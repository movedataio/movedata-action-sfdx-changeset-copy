"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const common_1 = require("../../common");
const utils_1 = require("../../utils");
const replacements_1 = require("../replacements");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
const ORIGINAL_SUFFIX_REGEX = new RegExp('(.)([a-zA-Z]+)(' + common_1.META_XML_SUFFIX + ')$');
/**
 * The default metadata transformer.
 *
 * If a metadata type doesn't have a transformer assigned to it, this one is used
 * during the conversion process. It leaves the component's metadata xml and source
 * files as-is.
 */
class DefaultMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    // eslint-disable-next-line @typescript-eslint/require-await, class-methods-use-this
    async toMetadataFormat(component) {
        return getWriteInfos(component, 'metadata');
    }
    // eslint-disable-next-line @typescript-eslint/require-await, class-methods-use-this
    async toSourceFormat(component, mergeWith) {
        return getWriteInfos(component, 'source', mergeWith);
    }
}
exports.DefaultMetadataTransformer = DefaultMetadataTransformer;
const getWriteInfos = (component, targetFormat, mergeWith) => component
    .walkContent()
    .map((path) => ({
    source: (0, replacements_1.getReplacementStreamForReadable)(component, path),
    output: getContentSourceDestination(path, targetFormat, component, mergeWith),
}))
    .concat(component.xml
    ? [
        {
            source: (0, replacements_1.getReplacementStreamForReadable)(component, component.xml),
            output: getXmlDestination(targetFormat, component, mergeWith),
        },
    ]
    : []);
// assumes component has content
const getContentSourceDestination = (source, targetFormat, component, mergeWith) => {
    if (mergeWith?.content) {
        if (component.tree.isDirectory(component.content)) {
            const relative = (0, utils_1.trimUntil)(source, (0, path_1.basename)(component.content));
            return (0, path_1.join)((0, path_1.dirname)(mergeWith.content), relative);
        }
        return mergeWith.content;
    }
    return component.getPackageRelativePath(source, targetFormat);
};
// assumes component has xml
const getXmlDestination = (targetFormat, component, mergeWith) => {
    if (mergeWith?.xml && targetFormat === 'source') {
        return mergeWith.xml;
    }
    const { folderContentType, suffix, legacySuffix } = component.type;
    let xmlDestination = component.getPackageRelativePath(component.xml, targetFormat);
    // quirks:
    // - append or strip the -meta.xml suffix to the path if there's no content and if it's not DigitalExperienceBundle
    //  for folder components:
    //    - remove file extension but preserve -meta.xml suffix if folder type and to 'metadata format'
    //    - insert file extension behind the -meta.xml suffix if folder type and to 'source format'
    if (!component.content && !['digitalexperiencebundle'].includes(component.type.id)) {
        if (targetFormat === 'metadata') {
            xmlDestination = folderContentType
                ? xmlDestination.replace(`.${suffix}`, '')
                : xmlDestination.slice(0, xmlDestination.lastIndexOf(common_1.META_XML_SUFFIX));
        }
        else {
            xmlDestination = folderContentType
                ? xmlDestination.replace(common_1.META_XML_SUFFIX, `.${suffix}${common_1.META_XML_SUFFIX}`)
                : `${xmlDestination}${common_1.META_XML_SUFFIX}`;
        }
    }
    else if (suffix) {
        if (component.type.name === 'Document' && targetFormat === 'metadata') {
            xmlDestination = xmlDestination.replace(new RegExp('.' + suffix + common_1.META_XML_SUFFIX + '$'), '.' + (0, utils_1.extName)(component.content) + common_1.META_XML_SUFFIX);
        }
        else {
            xmlDestination = xmlDestination.replace(ORIGINAL_SUFFIX_REGEX, '.' + suffix + common_1.META_XML_SUFFIX);
        }
    }
    if (legacySuffix && suffix && xmlDestination.includes(legacySuffix)) {
        xmlDestination = xmlDestination.replace(legacySuffix, suffix);
    }
    return xmlDestination;
};
//# sourceMappingURL=defaultMetadataTransformer.js.map