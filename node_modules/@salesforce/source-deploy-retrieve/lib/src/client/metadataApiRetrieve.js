"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataApiRetrieve = exports.RetrieveResult = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const fs = require("graceful-fs");
const unzipper = require("unzipper");
const ts_types_1 = require("@salesforce/ts-types");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const convert_1 = require("../convert");
const collections_1 = require("../collections");
const resolve_1 = require("../resolve");
const metadataTransfer_1 = require("./metadataTransfer");
const types_1 = require("./types");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/source-deploy-retrieve', 'sdr', [
    'error_no_job_id',
    'error_no_components_to_retrieve',
]);
const partialDeleteFileResponses = [];
class RetrieveResult {
    /**
     * @param response The metadata retrieve response from the server
     * @param components The ComponentSet of retrieved source components
     * @param localComponents The ComponentSet used to create the retrieve request
     */
    constructor(response, components, localComponents) {
        this.response = response;
        this.components = components;
        this.localComponents = new collections_1.ComponentSet(localComponents?.getSourceComponents());
    }
    getFileResponses() {
        if (this.response && this.fileResponses) {
            return this.fileResponses;
        }
        this.fileResponses = [];
        // construct failures
        if (this.response.messages) {
            const retrieveMessages = (0, kit_1.ensureArray)(this.response.messages);
            for (const message of retrieveMessages) {
                // match type name and fullname of problem component
                const matches = new RegExp(/.+'(.+)'.+'(.+)'/).exec(message.problem);
                if (matches) {
                    const [typeName, fullName] = matches.slice(1);
                    this.fileResponses.push({
                        fullName,
                        type: typeName,
                        state: types_1.ComponentStatus.Failed,
                        error: message.problem,
                        problemType: 'Error',
                    });
                }
                else {
                    this.fileResponses.push({
                        fullName: '',
                        type: '',
                        problemType: 'Error',
                        state: types_1.ComponentStatus.Failed,
                        error: message.problem,
                    });
                }
            }
        }
        // construct successes
        for (const retrievedComponent of this.components.getSourceComponents()) {
            const { fullName, type, xml } = retrievedComponent;
            const baseResponse = {
                fullName,
                type: type.name,
                state: this.localComponents.has(retrievedComponent) ? types_1.ComponentStatus.Changed : types_1.ComponentStatus.Created,
            };
            if (!type.children || Object.values(type.children.types).some((t) => t.unaddressableWithoutParent)) {
                for (const filePath of retrievedComponent.walkContent()) {
                    this.fileResponses.push(Object.assign({}, baseResponse, { filePath }));
                }
            }
            if (xml) {
                this.fileResponses.push(Object.assign({}, baseResponse, { filePath: xml }));
            }
        }
        // Add file responses for components that support partial delete (e.g., DigitalExperience)
        // where pieces of the component were deleted in the org, then retrieved.
        while (partialDeleteFileResponses.length) {
            this.fileResponses.push(partialDeleteFileResponses.pop());
        }
        return this.fileResponses;
    }
}
exports.RetrieveResult = RetrieveResult;
class MetadataApiRetrieve extends metadataTransfer_1.MetadataTransfer {
    constructor(options) {
        super(options);
        this.options = Object.assign({}, MetadataApiRetrieve.DEFAULT_OPTIONS, options);
    }
    /**
     * Check the status of the retrieve operation.
     *
     * @returns Status of the retrieve
     */
    async checkStatus() {
        if (!this.id) {
            throw new core_1.SfError(messages.getMessage('error_no_job_id', ['retrieve']), 'MissingJobIdError');
        }
        const coerceBoolean = (field) => {
            if ((0, ts_types_1.isString)(field)) {
                return field.toLowerCase() === 'true';
            }
            return (0, ts_types_1.asBoolean)(field, false);
        };
        const connection = await this.getConnection();
        // Cast RetrieveResult returned by jsForce to MetadataApiRetrieveStatus
        const status = (await connection.metadata.checkRetrieveStatus(this.id));
        status.fileProperties = (0, kit_1.ensureArray)(status.fileProperties);
        status.success = coerceBoolean(status.success);
        status.done = coerceBoolean(status.done);
        return status;
    }
    /**
     * Cancel the retrieve operation.
     *
     * Canceling a retrieve occurs immediately and requires no additional status
     * checks to the org, unlike {@link MetadataApiDeploy.cancel}.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async cancel() {
        this.canceled = true;
    }
    async post(result) {
        let components;
        const isMdapiRetrieve = this.options.format === 'metadata';
        if (result.status === types_1.RequestStatus.Succeeded) {
            const zipFileContents = Buffer.from(result.zipFile, 'base64');
            if (isMdapiRetrieve) {
                const name = this.options.zipFileName || 'unpackaged.zip';
                const zipFilePath = path.join(this.options.output, name);
                fs.writeFileSync(zipFilePath, zipFileContents);
                if (this.options.unzip) {
                    const dir = await unzipper.Open.buffer(zipFileContents);
                    const extractPath = path.join(this.options.output, path.parse(name).name);
                    await dir.extract({ path: extractPath });
                }
            }
            else {
                components = await this.extract(zipFileContents);
            }
        }
        components ?? (components = new collections_1.ComponentSet(undefined, this.options.registry));
        const retrieveResult = new RetrieveResult(result, components, this.components);
        if (!isMdapiRetrieve && !this.options.suppressEvents) {
            // This should only be done when retrieving source format since retrieving
            // mdapi format has no conversion or events/hooks
            await this.maybeSaveTempDirectory('source', components);
            await core_1.Lifecycle.getInstance().emit('scopedPostRetrieve', {
                retrieveResult,
                orgId: this.orgId,
            });
        }
        return retrieveResult;
    }
    async pre() {
        var _a, _b;
        const packageNames = this.getPackageNames();
        if (this.components.size === 0 && !packageNames?.length) {
            throw new core_1.SfError(messages.getMessage('error_no_components_to_retrieve'), 'MetadataApiRetrieveError');
        }
        const connection = await this.getConnection();
        const apiVersion = connection.getApiVersion();
        this.orgId = connection.getAuthInfoFields().orgId;
        (_a = this.components).apiVersion ?? (_a.apiVersion = apiVersion);
        (_b = this.components).sourceApiVersion ?? (_b.sourceApiVersion = apiVersion);
        // only do event hooks if source, (NOT a metadata format) retrieve
        if (this.options.components && !this.options.suppressEvents) {
            await core_1.Lifecycle.getInstance().emit('scopedPreRetrieve', {
                componentSet: this.options.components,
                orgId: this.orgId,
            });
        }
        const manifestData = (await this.components.getObject()).Package;
        const requestBody = {
            // This apiVersion is only used when the version in the package.xml (manifestData) is not defined.
            // see docs here: https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_retrieve_request.htm
            apiVersion: this.components.sourceApiVersion ?? (await connection.retrieveMaxApiVersion()),
            unpackaged: manifestData,
        };
        // if we're retrieving with packageNames add it
        // otherwise don't - it causes errors if undefined or an empty array
        if (packageNames?.length) {
            requestBody.packageNames = packageNames;
            // delete unpackaged when no components and metadata format to prevent
            // sending an empty unpackaged manifest.
            if (this.options.format === 'metadata' && this.components.size === 0) {
                delete requestBody.unpackaged;
            }
        }
        if (this.options.singlePackage) {
            requestBody.singlePackage = this.options.singlePackage;
        }
        // Debug output for API version used for retrieve
        const manifestVersion = manifestData.version;
        this.logger.debug(`Retrieving source in v${manifestVersion} shape using SOAP v${apiVersion}`);
        await core_1.Lifecycle.getInstance().emit('apiVersionRetrieve', { manifestVersion, apiVersion });
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore required callback
        return connection.metadata.retrieve(requestBody);
    }
    getPackageNames() {
        return this.getPackageOptions()?.map((pkg) => pkg.name);
    }
    getPackageOptions() {
        const { packageOptions } = this.options;
        if (packageOptions?.length) {
            if ((0, ts_types_1.isString)(packageOptions[0])) {
                const packageNames = packageOptions;
                return packageNames.map((pkg) => ({ name: pkg, outputDir: pkg }));
            }
            else {
                const pkgs = packageOptions;
                // If there isn't an outputDir specified, use the package name.
                return pkgs.map(({ name, outputDir }) => ({ name, outputDir: outputDir || name }));
            }
        }
    }
    async extract(zip) {
        const components = [];
        const { merge, output, registry } = this.options;
        const converter = new convert_1.MetadataConverter(registry);
        const tree = await resolve_1.ZipTreeContainer.create(zip);
        const packages = [{ zipTreeLocation: 'unpackaged', outputDir: output }];
        const packageOpts = this.getPackageOptions();
        // eslint-disable-next-line no-unused-expressions
        packageOpts?.forEach(({ name, outputDir }) => {
            packages.push({ zipTreeLocation: name, outputDir });
        });
        for (const pkg of packages) {
            const outputConfig = merge
                ? {
                    type: 'merge',
                    mergeWith: this.components.getSourceComponents(),
                    defaultDirectory: pkg.outputDir,
                    forceIgnoredPaths: this.components.forceIgnoredPaths ?? new Set(),
                }
                : {
                    type: 'directory',
                    outputDirectory: pkg.outputDir,
                };
            const zipComponents = collections_1.ComponentSet.fromSource({
                fsPaths: [pkg.zipTreeLocation],
                registry,
                tree,
            })
                .getSourceComponents()
                .toArray();
            if (merge) {
                this.handlePartialDeleteMerges(zipComponents, tree);
            }
            // this is intentional sequential
            // eslint-disable-next-line no-await-in-loop
            const convertResult = await converter.convert(zipComponents, 'source', outputConfig);
            if (convertResult) {
                components.push(...convertResult.converted);
            }
        }
        return new collections_1.ComponentSet(components, registry);
    }
    // Some bundle-like components can be partially deleted in the org, then retrieved. When this
    // happens, the deleted files need to be deleted on the file system and added to the FileResponses
    // that are returned by `RetrieveResult.getFileResponses()` for accuracy. The component types that
    // support this behavior are defined in the metadata registry with `"supportsPartialDelete": true`.
    // However, not all types can be partially deleted in the org. Currently this only applies to
    // DigitalExperienceBundle and ExperienceBundle.
    handlePartialDeleteMerges(retrievedComponents, tree) {
        const partialDeleteComponents = new Map();
        const mergeWithComponents = this.components.getSourceComponents().toArray();
        // Find all merge (local) components that support partial delete.
        mergeWithComponents.forEach((comp) => {
            if (comp.type.supportsPartialDelete && comp.content && fs.statSync(comp.content).isDirectory()) {
                const contentList = fs.readdirSync(comp.content);
                partialDeleteComponents.set(comp.fullName, { contentPath: comp.content, contentList });
            }
        });
        // If no partial delete components were in the mergeWith ComponentSet, no need to continue.
        if (partialDeleteComponents.size === 0) {
            return;
        }
        // Compare the contents of the retrieved components that support partial delete with the
        // matching merge components. If the merge components have files that the retrieved components
        // don't, delete the merge component and add all locally deleted files to the partial delete list
        // so that they are added to the `FileResponses` as deletes.
        retrievedComponents.forEach((comp) => {
            if (comp.type.supportsPartialDelete && partialDeleteComponents.has(comp.fullName)) {
                const localComp = partialDeleteComponents.get(comp.fullName);
                if (localComp.contentPath && tree.isDirectory(comp.content)) {
                    const remoteContentList = tree.readDirectory(comp.content);
                    const isForceIgnored = (filePath) => {
                        const ignored = comp.getForceIgnore().denies(filePath);
                        if (ignored) {
                            this.logger.debug(`Local component has ${filePath} while remote does not, but it is forceignored so ignoring.`);
                        }
                        return ignored;
                    };
                    localComp.contentList.forEach((fileName) => {
                        if (!remoteContentList.includes(fileName)) {
                            // If fileName is forceignored it is not counted as a diff. If fileName is a directory
                            // we have to read the contents to check forceignore status or we might get a false
                            // negative with `denies()` due to how the ignore library works.
                            const fileNameFullPath = path.join(localComp.contentPath, fileName);
                            if (fs.statSync(fileNameFullPath).isDirectory()) {
                                const nestedFiles = fs.readdirSync(fileNameFullPath);
                                if (nestedFiles.some((f) => isForceIgnored(path.join(fileNameFullPath, f)))) {
                                    return;
                                }
                            }
                            else if (isForceIgnored(fileNameFullPath)) {
                                return;
                            }
                            this.logger.debug(`Local component (${comp.fullName}) contains ${fileName} while remote component does not. This file is being removed.`);
                            const filePath = path.join(localComp.contentPath, fileName);
                            partialDeleteFileResponses.push({
                                fullName: comp.fullName,
                                type: comp.type.name,
                                state: types_1.ComponentStatus.Deleted,
                                filePath,
                            });
                            fs.rmSync(filePath, { recursive: true, force: true });
                        }
                    });
                }
            }
        });
    }
}
exports.MetadataApiRetrieve = MetadataApiRetrieve;
MetadataApiRetrieve.DEFAULT_OPTIONS = { merge: false };
//# sourceMappingURL=metadataApiRetrieve.js.map