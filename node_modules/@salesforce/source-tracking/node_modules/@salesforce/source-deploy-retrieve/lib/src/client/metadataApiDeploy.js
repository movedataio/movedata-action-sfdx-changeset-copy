"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataApiDeploy = exports.DeployResult = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const util_1 = require("util");
const ts_types_1 = require("@salesforce/ts-types");
const archiver_1 = require("archiver");
const fs = require("graceful-fs");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const convert_1 = require("../convert");
const collections_1 = require("../collections");
const registry_1 = require("../registry");
const streams_1 = require("../convert/streams");
const metadataTransfer_1 = require("./metadataTransfer");
const types_1 = require("./types");
const diagnosticUtil_1 = require("./diagnosticUtil");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/source-deploy-retrieve', 'sdr');
class DeployResult {
    constructor(response, components, replacements = new Map()) {
        this.response = response;
        this.components = components;
        this.replacements = replacements;
        this.diagnosticUtil = new diagnosticUtil_1.DiagnosticUtil('metadata');
        this.shouldConvertPaths = path_1.sep !== path_1.posix.sep;
    }
    getFileResponses() {
        // this involves FS operations, so only perform once!
        if (!this.fileResponses) {
            // TODO: Log when messages can't be mapped to components
            const responseMessages = this.getDeployMessages(this.response);
            const fileResponses = [];
            if (this.components) {
                for (const deployedComponent of this.components.getSourceComponents()) {
                    if (deployedComponent.type.children) {
                        for (const child of deployedComponent.getChildren()) {
                            const childMessages = responseMessages.get(this.key(child));
                            if (childMessages) {
                                fileResponses.push(...this.createResponses(child, childMessages));
                            }
                        }
                    }
                    const componentMessages = responseMessages.get(this.key(deployedComponent));
                    if (componentMessages) {
                        fileResponses.push(...this.createResponses(deployedComponent, componentMessages));
                    }
                }
                this.fileResponses = fileResponses.concat(this.deleteNotFoundToFileResponses(responseMessages));
            }
            else {
                // if no this.components, this was likely a metadata format deploy so we need to process
                // the componentSuccesses and componentFailures instead.
                const successes = (0, kit_1.ensureArray)(this.response.details?.componentSuccesses);
                const failures = (0, kit_1.ensureArray)(this.response.details?.componentFailures);
                for (const component of [...successes, ...failures]) {
                    if (component.fullName === 'package.xml')
                        continue;
                    const baseResponse = {
                        fullName: component.fullName,
                        type: component.componentType,
                        state: getState(component),
                        filePath: component.fileName.replace(`zip${path_1.sep}`, ''),
                    };
                    if (baseResponse.state === types_1.ComponentStatus.Failed) {
                        baseResponse.error = component.problem;
                        baseResponse.problemType = component.problemType;
                    }
                    fileResponses.push(baseResponse);
                }
                this.fileResponses = fileResponses;
            }
        }
        return this.fileResponses;
    }
    createResponses(component, responseMessages) {
        const { fullName, type, xml, content } = component;
        const responses = [];
        for (const message of responseMessages) {
            const baseResponse = {
                fullName,
                type: type.name,
                state: getState(message),
            };
            if (baseResponse.state === types_1.ComponentStatus.Failed) {
                const diagnostic = this.diagnosticUtil.parseDeployDiagnostic(component, message);
                const response = Object.assign(baseResponse, diagnostic);
                responses.push(response);
            }
            else {
                // components with children are already taken care of through the messages,
                // so don't walk their content directories.
                if (content &&
                    (!type.children || Object.values(type.children.types).some((t) => t.unaddressableWithoutParent))) {
                    for (const filePath of component.walkContent()) {
                        const response = { ...baseResponse, filePath };
                        responses.push(response);
                    }
                }
                if (xml) {
                    const response = { ...baseResponse, filePath: xml };
                    responses.push(response);
                }
            }
        }
        return responses;
    }
    /**
     * Groups messages from the deploy result by component fullName and type
     */
    getDeployMessages(result) {
        const messageMap = new Map();
        const failedComponents = new collections_1.ComponentSet();
        const failureMessages = (0, kit_1.ensureArray)(result.details.componentFailures);
        const successMessages = (0, kit_1.ensureArray)(result.details.componentSuccesses);
        for (const failure of failureMessages) {
            const sanitized = sanitizeDeployMessage(failure);
            const componentLike = {
                fullName: sanitized.fullName,
                type: sanitized.componentType,
            };
            const key = this.key(componentLike);
            if (!messageMap.has(key)) {
                messageMap.set(key, []);
            }
            messageMap.get(key)?.push(sanitized);
            failedComponents.add(componentLike);
        }
        for (const success of successMessages) {
            const sanitized = sanitizeDeployMessage(success);
            const componentLike = {
                fullName: sanitized.fullName,
                type: sanitized.componentType,
            };
            const key = this.key(componentLike);
            // this will ensure successes aren't reported if there is a failure for
            // the same component. e.g. lwc returns failures and successes
            if (!failedComponents.has(componentLike)) {
                messageMap.set(key, [sanitized]);
            }
        }
        return messageMap;
    }
    /**
     * If a component fails to delete because it doesn't exist in the org, you get a message like
     * key: 'ApexClass#destructiveChanges.xml'
     * value:[{
     * fullName: 'destructiveChanges.xml',
     * fileName: 'destructiveChanges.xml',
     * componentType: 'ApexClass',
     * problem: 'No ApexClass named: test1 found',
     * problemType: 'Warning'
     * }]
     */
    deleteNotFoundToFileResponses(messageMap) {
        return Array.from(messageMap)
            .filter(([key]) => key.includes('destructiveChanges') && key.endsWith('.xml'))
            .flatMap(([, messageArray]) => messageArray.filter(isComponentNotFoundWarningMessage))
            .flatMap((message) => {
            const fullName = message.problem.replace(`No ${message.componentType} named: `, '').replace(' found', '');
            return this.components
                ? this.components
                    .getComponentFilenamesByNameAndType({ fullName, type: message.componentType })
                    .map((fileName) => ({
                    fullName,
                    type: message.componentType,
                    filePath: fileName,
                    state: types_1.ComponentStatus.Deleted,
                }))
                : [];
        });
    }
    key(component) {
        const type = typeof component.type === 'string' ? component.type : component.type.name;
        return `${type}#${this.shouldConvertPaths ? component.fullName.split(path_1.sep).join(path_1.posix.sep) : component.fullName}`;
    }
}
exports.DeployResult = DeployResult;
class MetadataApiDeploy extends metadataTransfer_1.MetadataTransfer {
    constructor(options) {
        super(options);
        this.replacements = new Map();
        options.apiOptions = { ...MetadataApiDeploy.DEFAULT_OPTIONS.apiOptions, ...options.apiOptions };
        this.options = Object.assign({}, options);
        this.isRestDeploy = !!options.apiOptions?.rest;
    }
    /**
     * Deploy recently validated components without running Apex tests. Requires the operation to have been
     * created with the `{ checkOnly: true }` API option.
     *
     * Ensure that the following requirements are met before deploying a recent validation:
     * - The components have been validated successfully for the target environment within the last 10 days.
     * - As part of the validation, Apex tests in the target org have passed.
     * - Code coverage requirements are met.
     * - If all tests in the org or all local tests are run, overall code coverage is at least 75%, and Apex triggers have some coverage.
     * - If specific tests are run with the RunSpecifiedTests test level, each class and trigger that was deployed is covered by at least 75% individually.
     *
     * See [deployRecentValidation()](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_deployRecentValidation.htm)
     *
     * @param rest - Set to `true` to use the REST API, otherwise defaults to using SOAP
     * @returns The ID of the quick deployment
     */
    async deployRecentValidation(rest = false) {
        if (!this.id) {
            throw new core_1.SfError(messages.getMessage('error_no_job_id', ['deploy']), 'MissingJobIdError');
        }
        const conn = await this.getConnection();
        const response = (await conn.deployRecentValidation({
            id: this.id,
            rest,
        }));
        return (0, ts_types_1.isString)(response) ? response : response.id;
    }
    /**
     * Check the status of the deploy operation.
     *
     * @returns Status of the deploy
     */
    async checkStatus() {
        if (!this.id) {
            throw new core_1.SfError(messages.getMessage('error_no_job_id', ['deploy']), 'MissingJobIdError');
        }
        const connection = await this.getConnection();
        // Recasting to use the project's version of the type
        return connection.metadata.checkDeployStatus(this.id, true);
    }
    /**
     * Cancel the deploy operation.
     *
     * Deploys are asynchronously canceled. Once the cancel request is made to the org,
     * check the status of the cancellation with `checkStatus`.
     */
    async cancel() {
        if (!this.id) {
            throw new core_1.SfError(messages.getMessage('error_no_job_id', ['deploy']), 'MissingJobIdError');
        }
        const connection = await this.getConnection();
        // jsforce has an <any> on this
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,no-underscore-dangle
        await connection.metadata._invoke('cancelDeploy', { id: this.id });
    }
    async pre() {
        var _a, _b;
        const LifecycleInstance = core_1.Lifecycle.getInstance();
        const connection = await this.getConnection();
        const apiVersion = connection.getApiVersion();
        // store for use in the scopedPostDeploy event
        this.orgId = connection.getAuthInfoFields().orgId;
        // If we have a ComponentSet but no version info, use the apiVersion from the Connection.
        if (this.components) {
            // this is the SOAP/REST API version of the connection
            (_a = this.components).apiVersion ?? (_a.apiVersion = apiVersion);
            // this is used as the version in the manifest (package.xml).
            (_b = this.components).sourceApiVersion ?? (_b.sourceApiVersion = apiVersion);
        }
        // only do event hooks if source, (NOT a metadata format) deploy
        if (this.options.components) {
            await LifecycleInstance.emit('scopedPreDeploy', {
                componentSet: this.options.components,
                orgId: this.orgId,
            });
        }
        LifecycleInstance.on('replacement', async (replacement) => 
        // lifecycle have to be async, so wrapped in a promise
        new Promise((resolve) => {
            if (!this.replacements.has(replacement.filename)) {
                this.replacements.set(replacement.filename, new Set([replacement.replaced]));
            }
            else {
                this.replacements.get(replacement.filename)?.add(replacement.replaced);
            }
            resolve();
        }));
        const [zipBuffer] = await Promise.all([this.getZipBuffer(), this.maybeSaveTempDirectory('metadata')]);
        // SDR modifies what the mdapi expects by adding a rest param
        const { rest, ...optionsWithoutRest } = this.options.apiOptions ?? {};
        // Event and Debug output for API version and source API version used for deploy
        const manifestVersion = this.components?.sourceApiVersion;
        const webService = rest ? 'REST' : 'SOAP';
        const manifestMsg = manifestVersion ? ` in v${manifestVersion} shape` : '';
        const debugMsg = (0, util_1.format)(`Deploying metadata source%s using ${webService} v${apiVersion}`, manifestMsg);
        this.logger.debug(debugMsg);
        await LifecycleInstance.emit('apiVersionDeploy', { webService, manifestVersion, apiVersion });
        return this.isRestDeploy
            ? connection.metadata.deployRest(zipBuffer, optionsWithoutRest)
            : connection.metadata.deploy(zipBuffer, optionsWithoutRest);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async post(result) {
        const lifecycle = core_1.Lifecycle.getInstance();
        const connection = await this.getConnection();
        try {
            const apiVersion = connection.getApiVersion();
            // Creates an array of unique metadata types that were deployed, uses Set to avoid duplicates.
            let listOfMetadataTypesDeployed;
            if (this.options.components) {
                listOfMetadataTypesDeployed = Array.from(new Set(this.options.components.map((c) => c.type.name)));
            }
            else {
                // mdapi deploys don't have a ComponentSet, so using the result
                const types = new Set();
                const successes = (0, kit_1.ensureArray)(result.details?.componentSuccesses);
                const failures = (0, kit_1.ensureArray)(result.details?.componentFailures);
                [...successes, ...failures].forEach((c) => c.componentType && types.add(c.componentType));
                listOfMetadataTypesDeployed = Array.from(types);
            }
            void lifecycle.emitTelemetry({
                eventName: 'metadata_api_deploy_result',
                library: 'SDR',
                status: result.status,
                apiVersion,
                sourceApiVersion: this.components?.sourceApiVersion,
                createdDate: result.createdDate,
                startDate: result.startDate,
                completedDate: result.completedDate,
                rollbackOnError: result.rollbackOnError,
                runTestsEnabled: result.runTestsEnabled,
                isRestDeploy: this.isRestDeploy,
                checkOnly: result.checkOnly,
                done: result.done,
                ignoreWarnings: result.ignoreWarnings,
                metadataTypesDeployed: listOfMetadataTypesDeployed.toString(),
                numberComponentErrors: result.numberComponentErrors,
                numberComponentsDeployed: result.numberComponentsDeployed,
                numberComponentsTotal: result.numberComponentsTotal,
                numberTestErrors: result.numberTestErrors,
                numberTestsCompleted: result.numberTestsCompleted,
                numberTestsTotal: result.numberTestsTotal,
                testsTotalTime: result.details?.runTestResult?.totalTime,
                filesWithReplacementsQuantity: this.replacements.size ?? 0,
            });
        }
        catch (err) {
            const error = err;
            this.logger.debug(`Error trying to compile/send deploy telemetry data for deploy ID: ${this.id}\nError: ${error.message}`);
        }
        const deployResult = new DeployResult(result, this.components, new Map(Array.from(this.replacements).map(([k, v]) => [k, Array.from(v)])));
        // only do event hooks if source, (NOT a metadata format) deploy
        if (this.options.components) {
            // this may not be set if you resume a deploy so that `pre` is skipped.
            this.orgId ?? (this.orgId = connection.getAuthInfoFields().orgId);
            // previous step ensures string exists
            if (this.orgId) {
                await lifecycle.emit('scopedPostDeploy', { deployResult, orgId: this.orgId });
            }
        }
        return deployResult;
    }
    async getZipBuffer() {
        if (this.options.mdapiPath) {
            if (!fs.existsSync(this.options.mdapiPath) || !fs.lstatSync(this.options.mdapiPath).isDirectory()) {
                throw messages.createError('error_directory_not_found_or_not_directory', [this.options.mdapiPath]);
            }
            // make a zip from the given directory
            const zip = (0, archiver_1.create)('zip', { zlib: { level: 9 } });
            // anywhere not at the root level is fine
            zip.directory(this.options.mdapiPath, 'zip');
            // archiver/zip.finalize looks like it is async, because it extends streams, but it is not meant to be used that way
            // the typings on it are misleading and unintended.  More info https://github.com/archiverjs/node-archiver/issues/476
            // If you await it, bad things happen, like the convert process exiting silently.  https://github.com/forcedotcom/cli/issues/1791
            // leave the void as it is
            void zip.finalize();
            return (0, streams_1.stream2buffer)(zip);
        }
        // read the zip into a buffer
        if (this.options.zipPath) {
            if (!fs.existsSync(this.options.zipPath)) {
                throw new core_1.SfError(messages.getMessage('error_path_not_found', [this.options.zipPath]));
            }
            // does encoding matter for zip files? I don't know
            return fs.promises.readFile(this.options.zipPath);
        }
        if (this.options.components && this.components) {
            const converter = new convert_1.MetadataConverter();
            const { zipBuffer } = await converter.convert(this.components, 'metadata', { type: 'zip' });
            if (!zipBuffer) {
                throw new core_1.SfError(messages.getMessage('zipBufferError'));
            }
            return zipBuffer;
        }
        throw new Error('Options should include components, zipPath, or mdapiPath');
    }
}
exports.MetadataApiDeploy = MetadataApiDeploy;
MetadataApiDeploy.DEFAULT_OPTIONS = {
    apiOptions: {
        rollbackOnError: true,
        ignoreWarnings: false,
        checkOnly: false,
        singlePackage: true,
        rest: false,
    },
};
const getState = (message) => {
    if (message.created === 'true' || message.created === true) {
        return types_1.ComponentStatus.Created;
    }
    else if (message.changed === 'true' || message.changed === true) {
        return types_1.ComponentStatus.Changed;
    }
    else if (message.deleted === 'true' || message.deleted === true) {
        return types_1.ComponentStatus.Deleted;
    }
    else if (message.success === 'false' || message.success === false) {
        return types_1.ComponentStatus.Failed;
    }
    return types_1.ComponentStatus.Unchanged;
};
/**
 * Fix any issues with the deploy message returned by the api.
 * TODO: remove cases if fixes are made in the api.
 */
const sanitizeDeployMessage = (message) => {
    if (!hasComponentType(message)) {
        throw new core_1.SfError(`Missing componentType in deploy message ${message.fullName} ${message.fileName}`);
    }
    // mdapi error messages have the type as "FooSettings" but SDR only recognizes "Settings"
    if (message.componentType.endsWith('Settings') && message.fileName.endsWith('.settings')) {
        return {
            ...message,
            componentType: 'Settings',
        };
    }
    if (message.componentType === registry_1.registry.types.lightningcomponentbundle.name) {
        return {
            ...message,
            fullName: message.fullName.replace(/markup:\/\/[a-z|0-9|_]+:/i, ''),
        };
    }
    if (message.componentType === registry_1.registry.types.document.name) {
        return {
            ...message,
            // strip document extension from fullName
            fullName: (0, path_1.join)((0, path_1.dirname)(message.fullName), (0, path_1.basename)(message.fullName, (0, path_1.extname)(message.fullName))),
        };
    }
    // Treat emailTemplateFolder as EmailFolder
    if (message.componentType === registry_1.registry.types.emailtemplatefolder.name) {
        return {
            ...message,
            // strip document extension from fullName
            componentType: registry_1.registry.types.emailfolder.name,
        };
    }
    return message;
};
/* Type guard for asserting that a DeployMessages has a componentType, problem, and problemType === Warning*/
const isComponentNotFoundWarningMessage = (message) => hasComponentType(message) &&
    message.problemType === 'Warning' &&
    typeof message.problem === 'string' &&
    message.problem?.startsWith(`No ${message.componentType} named: `);
const hasComponentType = (message) => typeof message.componentType === 'string';
//# sourceMappingURL=metadataApiDeploy.js.map