"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticResourceMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path_1 = require("path");
const archiver_1 = require("archiver");
const mime_1 = require("mime");
const unzipper_1 = require("unzipper");
const graceful_fs_1 = require("graceful-fs");
const core_1 = require("@salesforce/core");
const utils_1 = require("../../utils");
const fileSystemHandler_1 = require("../../utils/fileSystemHandler");
const streams_1 = require("../streams");
const replacements_1 = require("../replacements");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/source-deploy-retrieve', 'sdr');
class StaticResourceMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    // allowed to preserve API
    // eslint-disable-next-line class-methods-use-this
    async toMetadataFormat(component) {
        const { content, type, xml } = component;
        if (!content) {
            throw messages.createError('noContentFound', [component.fullName, component.type.name]);
        }
        if (!xml) {
            throw messages.createError('error_parsing_xml', [component.fullName, component.type.name]);
        }
        // archiver/zip.finalize looks like it is async, because it extends streams, but it is not meant to be used that way
        // the typings on it are misleading and unintended.  More info https://github.com/archiverjs/node-archiver/issues/476
        // If you await it, bad things happen, like the convert process exiting silently.  https://github.com/forcedotcom/cli/issues/1791
        // leave the void as it is
        // eslint-disable-next-line @typescript-eslint/require-await
        const zipIt = async () => {
            // toolbelt was using level 9 for static resources, so we'll do the same.
            // Otherwise, you'll see errors like https://github.com/forcedotcom/cli/issues/1098
            const zip = (0, archiver_1.create)('zip', { zlib: { level: 9 } });
            if (!component.replacements) {
                // the easy way...no replacements required
                zip.directory(content, false);
            }
            else {
                // the hard way--we have to walk the content and do replacements on each of the files.
                for (const path of component.walkContent()) {
                    const replacementStream = (0, replacements_1.getReplacementStreamForReadable)(component, path);
                    zip.append(replacementStream, { name: (0, path_1.relative)(content, path) });
                }
            }
            void zip.finalize();
            return zip;
        };
        return [
            {
                source: (await componentIsExpandedArchive(component))
                    ? await zipIt()
                    : (0, replacements_1.getReplacementStreamForReadable)(component, content),
                output: (0, path_1.join)(type.directoryName, `${(0, utils_1.baseName)(content)}.${type.suffix}`),
            },
            {
                source: (0, replacements_1.getReplacementStreamForReadable)(component, xml),
                output: (0, path_1.join)(type.directoryName, (0, path_1.basename)(xml)),
            },
        ];
    }
    async toSourceFormat(component, mergeWith) {
        const { xml, content } = component;
        if (!content) {
            return [];
        }
        const componentContentType = await getContentType(component);
        const mergeContentPath = mergeWith?.content;
        const baseContentPath = getBaseContentPath(component, mergeWith);
        // only unzip an archive component if there isn't a merge component, or the merge component is itself expanded
        const shouldUnzipArchive = StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES.has(componentContentType) &&
            (!mergeWith || (mergeContentPath && mergeWith.tree.isDirectory(mergeContentPath)));
        if (shouldUnzipArchive) {
            // for the bulk of static resource writing we'll start writing ASAP
            // we'll still defer writing the resource-meta.xml file by pushing it onto the writeInfos
            await Promise.all((await openZipFile(component, content)).files
                .filter((f) => f.type === 'File')
                .map(async (f) => {
                const path = (0, path_1.join)(baseContentPath, f.path);
                const fullDest = (0, path_1.isAbsolute)(path)
                    ? path
                    : (0, path_1.join)(this.defaultDirectory ?? component.getPackageRelativePath('', 'source'), path);
                // push onto the pipeline and start writing now
                return this.pipeline(f.stream(), fullDest);
            }));
        }
        if (!xml) {
            throw messages.createError('error_parsing_xml', [component.fullName, component.type.name]);
        }
        return [
            {
                source: component.tree.stream(xml),
                output: mergeWith?.xml ?? component.getPackageRelativePath((0, path_1.basename)(xml), 'source'),
            },
        ].concat(shouldUnzipArchive
            ? []
            : [
                {
                    source: component.tree.stream(content),
                    output: `${baseContentPath}.${getExtensionFromType(componentContentType)}`,
                },
            ]);
    }
    /**
     * Only separated into its own method for unit testing purposes
     * I was unable to find a way to stub/spy a pipline() call
     *
     * @param stream the data to be written
     * @param destination the destination path to be written
     * @private
     */
    // eslint-disable-next-line class-methods-use-this
    async pipeline(stream, destination) {
        (0, fileSystemHandler_1.ensureFileExists)(destination);
        await (0, streams_1.pipeline)(stream, (0, graceful_fs_1.createWriteStream)(destination));
    }
}
exports.StaticResourceMetadataTransformer = StaticResourceMetadataTransformer;
StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES = new Set([
    'application/zip',
    'application/x-zip-compressed',
    'application/jar',
]);
const DEFAULT_CONTENT_TYPE = 'application/octet-stream';
const FALLBACK_TYPE_MAP = new Map([
    ['text/javascript', 'js'],
    ['application/x-javascript', 'js'],
    ['application/x-zip-compressed', 'zip'],
    ['text/x-haml', 'haml'],
    ['image/x-png', 'png'],
    ['text/xml', 'xml'],
]);
const getContentType = async (component) => {
    const resource = (await component.parseXml()).StaticResource;
    if (!resource || !Object.keys(resource).includes('contentType')) {
        throw new core_1.SfError(messages.getMessage('error_static_resource_missing_resource_file', [
            (0, path_1.join)('staticresources', component.name ?? component.xml ?? component.type.name),
        ]), 'LibraryError');
    }
    const output = resource.contentType ?? DEFAULT_CONTENT_TYPE;
    if (typeof output !== 'string') {
        throw new core_1.SfError(`Expected a string for contentType in ${component.name} (${component.xml}) but got ${output?.toString()}`);
    }
    return output;
};
const getBaseContentPath = (component, mergeWith) => {
    if (mergeWith?.content) {
        return (0, path_1.join)((0, path_1.dirname)(mergeWith.content), (0, utils_1.baseName)(mergeWith?.content));
    }
    if (typeof component.content === 'string') {
        const baseContentPath = component.getPackageRelativePath(component.content, 'source');
        return (0, path_1.join)((0, path_1.dirname)(baseContentPath), (0, utils_1.baseName)(baseContentPath));
    }
    throw new core_1.SfError(`Expected a content path for ${component.name} (${component.xml})`);
};
const getExtensionFromType = (contentType) => 
// return registered ext, fallback, or the default (application/octet-stream -> bin)
(0, mime_1.getExtension)(contentType) ?? FALLBACK_TYPE_MAP.get(contentType) ?? (0, mime_1.getExtension)(DEFAULT_CONTENT_TYPE) ?? 'bin';
const componentIsExpandedArchive = async (component) => {
    const { content, tree } = component;
    if (content && tree.isDirectory(content)) {
        const contentType = await getContentType(component);
        if (StaticResourceMetadataTransformer.ARCHIVE_MIME_TYPES.has(contentType)) {
            return true;
        }
        throw new core_1.SfError(messages.getMessage('error_static_resource_expected_archive_type', [contentType, component.name]), 'LibraryError');
    }
    return false;
};
/** wrapper around the Open command so we can emit a nicer error for bad zip files  */
async function openZipFile(component, content) {
    try {
        return await unzipper_1.Open.buffer(await component.tree.readFile(content));
    }
    catch (e) {
        throw new core_1.SfError(`Unable to open zip file ${content} for ${component.name} (${component.xml})`, 'BadZipFile', [
            'Check that your file really is a valid zip archive',
        ]);
    }
}
//# sourceMappingURL=staticResourceMetadataTransformer.js.map