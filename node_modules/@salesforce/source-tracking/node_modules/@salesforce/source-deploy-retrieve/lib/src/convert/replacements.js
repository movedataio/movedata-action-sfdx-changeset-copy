"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringToRegex = exports.matchesFile = exports.getReplacements = exports.getContentsOfReplacementFile = exports.getReplacementMarkingStream = exports.replacementIterations = exports.getReplacementStreamForReadable = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const promises_1 = require("fs/promises");
const stream_1 = require("stream");
const core_1 = require("@salesforce/core");
const minimatch = require("minimatch");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/source-deploy-retrieve', 'sdr');
const fileContentsCache = new Map();
/** If a component has replacements, you get it piped through the replacementStream
 * Otherwise, you'll get the original readable stream
 */
const getReplacementStreamForReadable = (component, path) => component.replacements?.[path]
    ? component.tree.stream(path).pipe(new ReplacementStream(component.replacements?.[path]))
    : component.tree.stream(path);
exports.getReplacementStreamForReadable = getReplacementStreamForReadable;
/**
 * A stream for replacing the contents of a single SourceComponent.
 *
 */
class ReplacementStream extends stream_1.Transform {
    constructor(replacements) {
        super({ objectMode: true });
        this.replacements = replacements;
    }
    async _transform(chunk, encoding, callback) {
        let error;
        // read and do the various replacements
        callback(error, Buffer.from(await (0, exports.replacementIterations)(chunk.toString(), this.replacements)));
    }
}
/**
 * perform an array of replacements on a string
 * emits warnings when an expected replacement target isn't found
 */
const replacementIterations = async (input, replacements) => {
    const lifecycleInstance = core_1.Lifecycle.getInstance();
    let output = input;
    for (const replacement of replacements) {
        // TODO: node 16+ has String.replaceAll for non-regex scenarios
        const regex = typeof replacement.toReplace === 'string' ? new RegExp(replacement.toReplace, 'g') : replacement.toReplace;
        const replaced = output.replace(regex, replacement.replaceWith);
        if (replaced !== output) {
            output = replaced;
            // eslint-disable-next-line no-await-in-loop
            await lifecycleInstance.emit('replacement', {
                filename: replacement.matchedFilename,
                replaced: replacement.toReplace.toString(),
            });
        }
        else if (replacement.singleFile) {
            // replacements need to be done sequentially
            // eslint-disable-next-line no-await-in-loop
            await lifecycleInstance.emitWarning(`Your sfdx-project.json specifies that ${replacement.toReplace.toString()} should be replaced in ${replacement.matchedFilename}, but it was not found.`);
        }
    }
    return output;
};
exports.replacementIterations = replacementIterations;
/**
 * Reads the project, gets replacements, removes any that aren't applicable due to environment conditionals, and returns an instance of the ReplacementMarkingStream
 */
const getReplacementMarkingStream = async (projectDir) => {
    // remove any that don't agree with current env
    const filteredReplacements = envFilter(await readReplacementsFromProject(projectDir));
    if (filteredReplacements.length) {
        return new ReplacementMarkingStream(filteredReplacements);
    }
};
exports.getReplacementMarkingStream = getReplacementMarkingStream;
/**
 * Stream for marking replacements on a component.
 * Returns a mutated component with a `replacements` property if any replacements are found.
 * Throws if any replacements reference a file or env that does not exist
 */
class ReplacementMarkingStream extends stream_1.Transform {
    constructor(replacementConfigs) {
        super({ objectMode: true });
        this.replacementConfigs = replacementConfigs;
    }
    async _transform(chunk, encoding, callback) {
        let err;
        // if deleting, or no configs, just pass through
        if (!chunk.isMarkedForDelete() && this.replacementConfigs?.length) {
            try {
                chunk.replacements = await (0, exports.getReplacements)(chunk, this.replacementConfigs);
            }
            catch (e) {
                if (!(e instanceof Error)) {
                    throw e;
                }
                err = e;
            }
        }
        callback(err, chunk);
    }
}
const getContentsOfReplacementFile = async (path) => {
    if (!fileContentsCache.has(path)) {
        try {
            fileContentsCache.set(path, (await (0, promises_1.readFile)(path, 'utf8')).trim());
        }
        catch (e) {
            throw messages.createError('replacementsFileNotRead', [path]);
        }
    }
    const output = fileContentsCache.get(path);
    if (!output) {
        throw messages.createError('replacementsFileNotRead', [path]);
    }
    return output;
};
exports.getContentsOfReplacementFile = getContentsOfReplacementFile;
/**
 * Build the replacements property for a sourceComponent
 */
const getReplacements = async (cmp, replacementConfigs = []) => {
    // all possible filenames for this component
    const filenames = [cmp.xml, ...cmp.walkContent()].filter(ts_types_1.isString);
    const replacementsForComponent = (await Promise.all(
    // build a nested array that can be run through Object.fromEntries
    // one MarkedReplacement[] for each file in the component
    filenames.map(async (f) => [
        f,
        await Promise.all(replacementConfigs
            // filter out any that don't match the current file
            .filter((r) => (0, exports.matchesFile)(f, r))
            .map(async (r) => ({
            matchedFilename: f,
            // used during replacement stream to limit warnings to explicit filenames, not globs
            singleFile: Boolean(r.filename),
            // Config is json which might use the regex.  If so, turn it into an actual regex
            toReplace: typeof r.stringToReplace === 'string'
                ? (0, exports.stringToRegex)(r.stringToReplace)
                : new RegExp(r.regexToReplace, 'g'),
            // get the literal replacement (either from env or file contents)
            replaceWith: typeof r.replaceWithEnv === 'string'
                ? getEnvValue(r.replaceWithEnv)
                : await (0, exports.getContentsOfReplacementFile)(r.replaceWithFile),
        }))),
    ])))
        // filter out any that don't have any replacements
        .filter(([, replacements]) => replacements.length > 0);
    if (replacementsForComponent.length) {
        // turn into a Dictionary-style object so it's easier to lookup by filename
        return Object.fromEntries(replacementsForComponent);
    }
};
exports.getReplacements = getReplacements;
const matchesFile = (f, r) => 
// filenames will be absolute.  We don't have convenient access to the pkgDirs,
// so we need to be more open than an exact match
Boolean((r.filename && f.endsWith(r.filename)) || (r.glob && minimatch(f, `**/${r.glob}`)));
exports.matchesFile = matchesFile;
/**
 * Regardless of any components, return the ReplacementConfig that are valid with the current env.
 * These can be checked globally and don't need to be checked per component.
 */
const envFilter = (replacementConfigs = []) => replacementConfigs.filter((replacement) => !replacement.replaceWhenEnv ||
    replacement.replaceWhenEnv.every((envConditional) => process.env[envConditional.env] === envConditional.value));
/** A "getter" for envs to throw an error when an expected env is not present */
const getEnvValue = (env) => (0, ts_types_1.ensureString)(new kit_1.Env().getString(env), `"${env}" is in sfdx-project.json as a value for "replaceWithEnv" property, but it's not set in your environment.`);
/**
 * Read the `replacement` property from sfdx-project.json
 */
const readReplacementsFromProject = async (projectDir) => {
    const proj = await core_1.SfProject.resolve(projectDir);
    const projJson = (await proj.resolveProjectConfig());
    return projJson.replacements ?? [];
};
/** escape any special characters used in the string so it can be used as a regex */
const stringToRegex = (input) => 
// being overly conservative
// eslint-disable-next-line no-useless-escape
new RegExp(input.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
exports.stringToRegex = stringToRegex;
//# sourceMappingURL=replacements.js.map