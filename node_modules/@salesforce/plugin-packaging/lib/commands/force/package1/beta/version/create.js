"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package1VersionCreateCommand = void 0;
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const packaging_1 = require("@salesforce/packaging");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package1_version_create');
class Package1VersionCreateCommand extends command_1.SfdxCommand {
    async run() {
        const version = this.parseVersion(this.flags.version);
        if (this.flags.wait) {
            // if we're waiting for the request, set up the listener
            core_1.Lifecycle.getInstance().on(packaging_1.PackageVersionEvents.create.progress, 
            // the 'on' method requires an async method, but we don't have any async calls
            // eslint-disable-next-line @typescript-eslint/require-await
            async (data) => {
                this.ux.log(`Package upload is ${data.pollingResult.Status === 'QUEUED' ? 'enqueued' : 'in progress'}. Waiting ${data.timeout} more seconds`);
            });
        }
        const result = await packaging_1.Package1Version.create(this.org.getConnection(), {
            MetadataPackageId: this.flags.packageid,
            VersionName: this.flags.name,
            Description: this.flags.description,
            MajorVersion: version.major,
            MinorVersion: version.minor,
            IsReleaseVersion: this.flags.managedreleased,
            ReleaseNotesUrl: this.flags.releasenotesurl,
            PostInstallUrl: this.flags.postinstallurl,
            Password: this.flags.installationkey,
        }, { frequency: kit_1.Duration.seconds(5), timeout: this.flags.wait ?? kit_1.Duration.seconds(0) });
        const arg = result.Status === 'SUCCESS' ? [result.MetadataPackageVersionId] : [result.Id, this.org.getUsername()];
        this.ux.log(messages.getMessage(result.Status, arg));
        return result;
    }
    // eslint-disable-next-line class-methods-use-this
    parseVersion(versionString) {
        const versions = versionString?.split('.');
        if (!versions) {
            // return nulls so when no version flag is provided, the server can infer the correct version
            return { major: null, minor: null };
        }
        if (versions.length === 2) {
            return {
                major: Number(versions[0]),
                minor: Number(versions[1]),
            };
        }
        else {
            throw messages.createError('package1VersionCreateCommandInvalidVersion', [versionString]);
        }
    }
}
exports.Package1VersionCreateCommand = Package1VersionCreateCommand;
Package1VersionCreateCommand.description = messages.getMessage('cliDescription');
Package1VersionCreateCommand.requiresUsername = true;
Package1VersionCreateCommand.requiresProject = true;
Package1VersionCreateCommand.flagsConfig = {
    packageid: command_1.flags.id({
        char: 'i',
        description: messages.getMessage('id'),
        longDescription: messages.getMessage('idLong'),
        required: true,
    }),
    name: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('name'),
        longDescription: messages.getMessage('nameLong'),
        required: true,
    }),
    description: command_1.flags.string({
        char: 'd',
        description: messages.getMessage('description'),
        longDescription: messages.getMessage('descriptionLong'),
    }),
    version: command_1.flags.string({
        char: 'v',
        description: messages.getMessage('version'),
        longDescription: messages.getMessage('versionLong'),
    }),
    managedreleased: command_1.flags.boolean({
        char: 'm',
        description: messages.getMessage('managedReleased'),
        longDescription: messages.getMessage('managedReleasedLong'),
    }),
    releasenotesurl: command_1.flags.url({
        char: 'r',
        description: messages.getMessage('releaseNotes'),
        longDescription: messages.getMessage('releaseNotesLong'),
    }),
    postinstallurl: command_1.flags.url({
        char: 'p',
        description: messages.getMessage('postInstall'),
        longDescription: messages.getMessage('postInstallLong'),
    }),
    installationkey: command_1.flags.string({
        char: 'k',
        description: messages.getMessage('installationKey'),
        longDescription: messages.getMessage('installationKeyLong'),
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('wait'),
        longDescription: messages.getMessage('waitLong'),
    }),
};
//# sourceMappingURL=create.js.map