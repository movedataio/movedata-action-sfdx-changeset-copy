"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageVersionListCommand = void 0;
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const packaging_1 = require("@salesforce/packaging");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package_version_list');
const packaging = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'packaging');
class PackageVersionListCommand extends command_1.SfdxCommand {
    async run() {
        const connection = this.hubOrg.getConnection();
        const project = core_1.SfProject.getInstance();
        const records = await packaging_1.Package.listVersions(connection, project, {
            createdLastDays: this.flags.createdlastdays,
            concise: this.flags.concise,
            modifiedLastDays: this.flags.modifiedlastdays,
            packages: this.flags.packages ?? [],
            isReleased: this.flags.released,
            orderBy: this.flags.orderby,
            verbose: this.flags.verbose,
        });
        const results = [];
        if (records?.length > 0) {
            let ancestorVersionsMap;
            // lookup ancestorVersions if ancestorIds are present
            const ancestorIds = records.filter((record) => record.AncestorId).map((record) => record.AncestorId);
            if (ancestorIds?.length > 0) {
                ancestorVersionsMap = await (0, packaging_1.getPackageVersionStrings)(ancestorIds, connection);
            }
            // Get the container options for each package version. We need this for determining if the version is OrgDependent
            const recordIds = [...new Set(records.map((record) => record.Package2Id))];
            const containerOptionsMap = await (0, packaging_1.getContainerOptions)(recordIds, connection);
            records.forEach((record) => {
                const ids = [record.Id, record.SubscriberPackageVersionId];
                const aliases = [];
                ids.forEach((id) => {
                    const matches = project.getAliasesFromPackageId(id);
                    if (matches.length > 0) {
                        aliases.push(matches);
                    }
                });
                const AliasStr = aliases.length > 0 ? aliases.join() : '';
                // set Ancestor display values
                let ancestorVersion = null;
                if (record.AncestorId) {
                    ancestorVersion = ancestorVersionsMap.get(record.AncestorId);
                }
                else if (containerOptionsMap.get(record.Package2Id) !== 'Managed') {
                    // display N/A if package is unlocked
                    ancestorVersion = 'N/A';
                    record.AncestorId = 'N/A';
                }
                const codeCoverage = record.CodeCoverage?.apexCodeCoveragePercentage != null
                    ? `${record.CodeCoverage.apexCodeCoveragePercentage.toString()}%`
                    : record.Package2.IsOrgDependent || record.ValidationSkipped
                        ? 'N/A'
                        : '';
                const hasPassedCodeCoverageCheck = record.Package2.IsOrgDependent === true || record.ValidationSkipped === true
                    ? 'N/A'
                    : record.HasPassedCodeCoverageCheck;
                const isOrgDependent = containerOptionsMap.get(record.Package2Id) === 'Managed'
                    ? 'N/A'
                    : record.Package2.IsOrgDependent
                        ? 'Yes'
                        : 'No';
                const hasMetadataRemoved = containerOptionsMap.get(record.Package2Id) !== 'Managed' ? 'N/A' : record.HasMetadataRemoved ? 'Yes' : 'No';
                results.push({
                    Package2Id: record.Package2Id,
                    Branch: record.Branch,
                    Tag: record.Tag,
                    MajorVersion: record.MajorVersion,
                    MinorVersion: record.MinorVersion,
                    PatchVersion: record.PatchVersion,
                    BuildNumber: record.BuildNumber,
                    Id: record.Id,
                    SubscriberPackageVersionId: record.SubscriberPackageVersionId,
                    ConvertedFromVersionId: record.ConvertedFromVersionId,
                    Name: record.Name,
                    NamespacePrefix: record.Package2.NamespacePrefix,
                    Package2Name: record.Package2.Name,
                    Description: record.Description,
                    Version: [record.MajorVersion, record.MinorVersion, record.PatchVersion, record.BuildNumber].join('.'),
                    // Table output needs string false to display 'false'
                    IsPasswordProtected: this.flags.json ? record.IsPasswordProtected : record.IsPasswordProtected.toString(),
                    IsReleased: this.flags.json ? record.IsReleased : record.IsReleased.toString(),
                    CreatedDate: new Date(record.CreatedDate).toISOString().replace('T', ' ').substring(0, 16),
                    LastModifiedDate: new Date(record.LastModifiedDate).toISOString().replace('T', ' ').substring(0, 16),
                    InstallUrl: packaging_1.INSTALL_URL_BASE.toString() + record.SubscriberPackageVersionId,
                    CodeCoverage: codeCoverage,
                    HasPassedCodeCoverageCheck: hasPassedCodeCoverageCheck,
                    ValidationSkipped: record.ValidationSkipped,
                    AncestorId: record.AncestorId,
                    AncestorVersion: ancestorVersion,
                    Alias: AliasStr,
                    IsOrgDependent: isOrgDependent,
                    ReleaseVersion: record.ReleaseVersion == null ? '' : Number.parseFloat(record.ReleaseVersion).toFixed(1),
                    BuildDurationInSeconds: record.BuildDurationInSeconds == null ? '' : record.BuildDurationInSeconds,
                    HasMetadataRemoved: hasMetadataRemoved,
                    CreatedBy: record.CreatedById,
                });
            });
            this.ux.styledHeader(`Package Versions [${results.length}]`);
            this.ux.table(results, this.getColumnData(), { 'no-truncate': true });
        }
        else {
            this.ux.log('No results found');
        }
        return results;
    }
    getColumnData() {
        if (this.flags.concise) {
            return {
                Package2Id: { header: messages.getMessage('packageId') },
                Version: { header: messages.getMessage('version') },
                SubscriberPackageVersionId: {
                    header: messages.getMessage('subscriberPackageVersionId'),
                },
                IsReleased: { header: 'Released' },
            };
        }
        const defaultCols = {
            Package2Name: { header: 'Package Name' },
            NamespacePrefix: { header: 'Namespace' },
            Name: { header: 'Version Name' },
            Version: { header: messages.getMessage('version') },
            SubscriberPackageVersionId: {
                header: messages.getMessage('subscriberPackageVersionId'),
            },
            Alias: { header: messages.getMessage('alias') },
            IsPasswordProtected: { header: messages.getMessage('installKey') },
            IsReleased: { header: 'Released' },
            ValidationSkipped: { header: messages.getMessage('validationSkipped') },
            AncestorId: { header: 'Ancestor' },
            AncestorVersion: { header: 'Ancestor Version' },
            Branch: { header: messages.getMessage('packageBranch') },
        };
        if (!this.flags.verbose) {
            return defaultCols;
        }
        else {
            // add additional columns for verbose output
            return {
                ...defaultCols,
                Package2Id: { header: messages.getMessage('packageId') },
                InstallUrl: { header: messages.getMessage('installUrl') },
                Id: { header: messages.getMessage('id') },
                CreatedDate: { header: 'Created Date' },
                LastModifiedDate: { header: 'Last Modified Date' },
                Tag: { header: messages.getMessage('packageTag') },
                Description: { header: messages.getMessage('description') },
                CodeCoverage: { header: messages.getMessage('codeCoverage') },
                HasPassedCodeCoverageCheck: {
                    header: messages.getMessage('hasPassedCodeCoverageCheck'),
                },
                ConvertedFromVersionId: {
                    header: messages.getMessage('convertedFromVersionId'),
                },
                IsOrgDependent: { header: messages.getMessage('isOrgDependent') },
                ReleaseVersion: { header: messages.getMessage('releaseVersion') },
                BuildDurationInSeconds: {
                    header: messages.getMessage('buildDurationInSeconds'),
                },
                HasMetadataRemoved: {
                    header: messages.getMessage('hasMetadataRemoved'),
                },
                CreatedBy: { header: messages.getMessage('createdBy') },
            };
        }
    }
}
exports.PackageVersionListCommand = PackageVersionListCommand;
PackageVersionListCommand.description = messages.getMessage('cliDescription');
PackageVersionListCommand.examples = messages.getMessage('examples').split(os.EOL);
PackageVersionListCommand.requiresDevhubUsername = true;
PackageVersionListCommand.flagsConfig = {
    createdlastdays: command_1.flags.number({
        char: 'c',
        description: packaging.getMessage('createdLastDaysDescription'),
        longDescription: packaging.getMessage('createdLastDaysLongDescription'),
    }),
    concise: command_1.flags.builtin({
        description: messages.getMessage('conciseDescription'),
        longDescription: messages.getMessage('conciseLongDescription'),
    }),
    modifiedlastdays: command_1.flags.number({
        char: 'm',
        description: packaging.getMessage('modifiedLastDaysDescription'),
        longDescription: packaging.getMessage('modifiedLastDaysLongDescription'),
    }),
    packages: command_1.flags.array({
        char: 'p',
        description: messages.getMessage('packagesDescription'),
        longDescription: messages.getMessage('packagesLongDescription'),
    }),
    released: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('releasedDescription'),
        longDescription: messages.getMessage('releasedLongDescription'),
    }),
    orderby: command_1.flags.array({
        char: 'o',
        description: messages.getMessage('orderByDescription'),
        longDescription: messages.getMessage('orderByLongDescription'),
    }),
    verbose: command_1.flags.builtin({
        description: messages.getMessage('verboseDescription'),
        longDescription: messages.getMessage('verboseLongDescription'),
    }),
};
//# sourceMappingURL=list.js.map