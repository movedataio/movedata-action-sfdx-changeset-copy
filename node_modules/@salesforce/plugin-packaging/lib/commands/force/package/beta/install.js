"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Install = void 0;
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const packaging_1 = require("@salesforce/packaging");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package_install');
// maps of command flag values to PackageInstallRequest values
const securityType = { AllUsers: 'full', AdminsOnly: 'none' };
const upgradeType = { Delete: 'delete-only', DeprecateOnly: 'deprecate-only', Mixed: 'mixed-mode' };
class Install extends command_1.SfdxCommand {
    static parseStatus(request, ux, installMsgs, username, alias) {
        const pkgIdOrAlias = alias ?? request.SubscriberPackageVersionKey;
        const { Status } = request;
        if (Status === 'SUCCESS') {
            ux.log(installMsgs.getMessage('packageInstallSuccess', [pkgIdOrAlias]));
        }
        else if (['IN_PROGRESS', 'UNKNOWN'].includes(Status)) {
            ux.log(installMsgs.getMessage('packageInstallInProgress', [request.Id, username]));
        }
        else {
            let errorMessage = '<empty>';
            const errors = request?.Errors?.errors;
            if (errors?.length) {
                errorMessage = 'Installation errors: ';
                for (let i = 0; i < errors.length; i++) {
                    errorMessage += `\n${i + 1}) ${errors[i].message}`;
                }
            }
            throw installMsgs.createError('packageInstallError', [errorMessage]);
        }
    }
    async run() {
        const noPrompt = this.flags.noprompt;
        this.connection = this.org.getConnection();
        const apiVersion = parseInt(this.connection.getApiVersion(), 10);
        if (apiVersion < 36) {
            throw messages.createError('apiVersionTooLow');
        }
        this.subscriberPackageVersion = new packaging_1.SubscriberPackageVersion({
            connection: this.connection,
            aliasOrId: this.flags.package,
            password: this.flags.installationkey,
        });
        const request = {
            SubscriberPackageVersionKey: await this.subscriberPackageVersion.getId(),
            Password: this.flags.installationkey,
            ApexCompileType: this.flags.apexcompile,
            SecurityType: securityType[this.flags.securitytype],
            UpgradeType: upgradeType[this.flags.upgradetype],
        };
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on(packaging_1.PackageEvents.install.warning, async (warningMsg) => {
            this.ux.log(warningMsg);
        });
        // If the user has specified --upgradetype Delete, then prompt for confirmation
        // unless the noprompt option has been included.
        if (this.flags.upgradetype === 'Delete') {
            await this.confirmUpgradeType(noPrompt);
        }
        // If the package has external sites, ask the user for permission to enable them
        // unless the noprompt option has been included.
        await this.confirmExternalSites(request, noPrompt);
        let installOptions;
        if (this.flags.wait) {
            installOptions = {
                publishTimeout: this.flags.publishwait,
                pollingTimeout: this.flags.wait,
            };
            let remainingTime = this.flags.wait;
            let timeThen = Date.now();
            this.ux.startSpinner(messages.getMessage('packageInstallWaiting', [remainingTime.minutes]));
            // waiting for publish to finish
            core_1.Lifecycle.getInstance().on(packaging_1.PackageEvents.install['subscriber-status'], 
            // eslint-disable-next-line @typescript-eslint/require-await
            async (publishStatus) => {
                const elapsedTime = kit_1.Duration.milliseconds(Date.now() - timeThen);
                timeThen = Date.now();
                remainingTime = kit_1.Duration.milliseconds(remainingTime.milliseconds - elapsedTime.milliseconds);
                const status = publishStatus === 'NO_ERRORS_DETECTED'
                    ? messages.getMessage('availableForInstallation')
                    : messages.getMessage('unavailableForInstallation');
                this.ux.setSpinnerStatus(messages.getMessage('packagePublishWaitingStatus', [remainingTime.minutes, status]));
            });
            // waiting for package install to finish
            core_1.Lifecycle.getInstance().on(packaging_1.PackageEvents.install.status, 
            // eslint-disable-next-line @typescript-eslint/require-await
            async (piRequest) => {
                const elapsedTime = kit_1.Duration.milliseconds(Date.now() - timeThen);
                timeThen = Date.now();
                remainingTime = kit_1.Duration.milliseconds(remainingTime.milliseconds - elapsedTime.milliseconds);
                this.ux.setSpinnerStatus(messages.getMessage('packageInstallWaitingStatus', [remainingTime.minutes, piRequest.Status]));
            });
        }
        const pkgInstallRequest = await this.subscriberPackageVersion.install(request, installOptions);
        this.ux.stopSpinner();
        Install.parseStatus(pkgInstallRequest, this.ux, messages, this.org.getUsername(), this.flags.package);
        return pkgInstallRequest;
    }
    async finally(err) {
        // Remove all the event listeners or they will still handle events
        core_1.Lifecycle.getInstance().removeAllListeners(packaging_1.PackageEvents.install.warning);
        core_1.Lifecycle.getInstance().removeAllListeners(packaging_1.PackageEvents.install.status);
        core_1.Lifecycle.getInstance().removeAllListeners(packaging_1.PackageEvents.install['subscriber-status']);
        await super.finally(err);
    }
    async confirmUpgradeType(noPrompt) {
        if ((await this.subscriberPackageVersion.getPackageType()) === 'Unlocked' && !noPrompt) {
            const promptMsg = messages.getMessage('promptUpgradeType');
            if (!(await this.ux.confirm(promptMsg))) {
                throw messages.createError('promptUpgradeTypeDeny');
            }
        }
    }
    async confirmExternalSites(request, noPrompt) {
        const extSites = await this.subscriberPackageVersion.getExternalSites();
        if (extSites) {
            let enableRss = true;
            if (!noPrompt) {
                const promptMsg = messages.getMessage('promptEnableRss', [extSites.join('\n')]);
                enableRss = await this.ux.confirm(promptMsg);
            }
            if (enableRss) {
                request.EnableRss = enableRss;
            }
        }
    }
}
exports.Install = Install;
Install.description = messages.getMessage('cliDescription');
Install.examples = messages.getMessage('examples').split(os.EOL);
Install.requiresUsername = true;
Install.flagsConfig = {
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('wait'),
        longDescription: messages.getMessage('waitLong'),
        default: kit_1.Duration.minutes(0),
    }),
    installationkey: command_1.flags.string({
        char: 'k',
        description: messages.getMessage('installationKey'),
        longDescription: messages.getMessage('installationKeyLong'),
    }),
    publishwait: command_1.flags.minutes({
        char: 'b',
        description: messages.getMessage('publishWait'),
        longDescription: messages.getMessage('publishWaitLong'),
        default: kit_1.Duration.minutes(0),
    }),
    noprompt: command_1.flags.boolean({
        char: 'r',
        description: messages.getMessage('noPrompt'),
        longDescription: messages.getMessage('noPromptLong'),
    }),
    package: command_1.flags.string({
        char: 'p',
        description: messages.getMessage('package'),
        longDescription: messages.getMessage('packageLong'),
        required: true,
    }),
    apexcompile: command_1.flags.enum({
        char: 'a',
        description: messages.getMessage('apexCompile'),
        longDescription: messages.getMessage('apexCompileLong'),
        default: 'all',
        options: ['all', 'package'],
    }),
    securitytype: command_1.flags.enum({
        char: 's',
        description: messages.getMessage('securityType'),
        longDescription: messages.getMessage('securityTypeLong'),
        default: 'AdminsOnly',
        options: ['AllUsers', 'AdminsOnly'],
    }),
    upgradetype: command_1.flags.enum({
        char: 't',
        description: messages.getMessage('upgradeType'),
        longDescription: messages.getMessage('upgradeTypeLong'),
        default: 'Mixed',
        options: ['DeprecateOnly', 'Mixed', 'Delete'],
    }),
};
//# sourceMappingURL=install.js.map