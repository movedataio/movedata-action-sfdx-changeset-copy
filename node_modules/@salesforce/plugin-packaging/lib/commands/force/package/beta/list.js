"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageListCommand = void 0;
const os = require("os");
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const packaging_1 = require("@salesforce/packaging");
const chalk = require("chalk");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package_list');
class PackageListCommand extends command_1.SfdxCommand {
    constructor() {
        super(...arguments);
        this.results = [];
    }
    async run() {
        this.logger = this.logger.child('package:list');
        const queryResult = await packaging_1.Package.list(this.hubOrg.getConnection());
        this.mapRecordsToResults(queryResult);
        this.displayResults();
        return this.results;
    }
    mapRecordsToResults(records) {
        if (records && records.length > 0) {
            this.results = records.map(({ Id, SubscriberPackageId, Name, Description, NamespacePrefix, ContainerOptions, ConvertedFromPackageId, IsOrgDependent, PackageErrorUsername, CreatedById, }) => ({
                Id,
                SubscriberPackageId,
                Name,
                Description,
                NamespacePrefix,
                ContainerOptions,
                ConvertedFromPackageId,
                Alias: this.project.getAliasesFromPackageId(Id).join(),
                IsOrgDependent: ContainerOptions === 'Managed' ? 'N/A' : IsOrgDependent ? 'Yes' : 'No',
                PackageErrorUsername,
                CreatedBy: CreatedById,
            }));
        }
    }
    displayResults() {
        this.ux.styledHeader(chalk.blue(`Packages [${this.results.length}]`));
        const columns = {
            NamespacePrefix: { header: messages.getMessage('namespace') },
            Name: { header: messages.getMessage('name') },
            Id: { header: messages.getMessage('id') },
            Alias: { header: messages.getMessage('alias') },
            Description: { header: messages.getMessage('description') },
            ContainerOptions: {
                header: messages.getMessage('packageType'),
            },
        };
        if (this.flags.verbose) {
            Object.assign(columns, {
                SubscriberPackageId: { header: messages.getMessage('packageId') },
                ConvertedFromPackageId: { header: messages.getMessage('convertedFromPackageId') },
                IsOrgDependent: { header: messages.getMessage('isOrgDependent') },
                PackageErrorUsername: { header: messages.getMessage('errorNotificationUsername') },
                CreatedBy: {
                    header: messages.getMessage('createdBy'),
                },
            });
        }
        this.ux.table(this.results, columns);
    }
}
exports.PackageListCommand = PackageListCommand;
PackageListCommand.description = messages.getMessage('cliDescription');
PackageListCommand.examples = messages.getMessage('examples').split(os.EOL);
PackageListCommand.requiresProject = true;
PackageListCommand.requiresDevhubUsername = true;
PackageListCommand.flagsConfig = {
    verbose: command_1.flags.builtin({
        description: messages.getMessage('verboseDescription'),
        longDescription: messages.getMessage('verboseLongDescription'),
    }),
};
//# sourceMappingURL=list.js.map