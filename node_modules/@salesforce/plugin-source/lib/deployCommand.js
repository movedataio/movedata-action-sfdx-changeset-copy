"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCoverageFormattersOptions = exports.createCoverageReport = exports.DeployCommand = exports.reportsFormatters = void 0;
const path = require("path");
const fs = require("fs");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const apex_node_1 = require("@salesforce/apex-node");
const sourceCommand_1 = require("./sourceCommand");
const stash_1 = require("./stash");
const coverageUtils_1 = require("./coverageUtils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-source', 'deployCommand', [
    'invalidDeployId',
    'MissingDeployId',
    'resultsDirMissing',
]);
exports.reportsFormatters = Object.keys(apex_node_1.DefaultReportOptions);
class DeployCommand extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.displayDeployId = (0, kit_1.once)((id) => {
            if (!this.isJsonOutput()) {
                this.ux.log(`Deploy ID: ${id}`);
            }
        });
        this.isRest = false;
        this.isAsync = false;
        this.updateDeployId = (0, kit_1.once)((id) => {
            this.displayDeployId(id);
            const stashKey = stash_1.Stash.getKey(this.id);
            stash_1.Stash.set(stashKey, { jobid: id });
        });
    }
    /**
     * Request a report of an in-progress or completed deployment.
     *
     * @param id the Deploy ID of a deployment request
     * @returns DeployResult
     */
    async report(id) {
        const deployId = this.resolveDeployId(id);
        this.displayDeployId(deployId);
        const res = await this.org.getConnection().metadata.checkDeployStatus(deployId, true);
        const deployStatus = res;
        const componentSet = this.componentSet || new source_deploy_retrieve_1.ComponentSet();
        return new source_deploy_retrieve_1.DeployResult(deployStatus, componentSet);
    }
    /**
     * Checks the response status to determine whether the deploy was successful.
     * Async deploys are successful unless an error is thrown, which resolves as
     * unsuccessful in oclif.
     */
    resolveSuccess() {
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.SucceededPartial, 68],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        if (!this.isAsync) {
            this.setExitCode(StatusCodeMap.get(this.deployResult.response?.status) ?? 1);
        }
    }
    /**
     * This method is here to provide a workaround to stubbing a constructor in the tests.
     *
     * @param id
     */
    createDeploy(id) {
        return new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection: this.org.getUsername(), id });
    }
    resolveDeployId(id) {
        if (id) {
            return id;
        }
        else {
            const stash = stash_1.Stash.get(stash_1.Stash.getKey(this.id));
            if (!stash) {
                throw new core_1.SfError(messages.getMessage('MissingDeployId'));
            }
            return stash.jobid;
        }
    }
    // SOAP is the default unless:
    //   1. SOAP is specified with the soapdeploy flag on the command
    //   2. The restDeploy SFDX config setting is explicitly true.
    isRestDeploy() {
        if ((0, ts_types_1.getBoolean)(this.flags, 'soapdeploy') === true) {
            this.logger.debug('soapdeploy flag === true.  Using SOAP');
            return false;
        }
        const restDeployConfig = this.configAggregator.getInfo(core_1.SfdxPropertyKeys.REST_DEPLOY).value;
        // aggregator property values are returned as strings
        if (restDeployConfig === 'false') {
            this.logger.debug('restDeploy SFDX config === false.  Using SOAP');
            return false;
        }
        else if (restDeployConfig === 'true') {
            this.logger.debug('restDeploy SFDX config === true.  Using REST');
            return true;
        }
        else {
            this.logger.debug('soapdeploy flag unset. restDeploy SFDX config unset.  Defaulting to SOAP');
        }
        return false;
    }
    async poll(deployId, options) {
        const waitFlag = this.getFlag('wait');
        const waitDuration = waitFlag.minutes === -1 ? kit_1.Duration.days(7) : waitFlag;
        const defaultOptions = {
            frequency: options?.frequency ?? kit_1.Duration.seconds(1),
            timeout: options?.timeout ?? waitDuration,
            poll: async () => {
                const deployResult = await this.report(deployId);
                return {
                    completed: (0, ts_types_1.getBoolean)(deployResult, 'response.done'),
                    payload: deployResult,
                };
            },
        };
        const pollingOptions = { ...defaultOptions, ...options };
        const pollingClient = await core_1.PollingClient.create(pollingOptions);
        return pollingClient.subscribe();
    }
    async deployRecentValidation() {
        const id = this.getFlag('validateddeployrequestid');
        const response = await this.org.getConnection().deployRecentValidation({ id, rest: this.isRest });
        // This is the deploy ID of the deployRecentValidation response, not
        // the already validated deploy ID (i.e., validateddeployrequestid).
        // REST returns an object with an ID, SOAP returns the id as a string.
        const validatedDeployId = (0, ts_types_1.isString)(response) ? response : response.id;
        this.updateDeployId(validatedDeployId);
        this.asyncDeployResult = { id: validatedDeployId };
        return this.isAsync ? this.report(validatedDeployId) : this.poll(validatedDeployId);
    }
    maybeCreateRequestedReports() {
        // only generate reports if test results are present
        if (this.deployResult.response?.numberTestsTotal) {
            if (this.flags.coverageformatters) {
                (0, exports.createCoverageReport)(this.deployResult, this.flags.coverageformatters, 'no-map', this.resultsDir);
            }
            if (this.flags.junit) {
                this.createJunitResults(this.deployResult);
            }
        }
    }
    createJunitResults(deployResult) {
        const testResult = (0, coverageUtils_1.transformDeployTestsResultsToTestResult)(this.org.getConnection(), deployResult.response?.details?.runTestResult);
        if (testResult.summary.testsRan > 0) {
            const jUnitReporter = new apex_node_1.JUnitReporter();
            const junitResults = jUnitReporter.format(testResult);
            const junitReportPath = path.join(this.resultsDir, 'junit');
            fs.mkdirSync(junitReportPath, { recursive: true });
            fs.writeFileSync(path.join(junitReportPath, 'junit.xml'), junitResults, 'utf8');
        }
    }
    // eslint-disable-next-line class-methods-use-this
    resolveOutputDir(coverageFormatters, junit, resultsDir, deployId, noThrow) {
        if (resultsDir) {
            return resultsDir;
        }
        if (coverageFormatters || junit) {
            if (deployId) {
                return deployId;
            }
            if (!noThrow) {
                throw new core_1.SfError(messages.getMessage('resultsDirMissing'));
            }
        }
        return undefined;
    }
}
exports.DeployCommand = DeployCommand;
// the basic sfdx flag is already making sure its of the correct length
DeployCommand.isValidDeployId = (id) => {
    if (id.startsWith('0Af')) {
        return true;
    }
    else {
        throw new core_1.SfError(messages.getMessage('invalidDeployId'), 'invalidDeployId');
    }
};
const createCoverageReport = (deployResult, formatters, sourceDir, resultsDir) => {
    const apexCoverage = (0, coverageUtils_1.transformCoverageToApexCoverage)((0, kit_1.ensureArray)(deployResult.response?.details?.runTestResult?.codeCoverage));
    fs.mkdirSync(resultsDir, { recursive: true });
    const options = (0, exports.getCoverageFormattersOptions)(formatters);
    const coverageReport = new apex_node_1.CoverageReporter(apexCoverage, resultsDir, sourceDir, options);
    coverageReport.generateReports();
};
exports.createCoverageReport = createCoverageReport;
const getCoverageFormattersOptions = (formatters = []) => {
    const reportFormats = formatters;
    const reportOptions = Object.fromEntries(reportFormats.map((format) => {
        const formatDefaults = apex_node_1.DefaultReportOptions[format];
        return [
            format,
            {
                ...formatDefaults,
                // always join any subdir from the defaults with our custom coverage dir
                ...('subdir' in formatDefaults ? { subdir: path.join('coverage', formatDefaults.subdir) } : {}),
                // if there is no subdir, we also put the file in the coverage dir, otherwise leave it alone
                ...('file' in formatDefaults && !('subdir' in formatDefaults)
                    ? { file: path.join('coverage', formatDefaults.file) }
                    : {}),
            },
        ];
    }));
    return {
        reportFormats,
        reportOptions,
    };
};
exports.getCoverageFormattersOptions = getCoverageFormattersOptions;
//# sourceMappingURL=deployCommand.js.map