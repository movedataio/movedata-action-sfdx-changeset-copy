"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSoqlQueryCommand = exports.SoqlQuery = void 0;
const os = require("os");
const fs = require("fs");
const command_1 = require("@salesforce/command");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const reporters_1 = require("../../../../reporters");
const dataSoqlQueryTypes_1 = require("../../../../dataSoqlQueryTypes");
const dataCommand_1 = require("../../../../dataCommand");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-data', 'soql.query');
const commonMessages = core_2.Messages.loadMessages('@salesforce/plugin-data', 'messages');
/**
 * Class to handle a soql query
 *
 * Will collect all records and the column metadata of the query
 */
class SoqlQuery {
    /**
     * Executs a SOQL query using the bulk 2.0 API
     *
     * @param connection
     * @param query
     * @param timeout
     * @param ux
     */
    async runBulkSoqlQuery(connection, query, timeout = kit_1.Duration.seconds(10), ux) {
        connection.bulk2.pollTimeout = timeout.milliseconds ?? kit_1.Duration.minutes(5).milliseconds;
        let res;
        try {
            res = (await connection.bulk2.query(query)) ?? [];
            return this.transformBulkResults(res, query);
        }
        catch (e) {
            const err = e;
            if (timeout.minutes === 0 && err.message.includes('Polling time out')) {
                // async query, so we can't throw an error, suggest force:data:query:report --queryid <id>
                ux.log(messages.getMessage('bulkQueryTimeout', [err.jobId, err.jobId, connection.getUsername()]));
                return { columns: [], result: { done: false, records: [], totalSize: 0, id: err.jobId }, query };
            }
            else {
                throw core_2.SfError.wrap(err);
            }
        }
    }
    /**
     * transforms Bulk 2.0 results to match the SOQL query results
     *
     * @param results results object
     * @param query query string
     */
    transformBulkResults(results, query) {
        /*
        bulk queries return a different payload, it's a [{column: data}, {column: data}]
        so we just need to grab the first object, find the keys (columns) and create the columns
         */
        const columns = Object.keys(results[0] ?? {}).map((name) => ({
            fieldType: dataSoqlQueryTypes_1.FieldType.field,
            name,
        }));
        return {
            columns,
            result: { done: true, records: results, totalSize: results.length },
            query,
        };
    }
    async runSoqlQuery(connection, query, logger, configAgg) {
        logger.debug('running query');
        // take the limit from the config, then default 50,000
        const queryOpts = {
            autoFetch: true,
            maxFetch: configAgg.getInfo('maxQueryLimit').value ?? 50000,
        };
        const result = await new Promise((resolve, reject) => {
            const records = [];
            const res = connection
                .query(query)
                .on('record', (rec) => records.push(rec))
                .on('error', (err) => reject(err))
                .on('end', () => {
                resolve({
                    done: true,
                    totalSize: (0, ts_types_1.getNumber)(res, 'totalSize', 0),
                    records,
                });
            })
                .run(queryOpts);
        });
        if (result.records.length && result.totalSize > result.records.length) {
            core_1.CliUx.ux.warn(`The query result is missing ${result.totalSize - result.records.length} records due to a ${queryOpts.maxFetch} record limit. Increase the number of records returned by setting the config value "maxQueryLimit" or the environment variable "SFDX_MAX_QUERY_LIMIT" to ${result.totalSize} or greater than ${queryOpts.maxFetch}.`);
        }
        logger.debug(`Query complete with ${result.totalSize} records returned`);
        const columns = result.totalSize ? await this.retrieveColumns(connection, query, logger) : [];
        return {
            query,
            columns,
            result,
        };
    }
    /**
     * Utility to fetch the columns involved in a soql query.
     *
     * Columns are then transformed into one of three types, Field, SubqueryField and FunctionField. List of
     * fields is returned as the product.
     *
     * @param connection
     * @param query
     */
    async retrieveColumns(connection, query, logger) {
        logger?.debug('fetching columns for query');
        // eslint-disable-next-line no-underscore-dangle
        const columnUrl = `${connection._baseUrl()}/query?q=${encodeURIComponent(query)}&columns=true`;
        const results = (0, ts_types_1.toJsonMap)(await connection.request(columnUrl));
        return this.recursivelyFindColumns((0, ts_types_1.ensureJsonArray)(results.columnMetadata));
    }
    recursivelyFindColumns(data) {
        const columns = [];
        for (let column of data) {
            column = (0, ts_types_1.ensureJsonMap)(column);
            const name = (0, ts_types_1.ensureString)(column.columnName);
            if ((0, ts_types_1.isJsonArray)(column.joinColumns) && column.joinColumns.length > 0) {
                if (column.aggregate) {
                    const field = {
                        fieldType: dataSoqlQueryTypes_1.FieldType.subqueryField,
                        name,
                        fields: [],
                    };
                    for (let subcolumn of column.joinColumns) {
                        subcolumn = (0, ts_types_1.ensureJsonMap)(subcolumn);
                        if ((0, ts_types_1.isJsonArray)(column.joinColumns) && column.joinColumns.length > 0) {
                            if (field.fields)
                                field.fields.push(...this.recursivelyFindColumns([subcolumn]));
                        }
                        else {
                            const f = {
                                fieldType: dataSoqlQueryTypes_1.FieldType.field,
                                name: (0, ts_types_1.ensureString)((0, ts_types_1.ensureJsonMap)(subcolumn).columnName),
                            };
                            if (field.fields)
                                field.fields.push(f);
                        }
                    }
                    columns.push(field);
                }
                else {
                    for (const subcolumn of column.joinColumns) {
                        const allSubFieldNames = this.searchSubColumnsRecursively(subcolumn);
                        for (const subFields of allSubFieldNames) {
                            columns.push({
                                fieldType: dataSoqlQueryTypes_1.FieldType.field,
                                name: `${name}.${subFields}`,
                            });
                        }
                    }
                }
            }
            else if (column.aggregate) {
                const field = {
                    fieldType: dataSoqlQueryTypes_1.FieldType.functionField,
                    name: (0, ts_types_1.ensureString)(column.displayName),
                };
                // If it isn't an alias, skip so the display name is used when messaging rows
                if (!/expr[0-9]+/.test(name)) {
                    field.alias = name;
                }
                columns.push(field);
            }
            else {
                columns.push({ fieldType: dataSoqlQueryTypes_1.FieldType.field, name });
            }
        }
        return columns;
    }
    searchSubColumnsRecursively(parent) {
        const column = (0, ts_types_1.ensureJsonMap)(parent);
        const name = (0, ts_types_1.ensureString)(column.columnName);
        let names = [name];
        const child = (0, ts_types_1.getArray)(parent, 'joinColumns');
        if (child.length) {
            // if we're recursively searching, reset the 'parent' - it gets added back below
            names = [];
            // recursively search for related column names
            child.map((c) => names.push(`${name}.${this.searchSubColumnsRecursively(c).join('.')}`));
        }
        return names;
    }
}
exports.SoqlQuery = SoqlQuery;
class DataSoqlQueryCommand extends dataCommand_1.DataCommand {
    /**
     * Command run implementation
     *
     * Returns either a DataSoqlQueryResult or a SfdxResult.
     * When the user is using global '--json' flag an instance of SfdxResult is returned.
     * This is necessary since '--json' flag reports results in the form of SfdxResult
     * and bypasses the definition of start result. The goal is to have the output
     * from '--json' and '--resulformat json' be the same.
     *
     * The DataSoqlQueryResult is necessary to communicate user selections to the reporters.
     * The 'this' object available during display() function does not include user input to
     * the command, which are necessary for reporter selection.
     *
     */
    async run() {
        try {
            if (this.flags.resultformat !== 'json')
                this.ux.startSpinner(messages.getMessage('queryRunningMessage'));
            const queryString = this.flags.query ?? fs.readFileSync(this.flags.soqlqueryfile, 'utf8');
            let queryResult;
            const soqlQuery = new SoqlQuery();
            if (this.flags.bulk) {
                queryResult = await soqlQuery.runBulkSoqlQuery(this.org.getConnection(), queryString, this.flags.wait, this.ux);
            }
            else {
                queryResult = await soqlQuery.runSoqlQuery(this.getConnection(), queryString, this.logger, this.configAggregator);
            }
            this.displayResults({ ...queryResult });
            return queryResult.result;
        }
        finally {
            if (this.flags.resultformat !== 'json')
                this.ux.stopSpinner();
        }
    }
    displayResults(queryResult) {
        // bypass if --json flag present
        if (!this.flags.json) {
            let reporter;
            switch (this.flags.resultformat) {
                case 'human':
                    reporter = new reporters_1.HumanReporter(queryResult, queryResult.columns, this.ux, this.logger);
                    break;
                case 'json':
                    reporter = new reporters_1.JsonReporter(queryResult, queryResult.columns, this.ux, this.logger);
                    break;
                case 'csv':
                    reporter = new reporters_1.CsvReporter(queryResult, queryResult.columns, this.ux, this.logger);
                    break;
                default:
                    throw new Error(`result format is invalid: ${this.flags.resultformat}`);
            }
            // delegate to selected reporter
            reporter.display();
        }
    }
}
exports.DataSoqlQueryCommand = DataSoqlQueryCommand;
DataSoqlQueryCommand.description = messages.getMessage('description');
DataSoqlQueryCommand.requiresUsername = true;
DataSoqlQueryCommand.examples = messages.getMessage('examples').split(os.EOL);
DataSoqlQueryCommand.flagsConfig = {
    query: command_1.flags.string({
        char: 'q',
        description: messages.getMessage('queryToExecute'),
        exclusive: ['soqlqueryfile'],
        exactlyOne: ['query', 'soqlqueryfile'],
    }),
    soqlqueryfile: command_1.flags.filepath({
        char: 'f',
        description: messages.getMessage('soqlqueryfile'),
        exclusive: ['query'],
        exactlyOne: ['query', 'soqlqueryfile'],
    }),
    usetoolingapi: command_1.flags.boolean({
        char: 't',
        description: messages.getMessage('queryToolingDescription'),
    }),
    bulk: command_1.flags.boolean({
        char: 'b',
        default: false,
        description: messages.getMessage('bulkDescription'),
        exclusive: ['usetoolingapi'],
    }),
    wait: command_1.flags.minutes({
        char: 'w',
        description: messages.getMessage('waitDescription'),
        dependsOn: ['bulk'],
    }),
    resultformat: command_1.flags.enum({
        char: 'r',
        description: messages.getMessage('resultFormatDescription'),
        options: ['human', 'csv', 'json'],
        default: 'human',
    }),
    perflog: command_1.flags.boolean({
        description: commonMessages.getMessage('perfLogLevelOption'),
        dependsOn: ['json'],
    }),
};
//# sourceMappingURL=query.js.map