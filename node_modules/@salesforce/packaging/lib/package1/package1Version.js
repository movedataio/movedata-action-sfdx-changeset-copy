"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package1Version = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const interfaces_1 = require("../interfaces");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package1Version');
/**
 * Provides the ability to get, list, and create 1st generation package versions.
 *
 * **Examples**
 *
 * List all 1GP package versions in the org:
 *
 * `const pkgList = await Package1Version.list(connection);`
 *
 * Create a new 1GP package vesion in the org:
 *
 * `const myPkg = await Package1Version.create(connection, options, pollingOptions);`
 *
 * More implementation examples are in the plugin here: https://github.com/salesforcecli/plugin-packaging/tree/main/src/commands/force/package1/
 */
class Package1Version {
    /**
     * Package1Version Constructor - Class to be used with 1st generation package versions
     *
     * @param connection: Connection to the org
     * @param id: 04t ID of the package version
     */
    constructor(connection, id) {
        this.connection = connection;
        this.id = id;
        if (!id.startsWith('04t')) {
            throw messages.createError('invalid04tId', [id]);
        }
    }
    /**
     * Will create a PackageUploadRequest object based on the options provided, will poll for completion if pollingOptions are provided
     *
     * @param connection: Connection to the org
     * @param options: Package1VersionCreateRequest options for the new PackageUploadRequest to be created with
     * @param pollingOptions: options to set frequency, and duration of polling. Default to not poll
     */
    static async create(connection, options, pollingOptions = { frequency: kit_1.Duration.seconds(5), timeout: kit_1.Duration.seconds(0) }) {
        if (!options.MetadataPackageId || !options.MetadataPackageId.startsWith('033')) {
            throw messages.createError('missingMetadataPackageId');
        }
        if (!options.VersionName) {
            throw messages.createError('missingVersionName');
        }
        const createRequest = await connection.tooling.sobject('PackageUploadRequest').create(options);
        if (pollingOptions.timeout.seconds) {
            const timeout = pollingOptions.timeout.seconds;
            const pollingClient = await core_1.PollingClient.create({
                poll: () => Package1Version.packageUploadPolling(connection, createRequest.id, timeout, pollingOptions.frequency.seconds),
                ...pollingOptions,
            });
            return pollingClient.subscribe();
        }
        else {
            // jsforce templates weren't working when setting the type to PackageUploadRequest, so we have to cast `as unknown as PackagingSObjects.PackageUploadRequest`
            return (await connection.tooling
                .sobject('PackageUploadRequest')
                .retrieve(createRequest.id));
        }
    }
    /**
     * Returns the status of a PackageUploadRequest
     *
     * @param connection Connection to the target org
     * @param id 0HD Id of the PackageUploadRequest
     */
    static async getCreateStatus(connection, id) {
        if (!id.startsWith('0HD')) {
            throw messages.createError('invalid0HDId', [id]);
        }
        return (await connection.tooling
            .sobject('PackageUploadRequest')
            .retrieve(id));
    }
    /**
     * Lists package versions available in the org. If package ID is supplied, only list versions of that package,
     * otherwise, list all package versions
     *
     * @param connection Connection to the org
     * @param id: optional, if present, ID of package to list versions for (starts with 033)
     * @returns Array of package version results
     */
    static async list(connection, id) {
        if (id && !id?.startsWith('033')) {
            // we have to check that it is present, and starts with 033
            // otherwise, undefined doesn't start with 033 and will trigger this error, when it shouldn't
            throw messages.createError('invalid033Id', [id]);
        }
        const query = `SELECT Id,MetadataPackageId,Name,ReleaseState,MajorVersion,MinorVersion,PatchVersion,BuildNumber FROM MetadataPackageVersion ${id ? `WHERE MetadataPackageId = '${id}'` : ''} ORDER BY MetadataPackageId, MajorVersion, MinorVersion, PatchVersion, BuildNumber`;
        return (await connection.tooling.query(query)).records;
    }
    static async packageUploadPolling(connection, id, timeout, frequency) {
        const pollingResult = await connection.tooling.sobject('PackageUploadRequest').retrieve(id);
        switch (pollingResult.Status) {
            case 'SUCCESS':
                return { completed: true, payload: pollingResult };
            case 'IN_PROGRESS':
            case 'QUEUED':
                timeout -= frequency;
                await core_1.Lifecycle.getInstance().emit(interfaces_1.Package1VersionEvents.create.progress, { timeout, pollingResult });
                return { completed: false, payload: pollingResult };
            default: {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                const errors = pollingResult?.Errors?.errors;
                if (errors?.length > 0) {
                    throw messages.createError('package1VersionCreateCommandUploadFailure', [
                        errors.map((e) => e.message).join(os.EOL),
                    ]);
                }
                else {
                    throw messages.createError('package1VersionCreateCommandUploadFailureDefault');
                }
            }
        }
    }
    /**
     * Queries the org for the package version with the given ID
     */
    async getPackageVersion() {
        const query = `SELECT Id, MetadataPackageId, Name, ReleaseState, MajorVersion, MinorVersion, PatchVersion, BuildNumber FROM MetadataPackageVersion WHERE id = '${this.id}'`;
        return (await this.connection.tooling.query(query)).records;
    }
}
exports.Package1Version = Package1Version;
//# sourceMappingURL=package1Version.js.map