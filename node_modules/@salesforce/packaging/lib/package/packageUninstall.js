"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uninstallPackage = exports.pollUninstall = exports.getUninstallErrors = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const interfaces_1 = require("../interfaces");
const packageUtils_1 = require("../utils/packageUtils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package_uninstall');
const pkgMessages = core_1.Messages.loadMessages('@salesforce/packaging', 'package');
async function getUninstallErrors(conn, id) {
    const errorQueryResult = await conn.tooling.query(`"SELECT Message FROM PackageVersionUninstallRequestError WHERE ParentRequest.Id = '${id}' ORDER BY Message"`);
    return errorQueryResult?.records || [];
}
exports.getUninstallErrors = getUninstallErrors;
async function pollUninstall(uninstallRequestId, conn, frequency, wait) {
    const poll = async (id) => {
        const uninstallRequest = (await conn.tooling
            .sobject('SubscriberPackageVersionUninstallRequest')
            .retrieve(id));
        switch (uninstallRequest.Status) {
            case 'Success': {
                return { completed: true, payload: uninstallRequest };
            }
            case 'InProgress':
            case 'Queued': {
                await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageEvents.uninstall, {
                    ...uninstallRequest,
                });
                return { completed: false, payload: uninstallRequest };
            }
            default: {
                const err = pkgMessages.getMessage('defaultErrorMessage', [id, uninstallRequest.Id]);
                const errorMessages = await getUninstallErrors(conn, id);
                const errors = errorMessages.map((error, index) => `(${index + 1}) ${error.Message}${os.EOL}`);
                const combinedErrors = errors.length ? `\n=== Errors\n${errors.join(os.EOL)}` : '';
                throw new core_1.SfError(`${err}${combinedErrors}`, 'UNINSTALL_ERROR', [messages.getMessage('uninstallErrorAction')]);
            }
        }
    };
    const pollingClient = await core_1.PollingClient.create({
        poll: () => poll(uninstallRequestId),
        frequency,
        timeout: wait,
    });
    return pollingClient.subscribe();
}
exports.pollUninstall = pollUninstall;
async function uninstallPackage(id, conn, frequency = kit_1.Duration.seconds(0), wait = kit_1.Duration.seconds(0)) {
    try {
        const uninstallRequest = await conn.tooling.sobject('SubscriberPackageVersionUninstallRequest').create({
            SubscriberPackageVersionId: id,
        });
        if (wait.seconds === 0) {
            return (await conn.tooling
                .sobject('SubscriberPackageVersionUninstallRequest')
                .retrieve(uninstallRequest.id));
        }
        else {
            return await pollUninstall(uninstallRequest.id, conn, frequency, wait);
        }
    }
    catch (err) {
        throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
    }
}
exports.uninstallPackage = uninstallPackage;
//# sourceMappingURL=packageUninstall.js.map