"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _PackageAncestry_requestedPackageId, _PackageAncestryNode_version, _PackageAncestryNode_MajorVersion, _PackageAncestryNode_MinorVersion, _PackageAncestryNode_PatchVersion, _PackageAncestryNode_BuildNumber, _PackageAncestryNode_AncestorId, _PackageAncestryNode_SubscriberPackageVersionId, _PackageAncestryNode_depthCounter;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageAncestryNode = exports.AncestryDotProducer = exports.AncestryJsonProducer = exports.AncestryTreeProducer = exports.PackageAncestry = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os_1 = require("os");
const core_1 = require("@salesforce/core");
const graphology_1 = require("graphology");
const kit_1 = require("@salesforce/kit");
const tree_1 = require("@oclif/core/lib/cli-ux/styled/tree");
const graphology_traversal_1 = require("graphology-traversal");
const pkgUtils = require("../utils/packageUtils");
const packageVersion_1 = require("./packageVersion");
const package_1 = require("./package");
const versionNumber_1 = require("./versionNumber");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package_ancestry');
const SELECT_PACKAGE_VERSION = 'SELECT AncestorId, SubscriberPackageVersionId, MajorVersion, MinorVersion, PatchVersion, BuildNumber FROM Package2Version';
// Add this to query calls to only show released package versions in the output
const releasedOnlyFilter = ' AND IsReleased = true';
const sortAncestryNodeData = (a, b) => {
    const aVersion = new versionNumber_1.VersionNumber(a.options.node.MajorVersion, a.options.node.MinorVersion, a.options.node.PatchVersion, a.options.node.BuildNumber);
    const bVersion = new versionNumber_1.VersionNumber(b.options.node.MajorVersion, b.options.node.MinorVersion, b.options.node.PatchVersion, b.options.node.BuildNumber);
    return aVersion.compareTo(bVersion);
};
/**
 * A class that represents the package ancestry graph.
 * Given a package Id (0Ho) or a package version Id (04t), it will build a graph of the package's ancestors.
 */
class PackageAncestry extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.options = options;
        _PackageAncestry_requestedPackageId.set(this, void 0);
        this.graph = new graphology_1.DirectedGraph();
    }
    get requestedPackageId() {
        return __classPrivateFieldGet(this, _PackageAncestry_requestedPackageId, "f");
    }
    async init() {
        await this.buildAncestryTree();
    }
    /**
     * Returns the internal representation of the requested package ancestry graph.
     */
    getAncestryGraph() {
        return this.graph;
    }
    /**
     * Convenience method to get the json representation of the package ancestry graph.
     */
    getJsonProducer() {
        return this.getRepresentationProducer((opts) => new AncestryJsonProducer(opts), this.requestedPackageId);
    }
    /**
     * Convenience method to get the CliUx.Tree representation of the package ancestry graph.
     */
    getTreeProducer(verbose) {
        return this.getRepresentationProducer((opts) => new AncestryTreeProducer({ ...opts, verbose: !!verbose }), this.requestedPackageId);
    }
    /**
     * Convenience method to get the dot representation of the package ancestry graph.
     */
    getDotProducer() {
        return this.getRepresentationProducer((opts) => new AncestryDotProducer(opts), this.requestedPackageId);
    }
    /**
     * Returns the producer representation of the package ancestry graph.
     *
     * @param producerCtor - function that returns a new instance of the producer
     * @param root - the subscriber package version id of the root node
     */
    getRepresentationProducer(producerCtor, root) {
        const treeRoot = root
            ? this.graph.findNode((node, attributes) => attributes.node.SubscriberPackageVersionId === root)
            : undefined;
        const tree = producerCtor();
        const treeStack = [];
        function handleNode(node, attr, depth) {
            if (treeStack.length > depth) {
                treeStack.splice(depth);
            }
            let t = treeStack[depth];
            if (!t) {
                t = producerCtor({ node: attr.node, depth });
                treeStack.push(t);
            }
            if (depth === 0) {
                tree.addNode(t);
            }
            else {
                treeStack[depth - 1].addNode(t);
            }
        }
        if (treeRoot) {
            (0, graphology_traversal_1.dfsFromNode)(this.graph, treeRoot, handleNode);
        }
        else {
            (0, graphology_traversal_1.dfs)(this.graph, handleNode);
        }
        return tree;
    }
    /**
     * Returns a list of ancestry nodes that represent the path from subscriber package version id to the root of the
     * package ancestry tree.
     *
     * @param subscriberPackageVersionId
     */
    getLeafPathToRoot(subscriberPackageVersionId) {
        const root = this.graph.findNode((node, attributes) => attributes.node.AncestorId === null);
        const paths = [];
        let path = [];
        let previousDepth = 0;
        (0, graphology_traversal_1.dfsFromNode)(this.graph, root, (node, attr, depth) => {
            if (depth === 0) {
                paths.push(path);
                path = [];
            }
            else if (depth <= previousDepth) {
                paths.push(path);
                path = path.slice(0, depth);
            }
            previousDepth = depth;
            path.push(attr.node);
        });
        // push remaining path
        paths.push(path);
        return (paths
            .filter(
        // eslint-disable-next-line @typescript-eslint/no-shadow
        (path) => path.length > 0 && // don't care about zero length paths
            (!subscriberPackageVersionId ||
                path.some((node) => node.SubscriberPackageVersionId === subscriberPackageVersionId)))
            // eslint-disable-next-line @typescript-eslint/no-shadow
            .map((path) => path.reverse())
            // eslint-disable-next-line @typescript-eslint/no-shadow
            .map((path) => {
            const subscriberPackageVersionIdIndex = path.findIndex((node) => node.SubscriberPackageVersionId === subscriberPackageVersionId);
            return path.slice(subscriberPackageVersionIdIndex === -1 ? 0 : subscriberPackageVersionIdIndex);
        }));
    }
    async buildAncestryTree() {
        this.roots = await this.getRoots();
        await this.buildAncestryTreeFromRoots(this.roots);
    }
    async getRoots() {
        let roots = [];
        __classPrivateFieldSet(this, _PackageAncestry_requestedPackageId, this.options.project.getPackageIdFromAlias(this.options.packageId) ?? this.options.packageId, "f");
        switch (this.requestedPackageId.slice(0, 3)) {
            case '0Ho':
                pkgUtils.validateId(pkgUtils.BY_LABEL.PACKAGE_ID, this.requestedPackageId);
                roots = await this.findRootsForPackage();
                break;
            case '04t':
                pkgUtils.validateId(pkgUtils.BY_LABEL.SUBSCRIBER_PACKAGE_VERSION_ID, this.requestedPackageId);
                roots = await this.findRootsForPackageVersion();
                break;
            default:
                throw messages.createError('idOrAliasNotFound', [this.requestedPackageId]);
        }
        await this.validatePackageType();
        return roots;
    }
    async findRootsForPackageVersion() {
        // Start with the node, and shoot up
        let node = await this.getPackageVersion(this.requestedPackageId);
        while (node.AncestorId !== null) {
            // eslint-disable-next-line no-await-in-loop
            const ancestor = await this.getPackageVersion(node.AncestorId);
            this.addToGraph(ancestor, node);
            node = ancestor;
        }
        return [node];
    }
    async validatePackageType() {
        // Check to see if the package version is part of an unlocked package
        // if so, throw an error since ancestry only applies to managed packages
        let packageType;
        switch (this.requestedPackageId.slice(0, 3)) {
            case '04t':
                // eslint-disable-next-line no-case-declarations
                const packageVersion = new packageVersion_1.PackageVersion({
                    idOrAlias: this.requestedPackageId,
                    project: this.options.project,
                    connection: this.options.connection,
                });
                packageType = await packageVersion.getPackageType();
                break;
            case '0Ho':
                // eslint-disable-next-line no-case-declarations
                const pkg = new package_1.Package({
                    packageAliasOrId: this.requestedPackageId,
                    project: this.options.project,
                    connection: this.options.connection,
                });
                packageType = await pkg.getType();
                break;
        }
        if (packageType !== 'Managed') {
            throw messages.createError('unlockedPackageError');
        }
    }
    async getPackageVersion(nodeId) {
        const query = `${SELECT_PACKAGE_VERSION} WHERE SubscriberPackageVersionId = '${nodeId}'`;
        try {
            const results = await this.options.connection.singleRecordQuery(query, {
                tooling: true,
            });
            return new PackageAncestryNode(results);
        }
        catch (e) {
            if (e.message.includes('No record found for')) {
                throw messages.createError('versionNotFound', [nodeId]);
            }
            throw e;
        }
    }
    async findRootsForPackage() {
        // Check to see if the package is an unlocked package
        // if so, throw and error since ancestry only applies to managed packages
        await this.validatePackageType();
        const normalQuery = `${SELECT_PACKAGE_VERSION} WHERE AncestorId = NULL AND Package2Id = '${this.requestedPackageId}' ${releasedOnlyFilter}`;
        const subscriberPackageVersions = (await this.options.connection.tooling.query(normalQuery)).records?.map((record) => new PackageAncestryNode(record));
        // The package exists, but there are no versions for the provided package
        if (subscriberPackageVersions.length === 0) {
            throw messages.createError('noVersionsError');
        }
        return subscriberPackageVersions;
    }
    async buildAncestryTreeFromRoots(roots) {
        while (roots.length > 0) {
            const subscriberPackageVersion = roots.shift();
            // eslint-disable-next-line no-await-in-loop
            const descendants = await this.addDescendantsFromPackageVersion(subscriberPackageVersion);
            roots.push(...descendants);
        }
    }
    async addDescendantsFromPackageVersion(subscriberPackageVersion) {
        const descendants = await this.getDescendants(subscriberPackageVersion);
        descendants.forEach((descendant) => this.addToGraph(subscriberPackageVersion, descendant));
        return descendants;
    }
    addToGraph(ancestor, descendant) {
        if (!this.graph.hasNode(ancestor.getVersion())) {
            this.graph.addNode(ancestor.getVersion(), { node: ancestor });
        }
        if (!this.graph.hasNode(descendant.getVersion())) {
            this.graph.addNode(descendant.getVersion(), { node: descendant });
        }
        if (!this.graph.hasEdge(ancestor.getVersion(), descendant.getVersion())) {
            this.graph.addDirectedEdgeWithKey(`${ancestor.getVersion()}->${descendant.getVersion()}`, ancestor.getVersion(), descendant.getVersion(), {
                from: ancestor.getVersion(),
                to: descendant.getVersion(),
            });
        }
    }
    async getDescendants(ancestor) {
        const query = `${SELECT_PACKAGE_VERSION} WHERE AncestorId = '${ancestor.SubscriberPackageVersionId}' ${releasedOnlyFilter}`;
        const results = await this.options.connection.tooling.query(query);
        return results.records.map((result) => new PackageAncestryNode(result));
    }
}
exports.PackageAncestry = PackageAncestry;
_PackageAncestry_requestedPackageId = new WeakMap();
class AncestryTreeProducer extends tree_1.Tree {
    constructor(options) {
        super();
        this.verbose = false;
        this.options = options;
        this.label = this.options?.node?.getVersion() || 'root';
        this.verbose = this.options?.verbose || false;
    }
    addNode(node) {
        const label = this.createLabel(node);
        this.insert(label, node);
    }
    produce() {
        const producers = [];
        producers.push(this);
        while (producers.length > 0) {
            const producer = producers.shift();
            Object.values(producer.nodes)
                .sort((a, b) => a.options.node.version.compareTo(b.options.node.version))
                .forEach((child) => {
                delete producer.nodes[this.createLabel(child)];
                producer.addNode(child);
                producers.push(child);
            });
        }
        this.display(this.options ? this.options['logger'] : undefined);
    }
    createLabel(node) {
        const subscriberId = this.verbose && node?.options?.node?.SubscriberPackageVersionId
            ? ` (${node.options.node.SubscriberPackageVersionId})`
            : '';
        return node?.label ? `${node.label}${subscriberId}` : 'root';
    }
}
exports.AncestryTreeProducer = AncestryTreeProducer;
class AncestryJsonProducer {
    constructor(options) {
        this.children = [];
        this.options = options;
        this.label = this.options?.node?.getVersion() || 'root';
        this.data = {
            children: [],
            data: {
                SubscriberPackageVersionId: this.options?.node?.SubscriberPackageVersionId,
                MajorVersion: this.options?.node?.MajorVersion,
                MinorVersion: this.options?.node?.MinorVersion,
                PatchVersion: this.options?.node?.PatchVersion,
                BuildNumber: this.options?.node?.BuildNumber,
                depthCounter: this.options?.depth,
            },
        };
    }
    addNode(node) {
        this.data.children.push(node.data);
        this.children.push(node);
    }
    produce() {
        const producers = [];
        producers.push(this);
        while (producers.length > 0) {
            const producer = producers.shift();
            producer.children.sort(sortAncestryNodeData);
            producers.push(...producer.children);
        }
        return this.data.children[0];
    }
}
exports.AncestryJsonProducer = AncestryJsonProducer;
class AncestryDotProducer {
    constructor(options) {
        this.children = [];
        this.options = options;
        this.label = this.options?.node?.getVersion() || 'root';
    }
    /**
     * Builds a node line in DOT, of the form nodeID [label="MAJOR.MINOR.PATCH"]
     *
     * @param currentNode
     */
    static buildDotNode(currentNode) {
        return `\t node${currentNode.options.node.SubscriberPackageVersionId} [label="${currentNode.label}"]`;
    }
    /**
     * Builds an edge line in DOT, of the form fromNode -- toNode
     *
     * @param fromNode
     * @param toNode
     */
    static buildDotEdge(fromNode, toNode) {
        return `\t node${fromNode.options.node.SubscriberPackageVersionId} -- node${toNode.options.node.SubscriberPackageVersionId}`;
    }
    addNode(node) {
        this.children.push(node);
    }
    produce() {
        const producers = [];
        producers.push(this);
        const dotLines = [];
        while (producers.length > 0) {
            const producer = producers.shift();
            if (producer.options) {
                dotLines.push(AncestryDotProducer.buildDotNode(producer));
            }
            producer.children.sort(sortAncestryNodeData);
            producers.push(...producer.children);
        }
        producers.push(this);
        while (producers.length > 0) {
            const producer = producers.shift();
            if (producer.options) {
                producer.children.forEach((child) => dotLines.push(AncestryDotProducer.buildDotEdge(producer, child)));
            }
            producers.push(...producer.children);
        }
        return `strict graph G {${os_1.EOL}${dotLines.join(os_1.EOL)}${os_1.EOL}}`;
    }
}
exports.AncestryDotProducer = AncestryDotProducer;
class PackageAncestryNode extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.options = options;
        _PackageAncestryNode_version.set(this, void 0);
        _PackageAncestryNode_MajorVersion.set(this, void 0);
        _PackageAncestryNode_MinorVersion.set(this, void 0);
        _PackageAncestryNode_PatchVersion.set(this, void 0);
        _PackageAncestryNode_BuildNumber.set(this, void 0);
        _PackageAncestryNode_AncestorId.set(this, void 0);
        _PackageAncestryNode_SubscriberPackageVersionId.set(this, void 0);
        _PackageAncestryNode_depthCounter.set(this, void 0);
        __classPrivateFieldSet(this, _PackageAncestryNode_version, new versionNumber_1.VersionNumber(this.options.MajorVersion, this.options.MinorVersion, this.options.PatchVersion, this.options.BuildNumber), "f");
        __classPrivateFieldSet(this, _PackageAncestryNode_AncestorId, this.options.AncestorId, "f");
        __classPrivateFieldSet(this, _PackageAncestryNode_SubscriberPackageVersionId, this.options.SubscriberPackageVersionId, "f");
        __classPrivateFieldSet(this, _PackageAncestryNode_MajorVersion, typeof this.options.MajorVersion === 'number'
            ? this.options.MajorVersion
            : parseInt(this.options.MajorVersion, 10), "f");
        __classPrivateFieldSet(this, _PackageAncestryNode_MinorVersion, typeof this.options.MinorVersion === 'number'
            ? this.options.MinorVersion
            : parseInt(this.options.MinorVersion, 10), "f");
        __classPrivateFieldSet(this, _PackageAncestryNode_PatchVersion, typeof this.options.PatchVersion === 'number'
            ? this.options.PatchVersion
            : parseInt(this.options.PatchVersion, 10), "f");
        __classPrivateFieldSet(this, _PackageAncestryNode_BuildNumber, this.options.BuildNumber, "f");
    }
    get AncestorId() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_AncestorId, "f");
    }
    get SubscriberPackageVersionId() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_SubscriberPackageVersionId, "f");
    }
    get version() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_version, "f");
    }
    get MinorVersion() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_MinorVersion, "f");
    }
    get PatchVersion() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_PatchVersion, "f");
    }
    get BuildNumber() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_BuildNumber, "f");
    }
    get MajorVersion() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_MajorVersion, "f");
    }
    get depthCounter() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_depthCounter, "f");
    }
    getVersion() {
        return __classPrivateFieldGet(this, _PackageAncestryNode_version, "f").toString();
    }
    // eslint-disable-next-line class-methods-use-this
    init() {
        return Promise.resolve();
    }
}
exports.PackageAncestryNode = PackageAncestryNode;
_PackageAncestryNode_version = new WeakMap(), _PackageAncestryNode_MajorVersion = new WeakMap(), _PackageAncestryNode_MinorVersion = new WeakMap(), _PackageAncestryNode_PatchVersion = new WeakMap(), _PackageAncestryNode_BuildNumber = new WeakMap(), _PackageAncestryNode_AncestorId = new WeakMap(), _PackageAncestryNode_SubscriberPackageVersionId = new WeakMap(), _PackageAncestryNode_depthCounter = new WeakMap();
//# sourceMappingURL=packageAncestry.js.map