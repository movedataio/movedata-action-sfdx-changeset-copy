"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const _ = require("lodash");
const fs = require("fs");
const os_1 = require("os");
const snapshot_command_1 = require("../../snapshot-command");
const chalk = require("chalk");
class Compare extends snapshot_command_1.SnapshotCommand {
    /**
     * Compare a snapshot with the current commands
     * @param {CommandChange[]} initialCommands Command list from the snapshot
     * @param {CommandChange[]} updatedCommands Command list from runtime
     * @returns all the command differences
     */
    async compareSnapshot(initialCommands, updatedCommands) {
        const removedCommands = [];
        const diffCommands = [];
        for (const initialCommand of initialCommands) {
            const updatedCommand = updatedCommands.find(updatedCommand => {
                // Protect against old snapshot files that don't have the plugin entry filled out.
                const samePlugin = initialCommand.plugin ? initialCommand.plugin === updatedCommand.plugin : true;
                return initialCommand.command === updatedCommand.name && samePlugin;
            });
            if (updatedCommand) {
                const changedFlags = this.diffCommandProperty(initialCommand.flags, updatedCommand.flags).changedProperty;
                const changedAlias = this.diffCommandProperty(initialCommand.alias, updatedCommand.alias).changedProperty;
                const flagsChanged = changedFlags.length > 0;
                const aliasChanged = changedAlias.length > 0;
                if (aliasChanged) {
                    updatedCommand.alias = changedAlias;
                }
                if (flagsChanged) {
                    updatedCommand.flags = changedFlags;
                }
                if (flagsChanged || aliasChanged) {
                    diffCommands.push(updatedCommand);
                }
            }
            else {
                removedCommands.push(initialCommand.command);
            }
        }
        const initialCommandNames = initialCommands.map(initialCommand => initialCommand.command);
        const updatedCommandNames = updatedCommands.map(updatedCommand => updatedCommand.name);
        const addedCommands = _.difference(updatedCommandNames, initialCommandNames);
        if (removedCommands.length === 0 && addedCommands.length === 0 && diffCommands.length === 0) {
            this.log('No changes have been detected.');
            return {};
        }
        // Fail the process since there are changes to the snapshot file
        process.exitCode = 1;
        this.log(`The following commands and flags have modified: (${chalk.green('+')} added, ${chalk.red('-')} removed)${os_1.EOL}`);
        for (const command of removedCommands) {
            this.log(chalk.red(`\t-${command}`));
        }
        for (const command of addedCommands) {
            this.log(chalk.green(`\t+${command}`));
        }
        const removedProperties = [];
        const printCommandDiff = (properties, propertyName) => {
            if (properties.some(prop => prop.added || prop.removed))
                this.log(`\t  ${propertyName}:`);
            for (const prop of properties) {
                if (prop.added || prop.removed) {
                    const color = prop.added ? chalk.green : chalk.red;
                    this.log(color(`\t\t${prop.added ? '+' : '-'}${prop.name}`));
                }
                if (prop.removed)
                    removedProperties.push();
            }
        };
        for (const command of diffCommands) {
            this.log(`\t${command.name}`);
            printCommandDiff(command.flags, 'Flags');
            printCommandDiff(command.alias, 'Aliases');
        }
        this.log(`${os_1.EOL}Command, flag, or alias differences detected. If intended, please update the snapshot file and run again.`);
        // Check if existent commands, or properties (flags, aliases) have been deleted
        if (removedCommands.length > 0 || removedProperties.length > 0) {
            this.log(chalk.red(`${os_1.EOL}Since there are deletions, a major version bump is required.`));
        }
        return { addedCommands, removedCommands, removedFlags: removedCommands, diffCommands };
    }
    /**
     * @deprecated in favor of diffCommandProperty
   * Compares a flag snapshot with the current command's flags
   * @param {string[]} initialFlags Flag list from the snapshot
   * @param {string[]} updatedFlags Flag list from runtime
   * @return {boolean} true if no changes, false otherwise
   */
    diffCommandFlags(initialFlags, updatedFlags) {
        const diffedFlags = this.diffCommandProperty(initialFlags, updatedFlags);
        return { addedFlags: diffedFlags.addedProperty, removedFlags: diffedFlags.removedProperty, updatedFlags: diffedFlags.updated, changedFlags: diffedFlags.changedProperty };
    }
    /**
   * compares two command's properties to each other
   * @return a list of added, removed, updated, and changed properties
   * @param initial initial command property to compare against
   * @param updated generated command property to compare with
   */
    diffCommandProperty(initial, updated) {
        const updatedPropertyNames = updated.map(update => update.name);
        const addedProperty = _.difference(updatedPropertyNames, initial);
        const removedProperty = _.difference(initial, updatedPropertyNames);
        const changedProperty = [];
        for (const update of updated) {
            if (addedProperty.includes(update.name)) {
                update.added = true;
                changedProperty.push(update);
            }
        }
        for (const remove of removedProperty) {
            changedProperty.push({ name: remove, removed: true });
            // The removed flags in not included in the updated flags, but we want it to
            // so it shows removed.
            updated.push({ name: remove, removed: true });
        }
        return { addedProperty, removedProperty, updated, changedProperty };
    }
    get changed() {
        return this.commands.map(command => {
            return {
                name: command.id,
                plugin: command.pluginName || '',
                flags: Object.entries(command.flags).map(flagName => ({ name: flagName[0] })),
                alias: command.aliases.map(alias => ({ name: alias })),
            };
        });
    }
    async run() {
        const { flags } = await this.parse(Compare);
        const oldCommands = JSON.parse(fs.readFileSync(flags.filepath).toString('utf8'));
        const newCommands = this.changed;
        return this.compareSnapshot(oldCommands, newCommands);
    }
}
exports.default = Compare;
Compare.flags = {
    filepath: core_1.Flags.string({
        description: 'path of the generated snapshot file',
        default: './command-snapshot.json',
    }),
};
