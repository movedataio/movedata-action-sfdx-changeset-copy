"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaGenerator = exports.getAllFiles = void 0;
const path = require("path");
const fs = require("fs");
const core_1 = require("@oclif/core");
const ts_json_schema_generator_1 = require("ts-json-schema-generator");
const snapshot_command_1 = require("../../snapshot-command");
const chalk_1 = require("chalk");
const util_1 = require("../../util");
function getAllFiles(dirPath, ext, allFiles = []) {
    let files = [];
    try {
        files = fs.readdirSync(dirPath);
    }
    catch (_a) { }
    for (const file of files) {
        const fPath = path.join(dirPath, file);
        if (fs.statSync(fPath).isDirectory()) {
            allFiles = getAllFiles(fPath, ext, allFiles);
        }
        else if (file.endsWith(ext)) {
            allFiles.push(fPath);
        }
    }
    return allFiles;
}
exports.getAllFiles = getAllFiles;
class SchemaGenerator {
    constructor(base, ignoreVoid = true) {
        this.base = base;
        this.ignoreVoid = ignoreVoid;
        this.classToId = {};
    }
    async generate() {
        for (const cmd of this.base.commands) {
            // eslint-disable-next-line no-await-in-loop
            const loadedCmd = await cmd.load(); // commands are loaded async in oclif/core
            this.classToId[loadedCmd.name] = loadedCmd.id;
        }
        const cmdSchemas = {};
        for (const file of this.getAllCmdFiles()) {
            const { returnType, commandId } = this.parseCmdFile(file);
            if (this.ignoreVoid && returnType === 'void')
                continue;
            cmdSchemas[commandId] = this.generateSchema(returnType, file);
        }
        const hookSchemas = {};
        for (const file of this.getAllHookFiles()) {
            const { returnType, hookId } = this.parseHookFile(file);
            if (returnType && hookId) {
                hookSchemas[hookId] = this.generateSchema(returnType, file);
            }
        }
        return { commands: cmdSchemas, hooks: hookSchemas };
    }
    generateSchema(returnType, file) {
        try {
            const config = {
                path: file,
                type: returnType,
                skipTypeCheck: true,
            };
            return (0, ts_json_schema_generator_1.createGenerator)(config).createSchema(config.type);
        }
        catch (error) {
            const error_ = error.message.toLowerCase().includes('no root type') ? new Error(`Schema generator could not find the ${(0, chalk_1.red)(returnType)} type. Please make sure that ${(0, chalk_1.red)(returnType)} is exported.`) : error;
            throw error_;
        }
    }
    getAllCmdFiles() {
        const { rootDir } = this.getDirs();
        return getAllFiles(path.join(rootDir, 'commands'), '.ts');
    }
    getAllHookFiles() {
        var _a, _b;
        // eslint-disable-next-line unicorn/no-array-reduce
        const hookFiles = Object.values((_b = (_a = this.base.config.pjson.oclif) === null || _a === void 0 ? void 0 : _a.hooks) !== null && _b !== void 0 ? _b : {}).reduce((x, y) => {
            return Array.isArray(y) ? [...x, ...y] : [...x, y];
        }, []);
        const { rootDir, outDir } = this.getDirs();
        return hookFiles.map(h => `${path.resolve(h)}.ts`.replace(outDir, rootDir));
    }
    /**
     * Use regex to find the typescript type being returned by the command's
     * `run` method.
     * @param file the file to parse
     * @returns Returns the name of the return type and the command id.
     */
    parseCmdFile(file) {
        const returnTypeRegex = /(?<=async\srun\(\):\sPromise<)(.*?)(>*)(?=>)/g;
        const contents = fs.readFileSync(file, 'utf8');
        const [returnType] = returnTypeRegex.exec(contents) || [];
        if (!returnType) {
            throw new Error(`No return type found for file ${file}`);
        }
        const commandId = this.determineCommandId(contents);
        if (!commandId) {
            throw new Error(`No commandId found for file ${file}`);
        }
        this.validateReturnType(returnType, commandId);
        return { returnType, commandId };
    }
    /**
     * Use regex to find the typescript type being returned by the hook
     * @param file the file to parse
     * @returns Returns the name of the return type and the hook id.
     */
    parseHookFile(file) {
        var _a, _b;
        const returnTypeRegex = /(?<=const\shook:\s(.*?)<)[^'](.*?)[^'](>*)(?=>)/g;
        const contents = fs.readFileSync(file, 'utf8');
        const [returnType] = returnTypeRegex.exec(contents) || [];
        if (!returnType || returnType === 'void') {
            return { returnType: null, hookId: null };
        }
        const hooks = (_b = (_a = this.base.config.pjson.oclif) === null || _a === void 0 ? void 0 : _a.hooks) !== null && _b !== void 0 ? _b : {};
        const hookId = Object.keys(hooks).find(key => {
            const hookFiles = (Array.isArray(hooks[key]) ? hooks[key] : [hooks[key]]);
            const hookFileNames = hookFiles.map(f => path.basename(f).split('.')[0]);
            const currentFileName = path.basename(file).split('.')[0];
            return hookFileNames.includes(currentFileName);
        });
        if (!hookId) {
            return { returnType: null, hookId: null };
        }
        this.validateReturnType(returnType, hookId);
        return { returnType, hookId };
    }
    validateReturnType(returnType, commandId) {
        const notAllowed = this.ignoreVoid ? ['any', 'unknown'] : ['any', 'unknown', 'void'];
        const vagueTypes = ['JsonMap', 'JsonCollection', 'AnyJson'];
        if (notAllowed.includes(returnType)) {
            throw new Error(`${returnType} (from ${commandId}) is not allowed. Please use a more specific type.`);
        }
        else if (vagueTypes.includes(returnType)) {
            throw new Error(`${returnType} (from ${commandId}) is too vague. Please use a more specific type.`);
        }
    }
    determineCommandId(contents) {
        for (const [className, cmdId] of Object.entries(this.classToId)) {
            const regex = new RegExp(` class ${className} `, 'g');
            if (regex.test(contents)) {
                return cmdId;
            }
        }
    }
    getDirs() {
        const dirs = {
            rootDir: path.join(this.base.config.root, 'src'),
            outDir: path.join(this.base.config.root, 'lib'),
        };
        try {
            const tsConfig = JSON.parse(fs.readFileSync(path.join(this.base.config.root, 'tsconfig.json'), 'utf-8'));
            if (tsConfig.compilerOptions.rootDir) {
                dirs.rootDir = path.join(this.base.config.root, tsConfig.compilerOptions.rootDir);
            }
            if (tsConfig.compilerOptions.outDir) {
                dirs.outDir = path.join(this.base.config.root, tsConfig.compilerOptions.outDir);
            }
            return dirs;
        }
        catch (_a) { }
        return dirs;
    }
}
exports.SchemaGenerator = SchemaGenerator;
class SchemaGenerate extends snapshot_command_1.SnapshotCommand {
    async run() {
        const { flags } = await this.parse(SchemaGenerate);
        const generator = new SchemaGenerator(this, flags.ignorevoid);
        const schemas = await generator.generate();
        const directory = flags.filepath.replace('{version}', this.config.version);
        fs.mkdirSync(directory, { recursive: true });
        const files = [];
        if (flags.singlefile) {
            const filePath = path.join(directory, 'schema.json');
            fs.writeFileSync(filePath, JSON.stringify(schemas, null, 2));
            this.log(`Generated JSON schema file "${filePath}"`);
            files.push(filePath);
        }
        else {
            for (const [cmdId, schema] of Object.entries(schemas.commands)) {
                const fileName = (0, util_1.getSchemaFileName)(cmdId);
                const filePath = path.join(directory, fileName);
                fs.writeFileSync(filePath, JSON.stringify(schema, null, 2));
                this.log(`Generated JSON schema file "${filePath}"`);
                files.push(filePath);
            }
            if (Object.values(schemas.hooks).length > 0) {
                const hooksDir = path.join(directory, 'hooks');
                fs.mkdirSync(hooksDir, { recursive: true });
                for (const [hookId, schema] of Object.entries(schemas.hooks)) {
                    const fileName = (0, util_1.getSchemaFileName)(hookId);
                    const filePath = path.join(hooksDir, fileName);
                    fs.writeFileSync(filePath, JSON.stringify(schema, null, 2));
                    this.log(`Generated JSON schema file "${filePath}"`);
                    files.push(filePath);
                }
            }
        }
        return files;
    }
}
exports.default = SchemaGenerate;
SchemaGenerate.flags = {
    filepath: core_1.Flags.string({
        description: 'directory to save the generated schema files; can use "{version}" to insert the current CLI/plugin version',
        default: './schemas',
    }),
    singlefile: core_1.Flags.boolean({
        description: 'put generated schema into a single file',
        default: false,
    }),
    ignorevoid: core_1.Flags.boolean({
        description: 'ignore commands that return void',
        default: true,
    }),
};
