"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const semver = require("semver");
const lodash_1 = require("lodash");
const just_diff_1 = require("just-diff");
const core_1 = require("@oclif/core");
const snapshot_command_1 = require("../../snapshot-command");
const generate_1 = require("./generate");
const chalk_1 = require("chalk");
const util_1 = require("../../util");
function isNumber(n) {
    return Number.isInteger(Number(n));
}
function isMeaningless(n) {
    const meaninglessKeys = ['$comment', '__computed'];
    return meaninglessKeys.includes(n);
}
class SchemaCompare extends snapshot_command_1.SnapshotCommand {
    async run() {
        const { flags } = await this.parse(SchemaCompare);
        try {
            fs.accessSync(flags.filepath);
        }
        catch (_a) {
            this.log(`${flags.filepath} not found.`);
            return [];
        }
        const existingSchema = this.readExistingSchema(flags.filepath);
        const latestSchema = (await this.generateLatestSchema());
        this.debug('existingSchema', existingSchema);
        this.debug('latestSchema', latestSchema);
        const changes = (0, just_diff_1.diff)(latestSchema, existingSchema);
        const humanReadableChanges = {};
        for (const change of changes) {
            const lastPathElement = change.path[change.path.length - 1];
            if (isMeaningless(lastPathElement))
                continue;
            const objPath = change.path.join('.');
            const existing = (0, lodash_1.get)(existingSchema, objPath);
            const latest = (0, lodash_1.get)(latestSchema, objPath);
            const [commandId] = objPath.split('.definitions');
            const readablePath = objPath.replace(`${commandId}.`, '');
            if (!humanReadableChanges[commandId]) {
                humanReadableChanges[commandId] = [];
            }
            const lastElementIsNum = isNumber(lastPathElement);
            const basePath = lastElementIsNum ? readablePath.replace(`.${lastPathElement}`, '') : readablePath;
            switch (change.op) {
                case 'replace':
                    humanReadableChanges[commandId].push(`${(0, chalk_1.underline)(readablePath)} was changed from ${(0, chalk_1.cyan)(existing)} to ${(0, chalk_1.cyan)(latest)}`);
                    break;
                case 'add':
                    humanReadableChanges[commandId].push(lastElementIsNum ?
                        `Array item at ${(0, chalk_1.underline)(basePath)} was ${(0, chalk_1.cyan)('added')} to latest schema` :
                        `${(0, chalk_1.underline)(readablePath)} was ${(0, chalk_1.cyan)('added')} to latest schema`);
                    break;
                case 'remove':
                    humanReadableChanges[commandId].push(lastElementIsNum ?
                        `Array item at ${(0, chalk_1.underline)(basePath)} was ${(0, chalk_1.cyan)('not found')} in latest schema` :
                        `${(0, chalk_1.underline)(readablePath)} was ${(0, chalk_1.cyan)('not found')} in latest schema`);
                    break;
                default:
                    break;
            }
        }
        if (Object.keys(humanReadableChanges).length === 0) {
            this.log('No changes have been detected.');
            return [];
        }
        this.log();
        this.log((0, chalk_1.bold)((0, chalk_1.red)('Found the following schema changes:')));
        for (const [commandId, changes] of Object.entries(humanReadableChanges)) {
            this.log();
            this.log((0, chalk_1.bold)(commandId));
            for (const change of changes) {
                this.log(`  - ${change}`);
            }
        }
        this.log();
        const bin = process.platform === 'win32' ? 'bin\\dev.cmd' : 'bin/dev';
        this.log('If intended, please update the schema file(s) and run again:', (0, chalk_1.bold)(`${bin} ${(0, core_1.toConfiguredId)('schema:generate', this.config)}`));
        process.exitCode = 1;
        return changes;
    }
    readExistingSchema(filePath) {
        const contents = fs.readdirSync(filePath);
        const folderIsVersioned = contents.every(c => semver.valid(c));
        const schemasDir = folderIsVersioned ? path.join(filePath, semver.rsort(contents)[0] || '') : filePath;
        const schemaFiles = (0, generate_1.getAllFiles)(schemasDir, '.json');
        let schemas = {
            commands: {},
            hooks: {},
        };
        if (schemaFiles.length === 1 && schemaFiles[0].endsWith('schema.json')) {
            schemas = JSON.parse(fs.readFileSync(schemaFiles[0]).toString('utf8'));
        }
        else {
            for (const file of schemaFiles) {
                const schema = JSON.parse(fs.readFileSync(file).toString('utf8'));
                const key = path.basename((0, util_1.getKeyNameFromFilename)(file));
                if (file.split(path.sep).includes('hooks')) {
                    schemas.hooks[key] = schema;
                }
                else {
                    schemas.commands[key] = schema;
                }
            }
        }
        return schemas;
    }
    async generateLatestSchema() {
        const generator = new generate_1.SchemaGenerator(this);
        return generator.generate();
    }
}
exports.default = SchemaCompare;
SchemaCompare.flags = {
    filepath: core_1.Flags.string({
        description: 'path of the generated snapshot file',
        default: './schemas',
    }),
};
