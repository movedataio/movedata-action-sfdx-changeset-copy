"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutocompleteSearch = exports.Choices = void 0;
const tslib_1 = require("tslib");
const ansiEscapes = require("ansi-escapes");
const Base = require("inquirer/lib/prompts/base");
const InquirerChoices = require("inquirer/lib/objects/choices");
const observe = require("inquirer/lib/utils/events");
const utils = require("inquirer/lib/utils/readline");
const Paginator = require("inquirer/lib/utils/paginator");
const operators_1 = require("rxjs/operators");
const Inquirer = (0, tslib_1.__importStar)(require("inquirer"));
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const fuse_js_1 = (0, tslib_1.__importDefault)(require("fuse.js"));
class Choices extends InquirerChoices {
    constructor(choices, options = {}) {
        // @ts-expect-error
        super(choices, options);
    }
}
exports.Choices = Choices;
class AutocompleteSearch extends Base {
    constructor(question, rl, answers = {}) {
        super(question, rl, answers);
        this.rl = rl;
        this.selected = 0;
        if (!this.opt.searchOpts) {
            this.throwParamError('searchOpts');
        }
        this.fuse = new fuse_js_1.default(this.opt.options, this.opt.searchOpts);
        this.currentChoices = new Choices([], {});
        this.firstRender = true;
        this.initialValue = this.opt.default;
        const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
        this.paginator = new Paginator(this.screen, { isInfinite: shouldLoop });
    }
    async _run(cb) {
        this.done = cb;
        const events = observe(this.rl);
        // eslint-disable-next-line unicorn/consistent-function-scoping
        const dontHaveAnswer = () => this.answer === undefined;
        events.line.pipe((0, operators_1.takeWhile)(dontHaveAnswer)).forEach(this.onSubmit.bind(this));
        // @ts-ignore
        events.keypress.pipe((0, operators_1.takeWhile)(dontHaveAnswer)).forEach(this.onKeypress.bind(this));
        // Call once at init
        this.search();
        return Promise.resolve(this);
    }
    render(error) {
        // Render question
        let content = this.getQuestion();
        let bottomContent = '';
        if (this.firstRender) {
            content += chalk_1.default.dim('(Use arrow keys or type to search , tab to autocomplete)');
        }
        // Render choices or answer depending on the state
        if (this.status === 'answered') {
            content += chalk_1.default.cyan(this.shortAnswer || this.answerName || this.answer);
        }
        else if (this.searching) {
            content += this.rl.line;
            bottomContent += '  ' + chalk_1.default.dim(this.opt.searchText || 'Searching...');
        }
        else if (this.nbChoices) {
            const choicesStr = renderList(this.currentChoices, this.selected);
            content += this.rl.line;
            const indexPosition = this.selected;
            let realIndexPosition = 0;
            this.currentChoices.choices.every((choice, index) => {
                if (index > indexPosition) {
                    return false;
                }
                if (choice.type === 'separator') {
                    return false;
                }
                const name = choice.name;
                realIndexPosition += name ? name.split('\n').length : 0;
                return true;
            });
            bottomContent += this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
            if (this.opt.footer) {
                const footer = this.opt.footer(this.currentChoices, this.selected, bottomContent);
                if (footer)
                    bottomContent += `\n${new Inquirer.Separator().line}\n${footer}`;
            }
        }
        else {
            content += this.rl.line;
            bottomContent += `  ${chalk_1.default.yellow(this.opt.emptyText || 'No results...')}`;
        }
        if (error) {
            bottomContent += `\n${chalk_1.default.red('>> ')}${error}`;
        }
        this.firstRender = false;
        this.screen.render(content, bottomContent);
    }
    onSubmit(line) {
        let lineOrRl = line || this.rl.line;
        if (!lineOrRl) {
            lineOrRl = (this.opt.default === null ? '' : this.opt.default);
        }
        if (typeof this.opt.validate === 'function') {
            const checkValidationResult = (validationResult) => {
                if (validationResult !== true) {
                    this.render(validationResult || 'Enter something, tab to autocomplete!');
                }
                else {
                    this.onSubmitAfterValidation(lineOrRl);
                }
            };
            const choice = this.currentChoices.getChoice(this.selected);
            const validationResult = this.opt.validate(choice, this.answers);
            if (typeof validationResult === 'object' && typeof validationResult.then === 'function') {
                void validationResult.then(checkValidationResult);
            }
            else {
                checkValidationResult(validationResult);
            }
        }
        else {
            this.onSubmitAfterValidation(lineOrRl);
        }
    }
    onSubmitAfterValidation(line) {
        let choice = {};
        if (this.nbChoices <= this.selected) {
            this.rl.write(line);
            this.search(line);
            return;
        }
        if (this.nbChoices) {
            choice = this.currentChoices.getChoice(this.selected);
            this.answer = choice.value;
            this.answerName = choice.name;
            this.shortAnswer = choice.short;
        }
        else {
            this.rl.write(line);
            this.search(line);
            return;
        }
        // @ts-expect-error
        // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument
        const value = this.opt.filter(choice.value, this.answers);
        choice.value = value;
        this.answer = value;
        this.status = 'answered';
        // Rerender prompt
        this.render();
        this.screen.done();
        this.done(choice.value);
    }
    search(searchTerm) {
        this.selected = 0;
        // Only render searching state after first time
        if (this.searchedOnce) {
            this.searching = true;
            this.currentChoices = new Choices([], {});
            this.render(); // Now render current searching state
        }
        else {
            this.searchedOnce = true;
        }
        this.lastSearchTerm = searchTerm;
        const choices = searchTerm ?
            this.fuse.search(searchTerm).map(el => el.item[this.opt.displayKey]) :
            this.opt.options.map(el => el[this.opt.displayKey]).sort();
        this.currentChoices = new Choices(choices, {});
        // @ts-expect-error
        const realChoices = this.currentChoices.filter(choice => choice.type !== 'separator' && !choice.disabled);
        this.nbChoices = realChoices.length;
        const selectedIndex = realChoices.findIndex(
        // @ts-expect-error
        choice => choice === this.initialValue || choice.value === this.initialValue);
        if (selectedIndex >= 0) {
            this.selected = selectedIndex;
        }
        this.searching = false;
        this.render();
    }
    ensureSelectedInRange() {
        const selectedIndex = Math.min(this.selected, this.nbChoices); // Not above currentChoices length - 1
        this.selected = Math.max(selectedIndex, 0); // Not below 0
    }
    onKeypress(e) {
        let len;
        const keyName = (e.key && e.key.name) || undefined;
        if (keyName === 'tab') {
            if (this.currentChoices.getChoice(this.selected)) {
                this.rl.write(ansiEscapes.cursorLeft);
                const autoCompleted = this.currentChoices.getChoice(this.selected).value;
                this.rl.write(ansiEscapes.cursorForward(autoCompleted.length));
                // @ts-expect-error because readonly property
                this.rl.line = autoCompleted;
                this.render();
            }
        }
        else if (keyName === 'down' || (keyName === 'n' && e.key.ctrl)) {
            len = this.nbChoices;
            this.selected = this.selected < len - 1 ? this.selected + 1 : 0;
            this.ensureSelectedInRange();
            this.render();
            utils.up(this.rl, 2);
        }
        else if (keyName === 'up' || (keyName === 'p' && e.key.ctrl)) {
            len = this.nbChoices;
            this.selected = this.selected > 0 ? this.selected - 1 : len - 1;
            this.ensureSelectedInRange();
            this.render();
        }
        else {
            this.render(); // Render input automatically
            // Only search if input have actually changed, not because of other keypresses
            if (this.lastSearchTerm !== this.rl.line) {
                this.search(this.rl.line); // Trigger new search
            }
        }
    }
}
exports.AutocompleteSearch = AutocompleteSearch;
function renderList(choices, pointer) {
    let output = '';
    let separatorOffset = 0;
    choices.forEach((choice, i) => {
        if (choice.type === 'separator') {
            separatorOffset += 1;
            output += `  ${choice}\n`;
            return;
        }
        if (choice.disabled) {
            separatorOffset += 1;
            output += `  - ${choice.name} ( ${typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'})\n`;
            return;
        }
        const isSelected = i - separatorOffset === pointer;
        // eslint-disable-next-line no-useless-concat
        let line = (isSelected ? '‚ùØ' + ' ' : '  ') + choice.name;
        if (isSelected) {
            line = chalk_1.default.cyan(line);
        }
        output += `${line}\n`;
    });
    return output.replace(/\n$/, '');
}
