"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const fs = require("fs-extra");
const path = require("path");
const os = require("os");
const semver = require("semver");
const shelljs_1 = require("shelljs");
async function fileExists(filePath) {
    try {
        await fs.access(filePath);
        return true;
    }
    catch (_a) {
        return false;
    }
}
class Manifest extends core_1.Command {
    async run() {
        var _a;
        const { flags } = await this.parse(Manifest);
        try {
            fs.unlinkSync('oclif.manifest.json');
        }
        catch (_b) { }
        const { args } = await this.parse(Manifest);
        const root = path.resolve(args.path);
        const packageJson = fs.readJSONSync('package.json');
        let jitPluginManifests = [];
        if (flags.jit && ((_a = packageJson.oclif) === null || _a === void 0 ? void 0 : _a.jitPlugins)) {
            this.debug('jitPlugins: %s', packageJson.oclif.jitPlugins);
            const tmpDir = os.tmpdir();
            const promises = Object.entries(packageJson.oclif.jitPlugins).map(async ([jitPlugin, version]) => {
                const pluginDir = jitPlugin.replace('/', '-').replace('@', '');
                const repo = this.executeCommand(`npm view ${jitPlugin}@latest repository --json`);
                const stdout = JSON.parse(repo.stdout);
                const repoUrl = stdout.url.replace(`${stdout.type}+`, '');
                const fullPath = path.join(tmpDir, pluginDir);
                if (await fileExists(fullPath))
                    await fs.remove(fullPath);
                const versions = JSON.parse(this.executeCommand(`npm view ${jitPlugin}@latest versions --json`).stdout);
                const maxSatisfying = semver.maxSatisfying(versions, version);
                this.cloneRepo(repoUrl, fullPath, maxSatisfying);
                this.executeCommand('yarn', { cwd: fullPath });
                this.executeCommand('yarn tsc', { cwd: fullPath });
                const plugin = new core_1.Plugin({ root: fullPath, type: 'jit', ignoreManifest: true, errorOnManifestCreate: true });
                await plugin.load();
                return plugin.manifest;
            });
            core_1.ux.action.start('Generating JIT plugin manifests');
            jitPluginManifests = await Promise.all(promises);
            core_1.ux.action.stop();
        }
        let plugin = new core_1.Plugin({ root, type: 'core', ignoreManifest: true, errorOnManifestCreate: true });
        if (!plugin)
            throw new Error('plugin not found');
        await plugin.load(true);
        if (!plugin.valid) {
            const p = require.resolve('@oclif/plugin-legacy', { paths: [process.cwd()] });
            const { PluginLegacy } = require(p);
            plugin = new PluginLegacy(this.config, plugin);
            await plugin.load();
        }
        if (process.env.OCLIF_NEXT_VERSION) {
            plugin.manifest.version = process.env.OCLIF_NEXT_VERSION;
        }
        const dotfile = plugin.pjson.files.find((f) => f.endsWith('.oclif.manifest.json'));
        const file = path.join(plugin.root, `${dotfile ? '.' : ''}oclif.manifest.json`);
        for (const manifest of jitPluginManifests) {
            plugin.manifest.commands = Object.assign(Object.assign({}, plugin.manifest.commands), manifest.commands);
        }
        fs.writeFileSync(file, JSON.stringify(plugin.manifest, null, 2));
        this.log(`wrote manifest to ${file}`);
    }
    cloneRepo(repoUrl, fullPath, tag) {
        try {
            this.executeCommand(`git clone --branch ${tag} ${repoUrl} ${fullPath} --depth 1`);
        }
        catch (_a) {
            try {
                this.executeCommand(`git clone --branch v${tag} ${repoUrl} ${fullPath} --depth 1`);
            }
            catch (_b) {
                throw new Error(`Unable to clone repo ${repoUrl} with tag ${tag}`);
            }
        }
    }
    executeCommand(command, options) {
        const debugString = (options === null || options === void 0 ? void 0 : options.cwd) ? `executing command: ${command} in ${options.cwd}` : `executing command: ${command}`;
        this.debug(debugString);
        const result = (0, shelljs_1.exec)(command, Object.assign(Object.assign({}, options), { silent: true, async: false }));
        if (result.code !== 0) {
            this.error(result.stderr);
        }
        this.debug(result.stdout);
        return result;
    }
}
exports.default = Manifest;
Manifest.description = 'generates plugin manifest json';
Manifest.args = {
    path: core_1.Args.string({ description: 'path to plugin', default: '.' }),
};
Manifest.flags = {
    jit: core_1.Flags.boolean({
        allowNo: true,
        summary: 'append commands from JIT plugins in manifest',
        default: true,
    }),
};
