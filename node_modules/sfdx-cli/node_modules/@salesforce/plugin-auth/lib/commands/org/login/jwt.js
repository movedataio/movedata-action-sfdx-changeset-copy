"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const authBaseCommand_1 = require("../../../authBaseCommand");
const common_1 = require("../../../common");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'jwt.grant');
const commonMessages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
class LoginJwt extends authBaseCommand_1.AuthBaseCommand {
    constructor() {
        super(...arguments);
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    async run() {
        const { flags } = await this.parse(LoginJwt);
        this.flags = flags;
        let result = {};
        if (await this.shouldExitCommand(flags['no-prompt']))
            return {};
        try {
            const authInfo = await this.initAuthInfo();
            await authInfo.handleAliasAndDefaultSettings({
                alias: flags.alias,
                setDefault: flags['set-default'],
                setDefaultDevHub: flags['set-default-dev-hub'],
            });
            result = authInfo.getFields(true);
            await core_1.AuthInfo.identifyPossibleScratchOrgs(result, authInfo);
        }
        catch (err) {
            const msg = (0, ts_types_1.getString)(err, 'message');
            throw messages.createError('JwtGrantError', [msg]);
        }
        const successMsg = commonMessages.getMessage('authorizeCommandSuccess', [result.username, result.orgId]);
        this.logSuccess(successMsg);
        return result;
    }
    async initAuthInfo() {
        const oauth2OptionsBase = {
            clientId: this.flags['client-id'],
            privateKeyFile: this.flags['jwt-key-file'],
        };
        const loginUrl = await common_1.Common.resolveLoginUrl(this.flags['instance-url']?.href);
        const oauth2Options = loginUrl ? Object.assign(oauth2OptionsBase, { loginUrl }) : oauth2OptionsBase;
        let authInfo;
        try {
            authInfo = await core_1.AuthInfo.create({
                username: this.flags.username,
                oauth2Options,
            });
        }
        catch (error) {
            const err = error;
            if (err.name === 'AuthInfoOverwriteError') {
                this.logger.debug('Auth file already exists. Removing and starting fresh.');
                const remover = await core_1.AuthRemover.create();
                await remover.removeAuth(this.flags.username);
                authInfo = await core_1.AuthInfo.create({
                    username: this.flags.username,
                    oauth2Options,
                });
            }
            else {
                throw err;
            }
        }
        await authInfo.save();
        return authInfo;
    }
}
exports.default = LoginJwt;
LoginJwt.summary = messages.getMessage('summary');
LoginJwt.description = messages.getMessage('description');
LoginJwt.examples = messages.getMessages('examples');
LoginJwt.aliases = ['force:auth:jwt:grant', 'auth:jwt:grant'];
LoginJwt.flags = {
    username: sf_plugins_core_1.Flags.string({
        char: 'o',
        summary: messages.getMessage('flags.username.summary'),
        required: true,
        deprecateAliases: true,
        aliases: ['u'],
    }),
    'jwt-key-file': sf_plugins_core_1.Flags.file({
        char: 'f',
        summary: messages.getMessage('flags.jwt-key-file.summary'),
        required: true,
        deprecateAliases: true,
        aliases: ['jwtkeyfile', 'keyfile'],
    }),
    'client-id': sf_plugins_core_1.Flags.string({
        char: 'i',
        summary: commonMessages.getMessage('flags.client-id.summary'),
        required: true,
        deprecateAliases: true,
        aliases: ['clientid'],
    }),
    'instance-url': sf_plugins_core_1.Flags.url({
        char: 'r',
        summary: commonMessages.getMessage('flags.instance-url.summary'),
        description: commonMessages.getMessage('flags.instance-url.description'),
        deprecateAliases: true,
        aliases: ['instanceurl', 'l'],
    }),
    'set-default-dev-hub': sf_plugins_core_1.Flags.boolean({
        char: 'd',
        summary: commonMessages.getMessage('flags.set-default-dev-hub.summary'),
        deprecateAliases: true,
        aliases: ['setdefaultdevhub', 'setdefaultdevhubusername', 'v'],
    }),
    'set-default': sf_plugins_core_1.Flags.boolean({
        char: 's',
        summary: commonMessages.getMessage('flags.set-default.summary'),
        deprecateAliases: true,
        aliases: ['setdefaultusername'],
    }),
    alias: sf_plugins_core_1.Flags.string({
        char: 'a',
        summary: commonMessages.getMessage('flags.alias.summary'),
        deprecateAliases: true,
        aliases: ['setalias'],
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        char: 'p',
        summary: commonMessages.getMessage('flags.no-prompt.summary'),
        required: false,
        hidden: true,
        deprecateAliases: true,
        aliases: ['noprompt'],
    }),
    loglevel: sf_plugins_core_1.loglevel,
};
//# sourceMappingURL=jwt.js.map