"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const open = require("open");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const authBaseCommand_1 = require("../../../authBaseCommand");
const common_1 = require("../../../common");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'web.login');
const commonMessages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
class LoginWeb extends authBaseCommand_1.AuthBaseCommand {
    async run() {
        const { flags } = await this.parse(LoginWeb);
        this.flags = flags;
        if (isSFDXContainerMode()) {
            throw new core_1.SfError(messages.getMessage('deviceWarning'), 'DEVICE_WARNING');
        }
        if (await this.shouldExitCommand(flags['no-prompt']))
            return {};
        const oauthConfig = {
            loginUrl: await common_1.Common.resolveLoginUrl((0, ts_types_1.get)(flags['instance-url'], 'href', null)),
            clientId: flags['client-id'],
        };
        if (flags['client-id']) {
            oauthConfig.clientSecret = await this.askForClientSecret(flags['disable-masking']);
        }
        try {
            const authInfo = await this.executeLoginFlow(oauthConfig);
            await authInfo.handleAliasAndDefaultSettings({
                alias: flags.alias,
                setDefault: flags['set-default'],
                setDefaultDevHub: flags['set-default-dev-hub'],
            });
            const fields = authInfo.getFields(true);
            await core_1.AuthInfo.identifyPossibleScratchOrgs(fields, authInfo);
            const successMsg = commonMessages.getMessage('authorizeCommandSuccess', [fields.username, fields.orgId]);
            this.logSuccess(successMsg);
            return fields;
        }
        catch (err) {
            const error = err;
            core_1.Logger.childFromRoot('auth').debug(error);
            if (error.name === 'AuthCodeExchangeError') {
                throw new core_1.SfError(messages.getMessage('invalidClientId', [error.message]));
            }
            throw error;
        }
    }
    // leave it because it's stubbed in the test
    // eslint-disable-next-line class-methods-use-this
    async executeLoginFlow(oauthConfig) {
        const oauthServer = await core_1.WebOAuthServer.create({ oauthConfig });
        await oauthServer.start();
        const openOptions = this.flags.browser
            ? { app: { name: open.apps[this.flags.browser] }, wait: false }
            : { wait: false };
        await open(oauthServer.getAuthorizationUrl(), openOptions);
        return oauthServer.authorizeAndSave();
    }
}
exports.default = LoginWeb;
LoginWeb.summary = messages.getMessage('summary');
LoginWeb.description = messages.getMessage('description');
LoginWeb.examples = messages.getMessages('examples');
LoginWeb.deprecateAliases = true;
LoginWeb.aliases = ['force:auth:web:login', 'auth:web:login'];
LoginWeb.flags = {
    browser: sf_plugins_core_1.Flags.string({
        char: 'b',
        summary: messages.getMessage('flags.browser.summary'),
        description: messages.getMessage('flags.browser.description'),
        options: ['chrome', 'edge', 'firefox'], // These are ones supported by "open" package
    }),
    'client-id': sf_plugins_core_1.Flags.string({
        char: 'i',
        summary: commonMessages.getMessage('flags.client-id.summary'),
        deprecateAliases: true,
        aliases: ['clientid'],
    }),
    'instance-url': sf_plugins_core_1.Flags.url({
        char: 'r',
        summary: commonMessages.getMessage('flags.instance-url.summary'),
        description: commonMessages.getMessage('flags.instance-url.description'),
        deprecateAliases: true,
        aliases: ['instanceurl', 'l'],
    }),
    'set-default-dev-hub': sf_plugins_core_1.Flags.boolean({
        char: 'd',
        summary: commonMessages.getMessage('flags.set-default-dev-hub.summary'),
        deprecateAliases: true,
        aliases: ['setdefaultdevhubusername', 'setdefaultdevhub', 'v'],
    }),
    'set-default': sf_plugins_core_1.Flags.boolean({
        char: 's',
        summary: commonMessages.getMessage('flags.set-default.summary'),
        deprecateAliases: true,
        aliases: ['setdefaultusername'],
    }),
    alias: sf_plugins_core_1.Flags.string({
        char: 'a',
        summary: commonMessages.getMessage('flags.alias.summary'),
        deprecateAliases: true,
        aliases: ['setalias'],
    }),
    'disable-masking': sf_plugins_core_1.Flags.boolean({
        summary: commonMessages.getMessage('flags.disable-masking.summary'),
        hidden: true,
        deprecateAliases: true,
        aliases: ['disablemasking'],
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        char: 'p',
        summary: commonMessages.getMessage('flags.no-prompt.summary'),
        required: false,
        hidden: true,
        deprecateAliases: true,
        aliases: ['noprompt'],
    }),
    loglevel: sf_plugins_core_1.loglevel,
};
const isSFDXContainerMode = () => {
    const env = new kit_1.Env();
    return env.getBoolean('SFDX_CONTAINER_MODE');
};
//# sourceMappingURL=web.js.map