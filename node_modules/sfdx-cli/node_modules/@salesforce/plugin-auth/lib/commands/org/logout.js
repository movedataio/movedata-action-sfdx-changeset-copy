"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const core_1 = require("@salesforce/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const inquirer_1 = require("inquirer");
const chalk = require("chalk");
const authBaseCommand_1 = require("../../authBaseCommand");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'logout');
const commonMessages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
class Logout extends authBaseCommand_1.AuthBaseCommand {
    static buildChoices(orgAuths, all) {
        const maxUsernameLength = Math.max('Username'.length, ...orgAuths.map((orgAuth) => orgAuth.username.length));
        const maxAliasLength = Math.max('Aliases'.length, ...orgAuths.map((orgAuth) => (orgAuth.aliases ? orgAuth.aliases.join(',') : '').length));
        const maxConfigLength = Math.max('Configs'.length, ...orgAuths.map((orgAuth) => (orgAuth.configs ? orgAuth.configs.join(',') : '').length));
        const maxTypeLength = Math.max('Type'.length, ...orgAuths.map((orgAuth) => {
            if (orgAuth.isScratchOrg) {
                return 'Scratch'.length;
            }
            if (orgAuth.isDevHub) {
                return 'DevHub'.length;
            }
            if (orgAuth.isSandbox) {
                return 'Sandbox'.length;
            }
            return 0;
        }));
        const choices = orgAuths
            .map((orgAuth) => {
            const aliasString = (orgAuth.aliases ? orgAuth.aliases.join(',') : '').padEnd(maxAliasLength, ' ');
            const configString = (orgAuth.configs ? orgAuth.configs.join(',') : '').padEnd(maxConfigLength, ' ');
            const typeString = chalk.dim((orgAuth.isScratchOrg ? 'Scratch' : orgAuth.isDevHub ? 'DevHub' : orgAuth.isSandbox ? 'Sandbox' : '').padEnd(maxTypeLength, ' '));
            // username - aliases - configs
            const key = `${chalk.bold(orgAuth.username.padEnd(maxUsernameLength))} | ${typeString} | ${aliasString} | ${chalk.yellowBright(configString)}`;
            return { name: key, value: orgAuth, checked: all, short: `${os.EOL}${orgAuth.username}` };
        })
            .sort((a, b) => a.value.username.localeCompare(b.value.username));
        const userHeader = `${'Username'.padEnd(maxUsernameLength, ' ')}`;
        const aliasHeader = `${'Aliases'.padEnd(maxAliasLength, ' ')}`;
        const configHeader = `${'Configs'.padEnd(maxConfigLength, ' ')}`;
        const typeHeader = `${'Type'.padEnd(maxTypeLength, ' ')}`;
        return [new inquirer_1.Separator(`  ${userHeader} | ${typeHeader} | ${aliasHeader} | ${configHeader}`), ...choices];
    }
    async run() {
        const { flags } = await this.parse(Logout);
        this.flags = flags;
        this.configAggregator = await core_1.ConfigAggregator.create();
        const remover = await core_1.AuthRemover.create();
        let orgAuths = [];
        const targetUsername = this.flags['target-org'] ?? this.configAggregator.getInfo(core_1.OrgConfigProperties.TARGET_ORG).value;
        // if no-prompt, there must be a resolved target-org or --all
        if (flags['no-prompt'] && !targetUsername && !flags.all) {
            throw messages.createError('noOrgSpecifiedWithNoPrompt');
        }
        if (this.jsonEnabled() && !targetUsername && !flags.all) {
            throw messages.createError('noOrgSpecifiedWithJson');
        }
        if (this.shouldFindAllAuths(targetUsername)) {
            orgAuths = await core_1.AuthInfo.listAllAuthorizations();
        }
        else if (targetUsername) {
            orgAuths = await core_1.AuthInfo.listAllAuthorizations((orgAuth) => orgAuth.username === targetUsername || !!orgAuth.aliases?.includes(targetUsername));
        }
        else {
            // just for clarity
            orgAuths = [];
        }
        if (orgAuths.length === 0) {
            if (this.flags['target-org']) {
                // user specified a target org but it was not resolved, issue success message and return
                this.logSuccess(messages.getMessage('logoutOrgCommandSuccess', [this.flags['target-org']]));
                return [this.flags['target-org']];
            }
            this.info(messages.getMessage('noOrgsFound'));
            return [];
        }
        const { orgs, confirmed } = await this.promptForOrgsToRemove(orgAuths, flags.all);
        if (confirmed) {
            for (const org of orgs) {
                // run sequentially to avoid configFile concurrency issues
                // eslint-disable-next-line no-await-in-loop
                await remover.removeAuth(org.username);
            }
            const loggedOutUsernames = orgs.map((org) => org.username);
            this.logSuccess(messages.getMessage('logoutOrgCommandSuccess', [loggedOutUsernames.join(os.EOL)]));
            return loggedOutUsernames;
        }
        else {
            this.info(messages.getMessage('noOrgsSelected'));
            return [];
        }
    }
    shouldFindAllAuths(targetUsername) {
        if (targetUsername && !this.flags.all) {
            return false;
        }
        return this.flags.all || core_1.Global.getEnvironmentMode() === core_1.Mode.DEMO || !this.flags['no-prompt'];
    }
    async promptForOrgsToRemove(orgAuths, all) {
        if (this.flags['no-prompt'] || this.jsonEnabled()) {
            return { orgs: orgAuths, confirmed: true };
        }
        if (orgAuths.length === 1) {
            if (orgAuths[0].isScratchOrg) {
                this.warn(messages.getMessage('warning'));
            }
            if (await this.confirm(messages.getMessage('prompt.confirm.single', [orgAuths[0].username]), 30000, false)) {
                return { orgs: orgAuths, confirmed: true };
            }
            else {
                return { orgs: [], confirmed: false };
            }
        }
        // pick the orgs to delete - if this.flags.all - set each org to selected
        // otherwise prompt the user to select the orgs to delete
        const choices = Logout.buildChoices(orgAuths, all);
        const { orgs, confirmed } = await this.timedPrompt([
            {
                name: 'orgs',
                message: messages.getMessage('prompt.select-envs'),
                type: 'checkbox',
                choices,
                loop: true,
            },
            {
                name: 'confirmed',
                when: (answers) => answers.orgs.length > 0,
                message: (answers) => {
                    const hasScratchOrgs = answers.orgs.some((org) => org.isScratchOrg);
                    if (hasScratchOrgs) {
                        this.warn(messages.getMessage('warning'));
                    }
                    const names = answers.orgs.map((org) => org.username);
                    if (names.length === orgAuths.length) {
                        return messages.getMessage('prompt.confirm-all');
                    }
                    else {
                        return messages.getMessage('prompt.confirm', [names.length, names.length > 1 ? 's' : '']);
                    }
                },
                type: 'confirm',
                default: false,
            },
        ], 30000);
        return {
            orgs: orgs.map((a) => a),
            confirmed,
        };
    }
}
exports.default = Logout;
Logout.summary = messages.getMessage('summary');
Logout.description = messages.getMessage('description');
Logout.examples = messages.getMessages('examples');
Logout.deprecateAliases = true;
Logout.aliases = ['force:auth:logout', 'auth:logout'];
Logout.flags = {
    'target-org': sf_plugins_core_1.Flags.string({
        summary: messages.getMessage('flags.target-org.summary'),
        char: 'o',
        aliases: ['targetusername', 'u'],
        deprecateAliases: true,
    }),
    all: sf_plugins_core_1.Flags.boolean({
        char: 'a',
        summary: messages.getMessage('flags.all.summary'),
        description: messages.getMessage('flags.all.description'),
        required: false,
        default: false,
        exclusive: ['target-org'],
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        char: 'p',
        summary: commonMessages.getMessage('flags.no-prompt.summary'),
        required: false,
        deprecateAliases: true,
        aliases: ['noprompt'],
    }),
    loglevel: sf_plugins_core_1.loglevel,
};
//# sourceMappingURL=logout.js.map