"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthBaseCommand = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const chalk = require("chalk");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-auth', 'messages');
function dimMessage(message) {
    return chalk.dim(message);
}
class AuthBaseCommand extends sf_plugins_core_1.SfCommand {
    constructor(argv, config) {
        super(argv, config);
    }
    async askForHiddenResponse(messageKey, disableMasking = false) {
        const msg = dimMessage(messages.getMessage(messageKey));
        const hidden = await this.prompt({
            message: msg,
            type: 'input',
            name: 'response',
            transformer: (input) => (disableMasking ? input : '*'.repeat(input.length)),
        });
        return hidden.response;
    }
    async shouldExitCommand(noPrompt, message) {
        if (noPrompt || core_1.Global.getEnvironmentMode() !== core_1.Mode.DEMO) {
            return false;
        }
        else {
            const msg = dimMessage(message ?? messages.getMessage('warnAuth', [this.config.bin]));
            const answer = await this.confirm(msg);
            return !answer;
        }
    }
    async shouldRunCommand(noPrompt, message, defaultAnswer = true) {
        if (noPrompt || core_1.Global.getEnvironmentMode() === core_1.Mode.DEMO) {
            return true;
        }
        else {
            const msg = dimMessage(message ?? messages.getMessage('warnAuth', [this.config.bin]));
            const answer = await this.confirm(msg, 10000, defaultAnswer);
            return answer;
        }
    }
    async askForClientSecret(disableMasking = false) {
        return this.askForHiddenResponse('clientSecretStdin', disableMasking);
    }
    async askForAccessToken(disableMasking = false) {
        return this.askForHiddenResponse('accessTokenStdin', disableMasking);
    }
    async askOverwriteAuthFile(username) {
        const yN = await this.confirm(messages.getMessage('overwriteAccessTokenAuthUserFile', [username]));
        return yN;
    }
}
exports.AuthBaseCommand = AuthBaseCommand;
//# sourceMappingURL=authBaseCommand.js.map