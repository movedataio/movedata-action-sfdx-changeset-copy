"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestReporter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const apex_node_1 = require("@salesforce/apex-node");
const core_1 = require("@salesforce/core");
const utils_1 = require("../utils");
const jsonReporter_1 = require("./jsonReporter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-apex', 'runtest');
class TestReporter {
    /**
     * Create a TestReporter that will format test results
     *
     * @param ux a new Ux instance based on if the command is in json mode
     * @param connection a connection to the org the tests are being run against - used for getting username for hints
     * @param bin the bin of the cli, used for providing suggestions in the users cli
     */
    constructor(ux, connection, bin) {
        this.ux = ux;
        this.connection = connection;
        this.bin = bin;
    }
    async report(result, options) {
        if (options['output-dir']) {
            const jsonOutput = this.formatResultInJson(result);
            const outputDirConfig = this.buildOutputDirConfig(result, jsonOutput, options['output-dir'], options['result-format'], Boolean(options['detailed-coverage']), options.synchronous);
            const testService = new apex_node_1.TestService(this.connection);
            await testService.writeResultFiles(result, outputDirConfig, options['code-coverage']);
        }
        try {
            if (result.summary && result.summary.outcome === "Failed" /* ApexTestRunResultStatus.Failed */) {
                process.exitCode = utils_1.FAILURE_EXIT_CODE;
            }
            switch (options['result-format']) {
                case 'human':
                    this.logHuman(result, options['detailed-coverage'], options['output-dir']);
                    break;
                case 'tap':
                    this.logTap(result);
                    break;
                case 'junit':
                    this.logJUnit(result);
                    break;
                case 'json':
                    // when --json flag is specified, we should log CLI json format
                    if (!options.json) {
                        this.ux.styledJSON({
                            status: process.exitCode,
                            result: this.formatResultInJson(result),
                        });
                    }
                    break;
                default:
                    this.logHuman(result, options['detailed-coverage'], options['output-dir']);
            }
        }
        catch (e) {
            this.ux.styledJSON(result);
            throw messages.createError('testResultProcessErr', [e.message]);
        }
        return this.formatResultInJson(result);
    }
    /**
     * Builds output directory configuration with CLI format result files
     *
     * @param result Test results from async/sync test run
     * @param jsonOutput JSON CLI format of test results
     * @param outputDir Output directory for result files
     * @param resultFormat Result format for output files
     * @param detailedCoverage Boolean to control detailed coverage reporting
     * @param synchronous Whether the test run was synchronous
     * @returns Output directory configuration
     */
    // eslint-disable-next-line class-methods-use-this
    buildOutputDirConfig(result, jsonOutput, outputDir, resultFormat, detailedCoverage, synchronous = false) {
        const outputDirConfig = {
            dirPath: outputDir,
        };
        if ('summary' in result) {
            jsonOutput = jsonOutput;
            if (typeof resultFormat !== 'undefined' || synchronous) {
                outputDirConfig.fileInfos = [
                    {
                        filename: result.summary.testRunId ? `test-result-${result.summary.testRunId}.json` : 'test-result.json',
                        content: jsonOutput,
                    },
                    ...(jsonOutput.coverage
                        ? [
                            {
                                filename: 'test-result-codecoverage.json',
                                content: jsonOutput.coverage?.coverage,
                            },
                        ]
                        : []),
                ];
                outputDirConfig.resultFormats = [apex_node_1.ResultFormat.junit];
            }
            if (typeof resultFormat === 'undefined' && synchronous) {
                resultFormat = apex_node_1.ResultFormat.human;
            }
            switch (resultFormat) {
                case apex_node_1.ResultFormat.tap:
                    outputDirConfig.fileInfos?.push({
                        filename: 'test-result.txt',
                        content: new apex_node_1.TapReporter().format(result),
                    });
                    outputDirConfig.resultFormats?.push(apex_node_1.ResultFormat.tap);
                    break;
                case apex_node_1.ResultFormat.junit:
                    outputDirConfig.fileInfos?.push({
                        filename: 'test-result.xml',
                        content: new apex_node_1.JUnitReporter().format(result),
                    });
                    break;
                case apex_node_1.ResultFormat.human:
                    outputDirConfig.fileInfos?.push({
                        filename: 'test-result.txt',
                        content: new apex_node_1.HumanReporter().format(result, detailedCoverage),
                    });
                    break;
                default:
                    break;
            }
        }
        return outputDirConfig;
    }
    formatResultInJson(result) {
        try {
            const reporter = new jsonReporter_1.JsonReporter();
            return reporter.format(result);
        }
        catch (e) {
            this.ux.styledJSON(result);
            throw messages.createError('testResultProcessErr', [e.message]);
        }
    }
    logHuman(result, detailedCoverage, outputDir) {
        if (outputDir) {
            this.ux.log(messages.getMessage('outputDirHint', [outputDir]));
        }
        const humanReporter = new apex_node_1.HumanReporter();
        const output = humanReporter.format(result, detailedCoverage);
        this.ux.log(output);
    }
    logTap(result) {
        const reporter = new apex_node_1.TapReporter();
        const hint = this.formatReportHint(result);
        this.ux.log(reporter.format(result, [hint]));
    }
    logJUnit(result) {
        const reporter = new apex_node_1.JUnitReporter();
        this.ux.log(reporter.format(result));
    }
    formatReportHint(result) {
        let reportArgs = `-i ${result.summary.testRunId}`;
        const username = this.connection?.getUsername();
        if (username) {
            reportArgs += ` -o ${username}`;
        }
        return messages.getMessage('apexTestReportFormatHint', [this.bin, reportArgs]);
    }
}
exports.TestReporter = TestReporter;
//# sourceMappingURL=testReporter.js.map