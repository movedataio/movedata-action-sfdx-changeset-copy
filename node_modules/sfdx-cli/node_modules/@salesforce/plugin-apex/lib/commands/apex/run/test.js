"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestLevelValues = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const apex_node_1 = require("@salesforce/apex-node");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const reporters_1 = require("../../../reporters");
const utils_1 = require("../../../utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-apex', 'runtest');
exports.TestLevelValues = ['RunLocalTests', 'RunAllTestsInOrg', 'RunSpecifiedTests'];
class Test extends sf_plugins_core_1.SfCommand {
    constructor() {
        super(...arguments);
        this.cancellationTokenSource = new apex_node_1.CancellationTokenSource();
    }
    async run() {
        const { flags } = await this.parse(Test);
        const testLevel = await this.validateFlags(flags['code-coverage'], flags['result-format'], flags['class-names'], flags['suite-names'], flags.tests, flags.synchronous, flags['test-level']);
        // add listener for errors
        process.on('uncaughtException', (err) => {
            throw messages.createError('apexLibErr', [err.message]);
        });
        // graceful shutdown
        const exitHandler = async () => {
            await this.cancellationTokenSource.asyncCancel();
            process.exit();
        };
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        process.on('SIGINT', exitHandler);
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        process.on('SIGTERM', exitHandler);
        const conn = flags['target-org'].getConnection(flags['api-version']);
        const testService = new apex_node_1.TestService(conn);
        // NOTE: This is a *bug*. Synchronous test runs should throw an error when multiple test classes are specified
        // This was re-introduced due to https://github.com/forcedotcom/salesforcedx-vscode/issues/3154
        // Address with W-9163533
        const result = flags.synchronous && testLevel === "RunSpecifiedTests" /* TestLevel.RunSpecifiedTests */
            ? await this.runTest(testService, flags, testLevel)
            : await this.runTestAsynchronous(testService, flags, testLevel);
        if (this.cancellationTokenSource.token.isCancellationRequested) {
            throw new core_1.SfError('Cancelled');
        }
        if ('summary' in result) {
            const testReporter = new reporters_1.TestReporter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), conn, this.config.bin);
            return testReporter.report(result, flags);
        }
        else {
            // async test run
            this.log(messages.getMessage('runTestReportCommand', [this.config.bin, result.testRunId, conn.getUsername()]));
            return result;
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async validateFlags(codeCoverage, resultFormatFlag, classNames, suiteNames, tests, synchronous, testLevel) {
        if ((classNames && (suiteNames || tests)) || (suiteNames && tests)) {
            return Promise.reject(new Error(messages.getMessage('classSuiteTestErr')));
        }
        if (synchronous && (suiteNames || (classNames && classNames.split(',').length > 1))) {
            return Promise.reject(new Error(messages.getMessage('syncClassErr')));
        }
        if ((tests || classNames || suiteNames) && testLevel && testLevel !== 'RunSpecifiedTests') {
            return Promise.reject(new Error(messages.getMessage('testLevelErr')));
        }
        if (testLevel) {
            return testLevel;
        }
        if (classNames || suiteNames || tests) {
            return "RunSpecifiedTests" /* TestLevel.RunSpecifiedTests */;
        }
        return "RunLocalTests" /* TestLevel.RunLocalTests */;
    }
    async runTest(testService, flags, testLevel) {
        const payload = {
            ...(await testService.buildSyncPayload(testLevel, flags.tests, flags['class-names'])),
            skipCodeCoverage: !flags['code-coverage'],
        };
        return testService.runTestSynchronous(payload, flags['code-coverage'], this.cancellationTokenSource.token);
    }
    async runTestAsynchronous(testService, flags, testLevel) {
        const payload = {
            ...(await testService.buildAsyncPayload(testLevel, flags.tests, flags['class-names'], flags['suite-names'])),
            skipCodeCoverage: !flags['code-coverage'],
        };
        // cast as TestRunIdResult because we're building an async payload which will return an async result
        return testService.runTestAsynchronous(payload, flags['code-coverage'], flags.wait && flags.wait.minutes > 0 ? false : !(flags.synchronous && !this.jsonEnabled()), undefined, this.cancellationTokenSource.token);
    }
}
exports.default = Test;
Test.summary = messages.getMessage('summary');
Test.description = messages.getMessage('description');
Test.examples = messages.getMessages('examples');
Test.deprecateAliases = true;
Test.aliases = ['force:apex:test:run'];
Test.flags = {
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'code-coverage': sf_plugins_core_1.Flags.boolean({
        aliases: ['codecoverage'],
        deprecateAliases: true,
        char: 'c',
        summary: messages.getMessage('flags.code-coverage.summary'),
    }),
    'output-dir': sf_plugins_core_1.Flags.directory({
        aliases: ['outputdir', 'output-directory'],
        deprecateAliases: true,
        char: 'd',
        summary: messages.getMessage('flags.output-dir.summary'),
    }),
    'test-level': sf_plugins_core_1.Flags.string({
        deprecateAliases: true,
        aliases: ['testlevel'],
        char: 'l',
        summary: messages.getMessage('flags.test-level.summary'),
        description: messages.getMessage('flags.test-level.description'),
        options: exports.TestLevelValues,
    }),
    'class-names': sf_plugins_core_1.Flags.string({
        deprecateAliases: true,
        aliases: ['classnames'],
        char: 'n',
        summary: messages.getMessage('flags.class-names.summary'),
        description: messages.getMessage('flags.class-names.description'),
    }),
    'result-format': sf_plugins_core_1.Flags.string({
        deprecateAliases: true,
        aliases: ['resultformat'],
        char: 'r',
        summary: messages.getMessage('flags.result-format.summary'),
        options: utils_1.resultFormat,
        default: 'human',
    }),
    'suite-names': sf_plugins_core_1.Flags.string({
        deprecateAliases: true,
        aliases: ['suitenames'],
        char: 's',
        summary: messages.getMessage('flags.suite-names.summary'),
        description: messages.getMessage('flags.suite-names.description'),
    }),
    tests: sf_plugins_core_1.Flags.string({
        char: 't',
        summary: messages.getMessage('flags.tests.summary'),
        description: messages.getMessage('flags.tests.description'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        summary: messages.getMessage('flags.wait.summary'),
    }),
    synchronous: sf_plugins_core_1.Flags.boolean({
        char: 'y',
        summary: messages.getMessage('flags.synchronous.summary'),
    }),
    'detailed-coverage': sf_plugins_core_1.Flags.boolean({
        deprecateAliases: true,
        aliases: ['detailedcoverage'],
        char: 'v',
        summary: messages.getMessage('flags.detailed-coverage.summary'),
        dependsOn: ['code-coverage'],
    }),
};
//# sourceMappingURL=test.js.map