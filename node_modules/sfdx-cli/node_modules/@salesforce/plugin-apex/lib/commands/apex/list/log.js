"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const apex_node_1 = require("@salesforce/apex-node");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-apex', 'list');
class Log extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Log);
        const conn = flags['target-org'].getConnection(flags['api-version']);
        const logService = new apex_node_1.LogService(conn);
        const logRecords = await logService.getLogRecords();
        if (logRecords.length === 0) {
            this.log(messages.getMessage('noDebugLogsFound'));
            return [];
        }
        logRecords.map((logRecord) => {
            logRecord.StartTime = this.formatTime(logRecord.StartTime);
        });
        if (!flags.json) {
            // while not required to prevent table output, save a few iterations if only printing json
            const cleanLogs = logRecords.map((logRecord) => ({
                app: logRecord.Application,
                duration: String(logRecord.DurationMilliseconds),
                id: logRecord.Id,
                location: logRecord.Location,
                size: String(logRecord.LogLength),
                user: logRecord.LogUser.Name,
                operation: logRecord.Operation,
                request: logRecord.Request,
                time: logRecord.StartTime,
                status: logRecord.Status,
            }));
            this.table(cleanLogs, {
                app: { header: messages.getMessage('appColHeader') },
                duration: { header: messages.getMessage('durationColHeader') },
                id: { header: messages.getMessage('idColHeader') },
                location: { header: messages.getMessage('locationColHeader') },
                size: { header: messages.getMessage('sizeColHeader') },
                user: { header: messages.getMessage('userColHeader') },
                operation: { header: messages.getMessage('operationColHeader') },
                request: { header: messages.getMessage('requestColHeader') },
                time: { header: messages.getMessage('timeColHeader') },
                status: { header: messages.getMessage('statusColHeader') },
            }, { 'no-truncate': true });
        }
        return logRecords;
    }
    // eslint-disable-next-line class-methods-use-this
    formatTime(time) {
        const milliIndex = time.indexOf('.');
        if (milliIndex !== -1) {
            return time.substring(0, milliIndex) + time.substring(milliIndex + 4);
        }
        return time;
    }
}
exports.default = Log;
Log.summary = messages.getMessage('summary');
Log.description = messages.getMessage('description');
Log.examples = messages.getMessages('examples');
Log.deprecateAliases = true;
Log.aliases = ['force:apex:log:list'];
Log.flags = {
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
};
//# sourceMappingURL=log.js.map