"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveZipFileName = exports.SourceCommand = void 0;
const path_1 = require("path");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const core_2 = require("@oclif/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'flags.validation');
class SourceCommand extends sf_plugins_core_1.SfCommand {
    initProgressBar() {
        this.debug('initializing progress bar');
        this.progressBar = core_2.ux.progress({
            format: 'SOURCE PROGRESS | {bar} | {value}/{total} Components',
            barCompleteChar: '\u2588',
            barIncompleteChar: '\u2591',
            linewrap: true,
        });
    }
    /**
     * Sets an exit code on the process that marks success or failure
     * after successful command execution.
     *
     * @param code The exit code to set on the process.
     */
    // eslint-disable-next-line class-methods-use-this
    setExitCode(code) {
        process.exitCode = code;
    }
    getPackageDirs() {
        return this.project.getUniquePackageDirectories().map((pDir) => pDir.fullPath);
    }
    async getSourceApiVersion() {
        const projectConfig = await this.project.resolveProjectConfig();
        return (0, ts_types_1.getString)(projectConfig, 'sourceApiVersion');
    }
    /**
     * Ensures command flags that are file system paths are set properly before
     * continuing command execution.  Can also create directories that don't yet
     * exist in the path.
     *
     * @param options defines the path to resolve and the expectations
     * @returns the resolved flag path
     */
    // eslint-disable-next-line class-methods-use-this
    ensureFlagPath(options) {
        const { flagName, path, type, throwOnENOENT } = options;
        const trimmedPath = path?.trim();
        let resolvedPath;
        if (trimmedPath?.length) {
            resolvedPath = (0, path_1.resolve)(trimmedPath);
        }
        try {
            const stats = fs.statSync(resolvedPath);
            if (type !== 'any') {
                const isDir = stats.isDirectory();
                if (type === 'dir' && !isDir) {
                    const msg = messages.getMessage('expectedDirectory');
                    throw new core_1.SfError(messages.getMessage('InvalidFlagPath', [flagName, path, msg]), 'InvalidFlagPath');
                }
                else if (type === 'file' && isDir) {
                    const msg = messages.getMessage('expectedFile');
                    throw new core_1.SfError(messages.getMessage('InvalidFlagPath', [flagName, path, msg]), 'InvalidFlagPath');
                }
            }
        }
        catch (error) {
            const err = error;
            if (err.code !== 'ENOENT') {
                throw err;
            }
            else {
                if (throwOnENOENT) {
                    const enoent = messages.getMessage('notFound');
                    throw new core_1.SfError(messages.getMessage('InvalidFlagPath', [flagName, path, enoent]), 'InvalidFlagPath');
                }
                const dir = type === 'dir' ? resolvedPath : (0, path_1.dirname)(resolvedPath);
                fs.mkdirSync(dir, { recursive: true });
            }
        }
        return resolvedPath;
    }
}
exports.SourceCommand = SourceCommand;
SourceCommand.DEFAULT_WAIT_MINUTES = 33;
const resolveZipFileName = (zipFileName) => {
    // If no file extension was provided append, '.zip'
    if (zipFileName && !(0, path_1.extname)(zipFileName)) {
        zipFileName += '.zip';
    }
    return zipFileName || 'unpackaged.zip';
};
exports.resolveZipFileName = resolveZipFileName;
//# sourceMappingURL=sourceCommand.js.map