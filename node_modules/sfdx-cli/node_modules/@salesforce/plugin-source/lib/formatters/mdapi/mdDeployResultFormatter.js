"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdDeployResultFormatter = void 0;
const chalk = require("chalk");
const ts_types_1 = require("@salesforce/ts-types");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const kit_1 = require("@salesforce/kit");
const resultFormatter_1 = require("../resultFormatter");
const coverageUtils_1 = require("../../coverageUtils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.deploy');
class MdDeployResultFormatter extends resultFormatter_1.ResultFormatter {
    constructor(ux, options, result) {
        super(ux, options);
        this.result = result;
    }
    /**
     * Get the JSON output from the DeployResult.
     *
     * @returns a JSON formatted result matching the provided type.
     */
    getJson() {
        // concise omits success messages
        // spread properties prevents modification of the object from impacting tests
        const response = this.getResponse();
        if (this.options.testsRan) {
            response.coverage = this.getCoverageFileInfo();
            response.junit = this.getJunitFileInfo();
        }
        if (this.isConcise()) {
            return {
                ...response,
                details: {
                    componentFailures: response.details.componentFailures,
                    runTestResult: response.details.runTestResult,
                },
            };
        }
        return response;
    }
    /**
     * @param isReportCommand set to true if the command is deploy:report.  The output is slightly different
     * Displays deploy results in human readable format.  Output can vary based on:
     *
     * 1. Verbose option
     * 3. Checkonly deploy (checkonly=true)
     * 4. Deploy with test results
     * 5. Canceled status
     */
    display(isReportCommand = false) {
        if (this.hasStatus(source_deploy_retrieve_1.RequestStatus.Canceled)) {
            const canceledByName = this.result.response.canceledByName ?? 'unknown';
            throw new core_1.SfError(messages.getMessage('deployCanceled', [canceledByName]), 'DeployFailed');
        }
        if (this.isVerbose()) {
            this.displaySuccesses();
            this.displayFailures();
            this.displayTestResults(isReportCommand);
            this.displayOutputFileLocations();
        }
        else if (isReportCommand) {
            this.ux.log(`Status: ${this.result.response.status ?? 'unknown'}`);
            const deploys = `Deployed: ${this.getNumResult('numberComponentsDeployed')}/${this.getNumResult('numberComponentsTotal')}`;
            const deployErrors = `Errors: ${this.getNumResult('numberComponentErrors')}`;
            const tests = `Tests Complete: ${this.getNumResult('numberTestsCompleted')}/${this.getNumResult('numberTestsTotal')}`;
            const testErrs = `Errors: ${this.getNumResult('numberTestErrors')}`;
            this.ux.log(`${deploys} ${deployErrors}`);
            this.ux.log(`${tests} ${testErrs}`);
            this.displayOutputFileLocations();
        }
        else {
            // always show failures
            this.displayFailures();
            this.displayTestResults(isReportCommand);
            this.displayOutputFileLocations();
        }
        // TODO: the toolbelt version of this is returning an SfError shape.  This returns a status=1 and the result (mdapi response) but not the error name, etc
        if (!this.isSuccess()) {
            // Add error message directly on the DeployResult (e.g., a GACK)
            const errMsg = this.getResponse()?.errorMessage ?? '';
            const error = new core_1.SfError(messages.getMessage('deployFailed', [errMsg]), 'mdapiDeployFailed');
            error.setData(this.result);
            throw error;
        }
    }
    hasStatus(status) {
        return this.result.response.status === status;
    }
    getResponse() {
        return this.result.response ?? {};
    }
    displaySuccesses() {
        if (this.isSuccess() && this.isVerbose()) {
            const successes = (0, kit_1.ensureArray)(this.getResponse().details.componentSuccesses).sort(mdResponseSorter);
            this.ux.log('');
            this.ux.styledHeader(chalk.blue('Deployed Source'));
            this.ux.table(successes, {
                componentType: { header: 'Type' },
                fileName: { header: 'File' },
                fullName: { header: 'Name' },
                id: { header: 'Id' },
            });
        }
    }
    displayFailures() {
        if (this.hasStatus(source_deploy_retrieve_1.RequestStatus.Failed) || this.hasStatus(source_deploy_retrieve_1.RequestStatus.SucceededPartial)) {
            const failures = (0, kit_1.ensureArray)(this.getResponse().details.componentFailures).sort(mdResponseSorter);
            if (failures.length === 0) {
                return;
            }
            this.ux.log('');
            this.ux.styledHeader(chalk.red(`Component Failures [${failures.length}]`));
            this.ux.table(failures, {
                problemType: { header: 'Type' },
                fileName: { header: 'File' },
                fullName: { header: 'Name' },
                problem: { header: 'Problem' },
            });
            this.ux.log('');
        }
    }
    getNumResult(field) {
        return (0, ts_types_1.getNumber)(this.result, `response.${field}`, 0);
    }
    displayTestResults(isReportCommand = false) {
        if (this.result.response.runTestsEnabled) {
            this.ux.log('');
            if (this.isVerbose() || !isReportCommand) {
                this.verboseTestFailures();
                this.verboseTestSuccess();
                this.verboseTestTime();
            }
            else {
                this.ux.styledHeader(chalk.blue('Test Results Summary'));
                this.ux.log(`Passing: ${this.getNumResult('numberTestsCompleted')}`);
                this.ux.log(`Failing: ${this.getNumResult('numberTestErrors')}`);
                this.ux.log(`Total: ${this.getNumResult('numberTestsTotal')}`);
                this.ux.log(`Time: ${this.getNumResult('details.runTestResult.totalTime')}`);
            }
        }
    }
    verboseTestFailures() {
        if (this.result?.response?.numberTestErrors) {
            const failures = (0, kit_1.ensureArray)(this.result.response.details?.runTestResult?.failures);
            const tests = this.sortTestResults(failures);
            this.ux.log('');
            this.ux.styledHeader(chalk.red(`Test Failures [${this.result.response.details.runTestResult?.numFailures}]`));
            this.ux.table(tests.map((test) => ({
                name: test.name,
                methodName: test.methodName,
                message: test.message,
                stackTrace: test.stackTrace,
            })), {
                name: { header: 'Name' },
                methodName: { header: 'Method' },
                message: { header: 'Message' },
                stackTrace: { header: 'Stacktrace' },
            });
        }
    }
    verboseTestSuccess() {
        const success = (0, kit_1.ensureArray)(this.result?.response?.details?.runTestResult?.successes);
        if (success.length) {
            const tests = this.sortTestResults(success);
            this.ux.log('');
            this.ux.styledHeader(chalk.green(`Test Success [${success.length}]`));
            this.ux.table(tests.map((test) => ({ name: test.name, methodName: test.methodName })), {
                name: { header: 'Name' },
                methodName: { header: 'Method' },
            });
        }
        const codeCoverage = (0, kit_1.ensureArray)(this.result?.response?.details?.runTestResult?.codeCoverage);
        if (codeCoverage.length) {
            const coverage = (0, coverageUtils_1.prepCoverageForDisplay)(codeCoverage);
            this.ux.log('');
            this.ux.styledHeader(chalk.blue('Apex Code Coverage'));
            // TODO: unsure about locationsNotCovered vs lineNotCovered
            this.ux.table(coverage.map((entry) => ({
                name: entry.name,
                numLocations: entry.numLocations,
                lineNotCovered: entry.locationsNotCovered,
            })), {
                name: { header: 'Name' },
                numLocations: { header: '% Covered' },
                lineNotCovered: { header: 'Uncovered Lines' },
            });
        }
    }
    verboseTestTime() {
        if (this.result.response?.details?.runTestResult?.successes ||
            this.result?.response?.details?.runTestResult?.failures) {
            this.ux.log('');
            this.ux.log(`Total Test Time:  ${this.result?.response?.details?.runTestResult?.totalTime}`);
        }
    }
}
exports.MdDeployResultFormatter = MdDeployResultFormatter;
const mdResponseSorter = (i, j) => {
    if (i.componentType === j.componentType) {
        if (i.fileName === j.fileName) {
            return i.fullName > j.fullName ? 1 : -1;
        }
        return i.fileName > j.fileName ? 1 : -1;
    }
    return i.componentType > j.componentType ? 1 : -1;
};
//# sourceMappingURL=mdDeployResultFormatter.js.map