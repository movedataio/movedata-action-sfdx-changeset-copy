"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deploy = void 0;
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const deployCommand_1 = require("../../../deployCommand");
const deployResultFormatter_1 = require("../../../formatters/deployResultFormatter");
const deployAsyncResultFormatter_1 = require("../../../formatters/source/deployAsyncResultFormatter");
const deployProgressBarFormatter_1 = require("../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../formatters/deployProgressStatusFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'deploy');
const deployMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'deployCommand');
// One of these flags must be specified for a valid deploy.
const xorFlags = ['manifest', 'metadata', 'sourcepath', 'validateddeployrequestid'];
const replacement = 'project deploy start';
class Deploy extends deployCommand_1.DeployCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['predeploy', 'postdeploy'];
    }
    async run() {
        this.flags = (await this.parse(Deploy)).flags;
        this.org = await core_1.Org.create({ aliasOrUsername: this.flags['target-org'] });
        await this.preChecks();
        await this.deploy();
        this.resolveSuccess();
        await this.maybeUpdateTracking();
        return this.formatResult();
    }
    async preChecks() {
        if (this.flags.tracksource) {
            this.tracking = await (0, trackingFunctions_1.trackingSetup)({
                // we'll check ACTUAL conflicts once we get a componentSet built
                ignoreConflicts: true,
                org: this.org,
                project: this.project,
                ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
            });
        }
    }
    // There are 3 types of deploys:
    //   1. synchronous - deploy metadata and wait for the deploy to complete.
    //   2. asynchronous - deploy metadata and immediately return.
    //   3. recent validation - deploy metadata that's already been validated by the org
    async deploy() {
        const waitDuration = this.flags.wait;
        this.isAsync = waitDuration.quantity === 0;
        this.isRest = this.isRestDeploy();
        if (this.isAsync && (this.flags.coverageformatters || this.flags.junit)) {
            this.warn(messages.getMessage('asyncCoverageJunitWarning'));
        }
        if (this.flags.validateddeployrequestid) {
            this.deployResult = await this.deployRecentValidation(this.flags.validateddeployrequestid, this.org.getConnection());
        }
        else {
            this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
                apiversion: this.flags['api-version'],
                sourceapiversion: await this.getSourceApiVersion(),
                sourcepath: this.flags.sourcepath,
                manifest: this.flags.manifest && {
                    manifestPath: this.flags.manifest,
                    directoryPaths: this.getPackageDirs(),
                    destructiveChangesPre: this.flags.predestructivechanges,
                    destructiveChangesPost: this.flags.postdestructivechanges,
                },
                metadata: this.flags.metadata && {
                    metadataEntries: this.flags.metadata,
                    directoryPaths: this.getPackageDirs(),
                },
            });
            if (this.flags.tracksource) {
                // will throw if conflicts exist
                if (!this.flags.forceoverwrite) {
                    await (0, trackingFunctions_1.filterConflictsByComponentSet)({
                        tracking: this.tracking,
                        components: this.componentSet,
                        ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
                    });
                }
                const localDeletes = await this.tracking.getChanges({
                    origin: 'local',
                    state: 'delete',
                    format: 'string',
                });
                if (localDeletes.length) {
                    this.warn(messages.getMessage('deployWontDelete'));
                }
            }
            // fire predeploy event for sync and async deploys
            await core_1.Lifecycle.getInstance().emit('predeploy', this.componentSet.toArray());
            const username = this.org.getUsername();
            // eslint-disable-next-line @typescript-eslint/require-await
            core_1.Lifecycle.getInstance().on('apiVersionDeploy', async (apiData) => {
                this.log(deployMessages.getMessage('apiVersionMsgDetailed', [
                    'Deploying',
                    apiData.manifestVersion,
                    username,
                    apiData.apiVersion,
                    apiData.webService,
                ]));
            });
            const deploy = await this.componentSet.deploy({
                usernameOrConnection: username,
                apiOptions: {
                    ...{
                        purgeOnDelete: this.flags.purgeondelete ?? false,
                        ignoreWarnings: this.flags.ignorewarnings ?? false,
                        rollbackOnError: !this.flags.ignoreerrors ?? false,
                        checkOnly: this.flags.checkonly ?? false,
                        rest: this.isRest,
                    },
                    // if runTests is defaulted as 'NoTestRun' and deploying to prod, you'll get this error
                    // https://github.com/forcedotcom/cli/issues/1542
                    // add additional properties conditionally ()
                    ...(this.flags.testlevel ? { testLevel: this.flags.testlevel } : {}),
                    ...(this.flags.runtests ? { runTests: this.flags.runtests } : {}),
                },
            });
            this.asyncDeployResult = { id: deploy.id };
            this.updateDeployId(deploy.id);
            if (!this.isAsync) {
                // we're not print JSON output
                if (!this.jsonEnabled()) {
                    const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                        ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }))
                        : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), {
                            verbose: this.flags.verbose,
                        });
                    progressFormatter.progress(deploy);
                }
                this.deployResult = await deploy.pollStatus({ timeout: waitDuration });
            }
        }
        if (this.deployResult) {
            // Only fire the postdeploy event when we have results. I.e., not async.
            await core_1.Lifecycle.getInstance().emit('postdeploy', this.deployResult);
        }
    }
    formatResult() {
        this.resultsDir = this.resolveOutputDir(this.flags.coverageformatters, this.flags.junit, this.flags.resultsdir, this.deployResult?.response?.id, false);
        const formatterOptions = {
            verbose: this.flags.verbose ?? false,
            username: this.org.getUsername(),
            coverageOptions: (0, deployCommand_1.getCoverageFormattersOptions)(this.flags.coverageformatters),
            junitTestResults: this.flags.junit,
            resultsDir: this.resultsDir,
            testsRan: (this.flags.testlevel ?? 'NoTestRun') !== 'NoTestRun',
        };
        const formatter = this.isAsync
            ? new deployAsyncResultFormatter_1.DeployAsyncResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), formatterOptions, this.asyncDeployResult)
            : new deployResultFormatter_1.DeployResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), formatterOptions, this.deployResult);
        if (!this.isAsync) {
            this.maybeCreateRequestedReports({
                coverageformatters: this.flags.coverageformatters,
                junit: this.flags.junit,
                org: this.org,
            });
        }
        // Only display results to console when JSON flag is unset.
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
    async maybeUpdateTracking() {
        if (this.flags.tracksource ?? false) {
            return (0, trackingFunctions_1.updateTracking)({
                ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
                result: this.deployResult,
                tracking: this.tracking,
            });
        }
    }
}
exports.Deploy = Deploy;
Deploy.summary = messages.getMessage('summary');
Deploy.description = messages.getMessage('description');
Deploy.examples = messages.getMessages('examples');
Deploy.state = 'deprecated';
Deploy.deprecationOptions = {
    to: replacement,
    message: messages.getMessage('deprecation', [replacement]),
};
Deploy.requiresProject = true;
Deploy.flags = {
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': deployCommand_1.targetUsernameFlag,
    checkonly: sf_plugins_core_1.Flags.boolean({
        char: 'c',
        description: messages.getMessage('flags.checkonly.description'),
        summary: messages.getMessage('flags.checkonly.summary'),
    }),
    soapdeploy: sf_plugins_core_1.Flags.boolean({
        default: false,
        summary: messages.getMessage('flags.soapDeploy.summary'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        default: kit_1.Duration.minutes(Deploy.DEFAULT_WAIT_MINUTES),
        min: 0,
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
    }),
    testlevel: sf_plugins_core_1.Flags.string({
        char: 'l',
        description: messages.getMessage('flags.testLevel.description'),
        summary: messages.getMessage('flags.testLevel.summary'),
        options: ['NoTestRun', 'RunSpecifiedTests', 'RunLocalTests', 'RunAllTestsInOrg'],
    }),
    runtests: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'r',
        summary: messages.getMessage('flags.runTests.summary'),
    }),
    ignoreerrors: sf_plugins_core_1.Flags.boolean({
        char: 'o',
        // brfeak this
        description: messages.getMessage('flags.ignoreErrors.description'),
        summary: messages.getMessage('flags.ignoreErrors.summary'),
    }),
    ignorewarnings: sf_plugins_core_1.Flags.boolean({
        char: 'g',
        description: messages.getMessage('flags.ignoreWarnings.description'),
        summary: messages.getMessage('flags.ignoreWarnings.summary'),
    }),
    purgeondelete: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.purgeOnDelete.summary'),
        dependsOn: ['manifest'],
    }),
    validateddeployrequestid: sf_plugins_core_1.Flags.salesforceId({
        char: 'q',
        description: messages.getMessage('flags.validateDeployRequestId.description'),
        summary: messages.getMessage('flags.validateDeployRequestId.summary'),
        exactlyOne: xorFlags,
        exclusive: ['checkonly', 'testlevel', 'runtests', 'tracksource'],
        startsWith: '0Af',
    }),
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
    metadata: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'm',
        description: messages.getMessage('flags.metadata.description'),
        summary: messages.getMessage('flags.metadata.summary'),
        exactlyOne: xorFlags,
    }),
    sourcepath: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'p',
        description: messages.getMessage('flags.sourcePath.description'),
        summary: messages.getMessage('flags.sourcePath.summary'),
        exactlyOne: xorFlags,
    }),
    manifest: sf_plugins_core_1.Flags.file({
        char: 'x',
        description: messages.getMessage('flags.manifest.description'),
        summary: messages.getMessage('flags.manifest.summary'),
        exactlyOne: xorFlags,
    }),
    predestructivechanges: sf_plugins_core_1.Flags.file({
        summary: messages.getMessage('flags.predestructivechanges.summary'),
        dependsOn: ['manifest'],
    }),
    postdestructivechanges: sf_plugins_core_1.Flags.file({
        summary: messages.getMessage('flags.postdestructivechanges.summary'),
        dependsOn: ['manifest'],
    }),
    tracksource: sf_plugins_core_1.Flags.boolean({
        char: 't',
        description: messages.getMessage('flags.tracksource.description'),
        summary: messages.getMessage('flags.tracksource.summary'),
        exclusive: ['checkonly', 'validateddeployrequestid'],
    }),
    forceoverwrite: sf_plugins_core_1.Flags.boolean({
        char: 'f',
        summary: messages.getMessage('flags.forceoverwrite.summary'),
        dependsOn: ['tracksource'],
    }),
    resultsdir: sf_plugins_core_1.Flags.directory({
        summary: messages.getMessage('flags.resultsDir.summary'),
    }),
    coverageformatters: (0, sf_plugins_core_1.arrayWithDeprecation)({
        summary: messages.getMessage('flags.coverageFormatters.summary'),
        options: deployCommand_1.reportsFormatters,
        helpValue: deployCommand_1.reportsFormatters.join(','),
    }),
    junit: sf_plugins_core_1.Flags.boolean({ summary: messages.getMessage('flags.junit.summary') }),
};
//# sourceMappingURL=deploy.js.map