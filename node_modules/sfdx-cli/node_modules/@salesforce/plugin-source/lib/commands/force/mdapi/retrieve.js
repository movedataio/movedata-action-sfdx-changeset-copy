"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Retrieve = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const sourceCommand_1 = require("../../../sourceCommand");
const stash_1 = require("../../../stash");
const retrieveResultFormatter_1 = require("../../../formatters/mdapi/retrieveResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.retrieve');
const spinnerMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'spinner');
const retrieveMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'retrieve');
const replacement = 'project retrieve start';
class Retrieve extends sourceCommand_1.SourceCommand {
    async run() {
        this.flags = (await this.parse(Retrieve)).flags;
        this.org = this.flags['target-org'];
        await this.retrieve();
        this.resolveSuccess();
        return this.formatResult();
    }
    async retrieve() {
        const packagenames = this.flags.packagenames;
        if (!packagenames && !this.flags.unpackaged) {
            this.sourceDir = this.resolveRootDir(this.flags.sourcedir);
        }
        this.retrieveTargetDir = this.resolveOutputDir(this.flags.retrievetargetdir);
        const manifest = this.resolveManifest(this.flags.unpackaged);
        const singlePackage = this.flags.singlepackage;
        this.zipFileName = (0, sourceCommand_1.resolveZipFileName)(this.flags.zipfilename);
        this.unzip = this.flags.unzip;
        const waitFlag = this.flags.wait;
        this.wait = waitFlag.minutes === -1 ? kit_1.Duration.days(7) : waitFlag;
        this.isAsync = this.wait.quantity === 0;
        if (singlePackage && packagenames?.length > 1) {
            throw new core_1.SfError(messages.getMessage('InvalidPackageNames', [packagenames.toString()]), 'InvalidPackageNames');
        }
        this.spinner.start(spinnerMessages.getMessage('retrieve.main', [this.org.getUsername()]));
        this.spinner.status = spinnerMessages.getMessage('retrieve.componentSetBuild');
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            // use the apiVersion if provided.
            // Manifests default to their specified apiVersion(ComponentSetBuilder handles this)
            // and not specifying the apiVersion will use the max for the org/Connection
            apiversion: this.flags.apiversion,
            packagenames,
            sourcepath: this.sourceDir ? [this.sourceDir] : undefined,
            manifest: manifest && {
                manifestPath: manifest,
                directoryPaths: [],
            },
        });
        await core_1.Lifecycle.getInstance().emit('preretrieve', { packageXmlPath: manifest });
        const username = this.org.getUsername();
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on('apiVersionRetrieve', async (apiData) => {
            this.log(retrieveMessages.getMessage('apiVersionMsgDetailed', [
                'Retrieving',
                apiData.manifestVersion,
                username,
                apiData.apiVersion,
            ]));
        });
        this.spinner.status = spinnerMessages.getMessage('retrieve.sendingRequest');
        this.mdapiRetrieve = await this.componentSet.retrieve({
            usernameOrConnection: username,
            output: this.retrieveTargetDir,
            packageOptions: this.flags.packagenames,
            format: 'metadata',
            singlePackage,
            zipFileName: this.zipFileName,
            unzip: this.unzip,
        });
        stash_1.Stash.set('MDAPI_RETRIEVE', {
            jobid: this.mdapiRetrieve.id,
            retrievetargetdir: this.retrieveTargetDir,
            zipfilename: this.zipFileName,
            unzip: this.unzip,
        });
        this.log(`Retrieve ID: ${this.mdapiRetrieve.id}`);
        if (this.isAsync) {
            this.spinner.stop('queued');
        }
        else {
            this.spinner.status = spinnerMessages.getMessage('retrieve.polling');
            this.retrieveResult = await this.mdapiRetrieve.pollStatus({
                frequency: kit_1.Duration.milliseconds(1000),
                timeout: this.wait,
            });
            this.spinner.stop();
        }
    }
    resolveSuccess() {
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        if (!this.isAsync) {
            this.setExitCode(StatusCodeMap.get(this.retrieveResult.response.status) ?? 1);
        }
    }
    formatResult() {
        // async result
        if (this.isAsync) {
            let cmdFlags = `--jobid ${this.mdapiRetrieve.id} --retrievetargetdir ${this.retrieveTargetDir}`;
            const targetusernameFlag = this.flags['target-org'];
            if (targetusernameFlag) {
                cmdFlags += ` --targetusername ${targetusernameFlag.getUsername()}`;
            }
            this.log('');
            this.log(messages.getMessage('checkStatus', [cmdFlags]));
            return {
                done: false,
                id: this.mdapiRetrieve.id,
                state: 'Queued',
                status: 'Queued',
                timedOut: true,
            };
        }
        else {
            const formatterOptions = {
                waitTime: this.wait.quantity,
                verbose: this.flags.verbose ?? false,
                retrieveTargetDir: this.retrieveTargetDir,
                zipFileName: this.zipFileName,
                unzip: this.unzip,
            };
            const formatter = new retrieveResultFormatter_1.RetrieveResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), formatterOptions, this.retrieveResult);
            if (!this.jsonEnabled()) {
                formatter.display();
            }
            return formatter.getJson();
        }
    }
    resolveProjectPath() {
        try {
            return core_1.SfProject.getInstance().getDefaultPackage().fullPath;
        }
        catch (error) {
            this.debug('No SFDX project found for default package directory');
        }
    }
    resolveRootDir(rootDir) {
        return rootDir
            ? this.ensureFlagPath({
                flagName: 'sourcedir',
                path: rootDir,
                type: 'dir',
                throwOnENOENT: true,
            })
            : this.resolveProjectPath();
    }
    resolveOutputDir(outputDir) {
        return this.ensureFlagPath({
            flagName: 'retrievetargetdir',
            path: outputDir,
            type: 'dir',
        });
    }
    resolveManifest(manifestPath) {
        if (manifestPath?.length) {
            return this.ensureFlagPath({
                flagName: 'unpackaged',
                path: manifestPath,
                type: 'file',
                throwOnENOENT: true,
            });
        }
    }
}
exports.Retrieve = Retrieve;
Retrieve.state = 'deprecated';
Retrieve.deprecationOptions = {
    to: replacement,
    message: messages.getMessage('deprecation', [replacement]),
};
Retrieve.summary = messages.getMessage('retrieve.summary');
Retrieve.description = messages.getMessage('retrieve.description');
Retrieve.examples = messages.getMessages('retrieve.examples');
Retrieve.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    retrievetargetdir: sf_plugins_core_1.Flags.directory({
        char: 'r',
        summary: messages.getMessage('flags.retrievetargetdir.summary'),
        required: true,
    }),
    unpackaged: sf_plugins_core_1.Flags.file({
        char: 'k',
        summary: messages.getMessage('flags.unpackaged.summary'),
        exclusive: ['sourcedir', 'packagenames'],
    }),
    sourcedir: sf_plugins_core_1.Flags.directory({
        char: 'd',
        summary: messages.getMessage('flags.sourcedir.summary'),
        exclusive: ['unpackaged', 'packagenames'],
    }),
    packagenames: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'p',
        summary: messages.getMessage('flags.packagenames.summary'),
        exclusive: ['sourcedir', 'unpackaged'],
    }),
    singlepackage: sf_plugins_core_1.Flags.boolean({
        char: 's',
        description: messages.getMessage('flags.singlepackage.description'),
        summary: messages.getMessage('flags.singlepackage.summary'),
    }),
    zipfilename: sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.zipfilename.summary'),
    }),
    unzip: sf_plugins_core_1.Flags.boolean({
        char: 'z',
        summary: messages.getMessage('flags.unzip.summary'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        unit: 'minutes',
        summary: messages.getMessage('flags.wait.summary'),
        default: kit_1.Duration.minutes(1440), // 24 hours is a reasonable default versus -1 (no timeout)
    }),
    apiversion: sf_plugins_core_1.Flags.string({
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore force char override for backward compat
        char: 'a',
        description: messages.getMessage('flags.apiversion.description'),
        summary: messages.getMessage('flags.apiversion.summary'),
    }),
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
};
//# sourceMappingURL=retrieve.js.map