"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Retrieve = void 0;
const path_1 = require("path");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const sourceCommand_1 = require("../../../sourceCommand");
const retrieveResultFormatter_1 = require("../../../formatters/retrieveResultFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
const promiseQueue_1 = require("../../../promiseQueue");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'retrieve');
const spinnerMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'spinner');
const retrieveMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'retrieve');
const replacement = 'project retrieve start';
class Retrieve extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['preretrieve', 'postretrieve'];
        this.registry = new source_deploy_retrieve_1.RegistryAccess();
    }
    async run() {
        this.flags = (await this.parse(Retrieve)).flags;
        await this.preChecks();
        await this.retrieve();
        this.resolveSuccess();
        await this.maybeUpdateTracking();
        await this.moveResultsForRetrieveTargetDir();
        return this.formatResult();
    }
    async preChecks() {
        if (this.flags.retrievetargetdir) {
            this.resolvedTargetDir = (0, path_1.resolve)(this.flags.retrievetargetdir);
            if (this.overlapsPackage()) {
                throw messages.createError('retrieveTargetDirOverlapsPackage', [this.flags.retrievetargetdir]);
            }
        }
        // we need something to retrieve
        const retrieveInputs = [this.flags.manifest, this.flags.metadata, this.flags.sourcepath, this.flags.packagenames];
        if (!retrieveInputs.some((x) => x)) {
            throw new core_1.SfError(messages.getMessage('nothingToRetrieve'));
        }
        if (this.flags.tracksource) {
            this.tracking = await (0, trackingFunctions_1.trackingSetup)({
                ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
                org: this.flags['target-org'],
                project: this.project,
                ignoreConflicts: true,
            });
        }
    }
    async retrieve() {
        const username = this.flags['target-org'].getUsername();
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on('apiVersionRetrieve', async (apiData) => {
            this.log(retrieveMessages.getMessage('apiVersionMsgDetailed', [
                'Retrieving',
                apiData.manifestVersion,
                username,
                apiData.apiVersion,
            ]));
        });
        this.spinner.start(spinnerMessages.getMessage('retrieve.componentSetBuild'));
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            apiversion: this.flags.apiversion,
            sourceapiversion: await this.getSourceApiVersion(),
            packagenames: this.flags.packagenames,
            sourcepath: this.flags.sourcepath,
            manifest: this.flags.manifest && {
                manifestPath: this.flags.manifest,
                directoryPaths: this.flags.retrievetargetdir ? [] : this.getPackageDirs(),
            },
            metadata: this.flags.metadata && {
                metadataEntries: this.flags.metadata,
                directoryPaths: this.flags.retrievetargetdir ? [] : this.getPackageDirs(),
            },
        });
        if (this.flags.manifest || this.flags.metadata) {
            if (this.wantsToRetrieveCustomFields()) {
                this.warn(messages.getMessage('wantsToRetrieveCustomFields'));
                this.componentSet.add({
                    fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
                    type: this.registry.getTypeByName('CustomObject'),
                });
            }
        }
        if (this.flags.tracksource) {
            // will throw if conflicts exist
            if (!this.flags.forceoverwrite) {
                await (0, trackingFunctions_1.filterConflictsByComponentSet)({
                    tracking: this.tracking,
                    components: this.componentSet,
                    ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
                });
            }
            const remoteDeletes = await this.tracking.getChanges({
                origin: 'remote',
                state: 'delete',
                format: 'string',
            });
            if (remoteDeletes.length) {
                this.warn(messages.getMessage('retrieveWontDelete'));
            }
        }
        await core_1.Lifecycle.getInstance().emit('preretrieve', this.componentSet.toArray());
        this.spinner.status = spinnerMessages.getMessage('retrieve.sendingRequest');
        const mdapiRetrieve = await this.componentSet.retrieve({
            usernameOrConnection: username,
            merge: true,
            output: this.resolvedTargetDir || this.project.getDefaultPackage().fullPath,
            packageOptions: this.flags.packagenames,
        });
        this.spinner.status = spinnerMessages.getMessage('retrieve.polling');
        this.retrieveResult = await mdapiRetrieve.pollStatus({ timeout: this.flags.wait });
        await core_1.Lifecycle.getInstance().emit('postretrieve', this.retrieveResult.getFileResponses());
        this.spinner.stop();
    }
    resolveSuccess() {
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        this.setExitCode(StatusCodeMap.get(this.retrieveResult.response.status) ?? 1);
    }
    async formatResult() {
        const packages = [];
        const projectPath = await core_1.SfProject.resolveProjectPath();
        (this.flags.packagenames ?? []).forEach((name) => {
            packages.push({ name, path: (0, path_1.join)(projectPath, name) });
        });
        const formatterOptions = {
            waitTime: this.flags.wait.quantity,
            verbose: this.flags.verbose ?? false,
            packages,
        };
        const formatter = new retrieveResultFormatter_1.RetrieveResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), formatterOptions, this.retrieveResult);
        // Only display results to console when JSON flag is unset.
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
    async maybeUpdateTracking() {
        if (this.flags.tracksource ?? false) {
            return (0, trackingFunctions_1.updateTracking)({
                tracking: this.tracking,
                result: this.retrieveResult,
                ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
            });
        }
    }
    wantsToRetrieveCustomFields() {
        const hasCustomField = this.componentSet.has({
            type: this.registry.getTypeByName('CustomField'),
            fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
        });
        const hasCustomObject = this.componentSet.has({
            type: this.registry.getTypeByName('CustomObject'),
            fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
        });
        return hasCustomField && !hasCustomObject;
    }
    async moveResultsForRetrieveTargetDir() {
        async function mv(src) {
            let directories = [];
            let files = [];
            const srcStat = await fs.promises.stat(src);
            if (srcStat.isDirectory()) {
                const contents = await fs.promises.readdir(src, { withFileTypes: true });
                [directories, files] = contents.reduce((acc, dirent) => {
                    if (dirent.isDirectory()) {
                        acc[0].push(dirent.name);
                    }
                    else {
                        acc[1].push(dirent.name);
                    }
                    return acc;
                }, [[], []]);
                directories = directories.map((dir) => (0, path_1.join)(src, dir));
            }
            else {
                files.push(src);
            }
            await (0, promiseQueue_1.promisesQueue)(files, async (file) => {
                const dest = (0, path_1.join)(src.replace((0, path_1.join)('main', 'default'), ''), file);
                const destDir = (0, path_1.dirname)(dest);
                await fs.promises.mkdir(destDir, { recursive: true });
                await fs.promises.rename((0, path_1.join)(src, file), dest);
                return dest;
            }, 50);
            return directories;
        }
        if (!this.flags.retrievetargetdir) {
            return;
        }
        // move contents of 'main/default' to 'retrievetargetdir'
        await (0, promiseQueue_1.promisesQueue)([(0, path_1.join)(this.resolvedTargetDir, 'main', 'default')], mv, 5, true);
        // remove 'main/default'
        await fs.promises.rm((0, path_1.join)(this.flags.retrievetargetdir, 'main'), { recursive: true });
        this.retrieveResult.getFileResponses().forEach((fileResponse) => {
            fileResponse.filePath = fileResponse.filePath?.replace((0, path_1.join)('main', 'default'), '');
        });
    }
    overlapsPackage() {
        return !!this.project.getPackageNameFromPath(this.resolvedTargetDir);
    }
}
exports.Retrieve = Retrieve;
Retrieve.summary = messages.getMessage('summary');
Retrieve.description = messages.getMessage('description');
Retrieve.examples = messages.getMessages('examples');
Retrieve.requiresProject = true;
Retrieve.requiresUsername = true;
Retrieve.state = 'deprecated';
Retrieve.deprecationOptions = {
    to: replacement,
    message: messages.getMessage('deprecation', [replacement]),
};
Retrieve.flags = {
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    retrievetargetdir: sf_plugins_core_1.Flags.directory({
        char: 'r',
        description: messages.getMessage('flags.retrievetargetdir.description'),
        summary: messages.getMessage('flags.retrievetargetdir.summary'),
        exclusive: ['packagenames', 'sourcepath'],
    }),
    apiversion: sf_plugins_core_1.Flags.string({
        /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */
        // @ts-ignore force char override for backward compat
        char: 'a',
    }),
    sourcepath: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'p',
        description: messages.getMessage('flags.sourcePath.description'),
        summary: messages.getMessage('flags.sourcePath.summary'),
        exclusive: ['manifest', 'metadata'],
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        default: kit_1.Duration.minutes(sourceCommand_1.SourceCommand.DEFAULT_WAIT_MINUTES),
        min: 1,
        description: messages.getMessage('flags.wait.description'),
        summary: messages.getMessage('flags.wait.summary'),
    }),
    manifest: sf_plugins_core_1.Flags.file({
        char: 'x',
        description: messages.getMessage('flags.manifest.description'),
        summary: messages.getMessage('flags.manifest.summary'),
        exclusive: ['metadata', 'sourcepath'],
    }),
    metadata: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'm',
        description: messages.getMessage('flags.metadata.description'),
        summary: messages.getMessage('flags.metadata.summary'),
        exclusive: ['manifest', 'sourcepath'],
    }),
    packagenames: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'n',
        summary: messages.getMessage('flags.packagename.summary'),
    }),
    tracksource: sf_plugins_core_1.Flags.boolean({
        char: 't',
        summary: messages.getMessage('flags.tracksource.summary'),
    }),
    forceoverwrite: sf_plugins_core_1.Flags.boolean({
        char: 'f',
        summary: messages.getMessage('flags.forceoverwrite.summary'),
        dependsOn: ['tracksource'],
    }),
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
};
//# sourceMappingURL=retrieve.js.map