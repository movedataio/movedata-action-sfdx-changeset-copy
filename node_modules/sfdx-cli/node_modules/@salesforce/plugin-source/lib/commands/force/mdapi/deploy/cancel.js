"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cancel = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const deployCommand_1 = require("../../../../deployCommand");
const deployCancelResultFormatter_1 = require("../../../../formatters/deployCancelResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.cancel');
const replacement = 'project deploy cancel';
class Cancel extends deployCommand_1.DeployCommand {
    async run() {
        this.flags = (await this.parse(Cancel)).flags;
        this.conn = this.flags['target-org'].getConnection(this.flags['api-version']);
        await this.cancel();
        this.resolveSuccess();
        return this.formatResult();
    }
    async cancel() {
        const deployId = this.resolveDeployId(this.flags.jobid);
        try {
            const deploy = this.createDeploy(this.conn, deployId);
            await deploy.cancel();
            this.deployResult = await this.poll(this.conn, deployId);
        }
        catch (e) {
            const err = e;
            throw new core_1.SfError(messages.getMessage('CancelFailed', [err.message]), 'CancelFailed');
        }
    }
    resolveSuccess() {
        const status = this.deployResult.response.status;
        if (status !== source_deploy_retrieve_1.RequestStatus.Canceled) {
            this.setExitCode(1);
        }
    }
    formatResult() {
        const formatter = new deployCancelResultFormatter_1.DeployCancelResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), this.deployResult);
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.Cancel = Cancel;
Cancel.description = messages.getMessage('description');
Cancel.summary = messages.getMessage('summary');
Cancel.examples = messages.getMessages('examples');
Cancel.state = 'deprecated';
Cancel.deprecationOptions = {
    to: replacement,
    message: messages.getMessage('deprecation', [replacement]),
};
Cancel.flags = {
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        unit: 'minutes',
        default: kit_1.Duration.minutes(deployCommand_1.DeployCommand.DEFAULT_WAIT_MINUTES),
        min: 1,
        description: messages.getMessage('flags.wait.description'),
        summary: messages.getMessage('flags.wait.summary'),
    }),
    jobid: sf_plugins_core_1.Flags.salesforceId({
        char: 'i',
        length: 'both',
        startsWith: '0Af',
        summary: messages.getMessage('flags.jobid.summary'),
    }),
};
//# sourceMappingURL=cancel.js.map