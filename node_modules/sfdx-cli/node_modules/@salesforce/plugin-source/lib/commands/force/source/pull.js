"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const sourceCommand_1 = require("../../../sourceCommand");
const pullFormatter_1 = require("../../../formatters/source/pullFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'pull');
const retrieveMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'retrieve');
const replacement = 'project retrieve start';
class Pull extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['preretrieve', 'postretrieve'];
    }
    async run() {
        this.flags = (await this.parse(Pull)).flags;
        await this.preChecks();
        await this.retrieve();
        // do not parallelize delete and retrieve...we only get to delete IF retrieve was successful
        await this.doDeletes(); // deletes includes its tracking file operations
        await (0, trackingFunctions_1.updateTracking)({
            result: this.retrieveResult,
            ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
            tracking: this.tracking,
        });
        this.spinner.stop();
        return this.formatResult();
    }
    async preChecks() {
        this.spinner.start('Loading source tracking information');
        this.tracking = await (0, trackingFunctions_1.trackingSetup)({
            ignoreConflicts: this.flags.forceoverwrite ?? false,
            org: this.flags['target-org'],
            project: this.project,
            ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
        });
    }
    async doDeletes() {
        this.spinner.status = 'Checking for deletes from the org and updating source tracking files';
        const changesToDelete = await this.tracking.getChanges({
            origin: 'remote',
            state: 'delete',
            format: 'SourceComponent',
        });
        this.deleteFileResponses = await this.tracking.deleteFilesAndUpdateTracking(changesToDelete);
    }
    async retrieve() {
        const componentSet = await this.tracking.remoteNonDeletesAsComponentSet();
        // if it isn't local, add it as a
        if (componentSet.size === 0) {
            return;
        }
        componentSet.sourceApiVersion = await this.getSourceApiVersion();
        if (this.flags['api-version']) {
            componentSet.apiVersion = this.flags['api-version'];
        }
        const username = this.flags['target-org'].getUsername();
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on('apiVersionRetrieve', async (apiData) => {
            this.log(retrieveMessages.getMessage('apiVersionMsgDetailed', [
                'Pulling',
                apiData.manifestVersion,
                username,
                apiData.apiVersion,
            ]));
        });
        const mdapiRetrieve = await componentSet.retrieve({
            usernameOrConnection: username,
            merge: true,
            output: this.project.getDefaultPackage().fullPath,
        });
        this.spinner.status = 'Retrieving metadata from the org';
        // assume: remote deletes that get deleted locally don't fire hooks?
        await core_1.Lifecycle.getInstance().emit('preretrieve', componentSet.toArray());
        this.retrieveResult = await mdapiRetrieve.pollStatus({ timeout: this.flags.wait });
        // Assume: remote deletes that get deleted locally don't fire hooks.
        await core_1.Lifecycle.getInstance().emit('postretrieve', this.retrieveResult.getFileResponses());
    }
    resolveSuccess() {
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        // there might not be a retrieveResult if we don't have anything to retrieve
        if (this.retrieveResult?.response.status) {
            this.setExitCode(StatusCodeMap.get(this.retrieveResult.response.status) ?? 1);
        }
    }
    formatResult() {
        const formatter = new pullFormatter_1.PullResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), { verbose: this.flags.verbose ?? false }, this.retrieveResult, this.deleteFileResponses);
        // Only display results to console when JSON flag is unset.
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.default = Pull;
Pull.state = 'deprecated';
Pull.deprecationOptions = {
    to: replacement,
    message: messages.getMessage('deprecation', [replacement]),
};
Pull.description = messages.getMessage('description');
Pull.summary = messages.getMessage('summary');
Pull.examples = messages.getMessages('examples');
Pull.flags = {
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    forceoverwrite: sf_plugins_core_1.Flags.boolean({
        char: 'f',
        summary: messages.getMessage('flags.forceoverwrite.summary'),
    }),
    // TODO: use shared flags from plugin-source
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        default: kit_1.Duration.minutes(33),
        min: 0,
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
    }),
};
Pull.requiresProject = true;
//# sourceMappingURL=pull.js.map