"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const ts_types_1 = require("@salesforce/ts-types");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const deployCommand_1 = require("../../../deployCommand");
const pushResultFormatter_1 = require("../../../formatters/source/pushResultFormatter");
const deployProgressBarFormatter_1 = require("../../../formatters/deployProgressBarFormatter");
const deployProgressStatusFormatter_1 = require("../../../formatters/deployProgressStatusFormatter");
const trackingFunctions_1 = require("../../../trackingFunctions");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'push');
const deployMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'deployCommand');
const replacement = 'project deploy start';
class Push extends deployCommand_1.DeployCommand {
    constructor() {
        super(...arguments);
        this.lifecycleEventNames = ['predeploy', 'postdeploy'];
        this.deployResults = [];
    }
    async run() {
        this.flags = (await this.parse(Push)).flags;
        await this.prechecks();
        await this.deploy();
        this.resolveSuccess();
        await this.updateTracking();
        return this.formatResult();
    }
    async prechecks() {
        this.tracking = await (0, trackingFunctions_1.trackingSetup)({
            ignoreConflicts: this.flags.forceoverwrite ?? false,
            org: this.flags['target-org'],
            project: this.project,
            ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
        });
        // we need these later to show deletes in results
        this.deletes = await this.tracking.getChanges({ origin: 'local', state: 'delete', format: 'string' });
    }
    async deploy() {
        const username = this.flags['target-org'].getUsername();
        const isSequentialDeploy = (0, ts_types_1.getBoolean)(await this.project.resolveProjectConfig(), 'pushPackageDirectoriesSequentially', false);
        const [componentSets, sourceApiVersion, isRest] = await Promise.all([
            this.tracking.localChangesAsComponentSet(isSequentialDeploy),
            this.getSourceApiVersion(),
            this.isRestDeploy(),
        ]);
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on('apiVersionDeploy', async (apiData) => {
            this.log(deployMessages.getMessage('apiVersionMsgDetailed', [
                'Pushing',
                apiData.manifestVersion,
                username,
                apiData.apiVersion,
                apiData.webService,
            ]));
        });
        for (const componentSet of componentSets) {
            // intentionally to do this sequentially if there are multiple component sets
            /* eslint-disable no-await-in-loop */
            if (sourceApiVersion) {
                componentSet.sourceApiVersion = sourceApiVersion;
            }
            // there might have been components in local tracking, but they might be ignored by SDR or unresolvable.
            // SDR will throw when you try to resolve them, so don't
            if (componentSet.size === 0) {
                this.warn('There are no changes to deploy');
                continue;
            }
            // fire predeploy event for sync and async deploys
            await core_1.Lifecycle.getInstance().emit('predeploy', componentSet.toArray());
            const deploy = await componentSet.deploy({
                usernameOrConnection: username,
                apiOptions: {
                    ignoreWarnings: this.flags.ignorewarnings ?? false,
                    rest: isRest,
                    testLevel: 'NoTestRun',
                },
            });
            // we're not print JSON output
            if (!this.jsonEnabled()) {
                const progressFormatter = kit_1.env.getBoolean('SFDX_USE_PROGRESS_BAR', true)
                    ? new deployProgressBarFormatter_1.DeployProgressBarFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }))
                    : new deployProgressStatusFormatter_1.DeployProgressStatusFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }));
                progressFormatter.progress(deploy);
            }
            const result = await deploy.pollStatus({ timeout: this.flags.wait });
            if (result) {
                // Only fire the postdeploy event when we have results. I.e., not async.
                await core_1.Lifecycle.getInstance().emit('postdeploy', result);
                this.deployResults.push(result);
                if (result.response.status !== source_deploy_retrieve_1.RequestStatus.Succeeded &&
                    isSequentialDeploy &&
                    this.project.hasMultiplePackages()) {
                    this.log(messages.getMessage('sequentialFail'));
                    break;
                }
            }
            /* eslint-enable no-await-in-loop */
        }
    }
    async updateTracking() {
        // there can be multiple deploy results for sequential deploys
        if (process.exitCode !== 0 || !this.deployResults.length) {
            return;
        }
        await (0, trackingFunctions_1.updateTracking)({
            ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
            result: this.deployResults[0],
            tracking: this.tracking,
            // since we're going to poll source members, we want them all in one transaction
            fileResponses: this.deployResults.flatMap((result) => result.getFileResponses()),
        });
    }
    resolveSuccess() {
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        // there might be no results if we exited early (ex: nothing to push)
        if (!this.deployResults.length) {
            return this.setExitCode(0);
        }
        // any incomplete means incomplete
        if (this.deployResults.some((result) => StatusCodeMap.get(result.response.status) === 69)) {
            return this.setExitCode(69);
        }
        const isSuccessLike = (result) => result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded ||
            // successful-ish  (only warnings about deleted things that are already deleted)
            (result.response.status === source_deploy_retrieve_1.RequestStatus.Failed &&
                result.getFileResponses().every((fr) => fr.state !== 'Failed') &&
                !result.response.errorMessage);
        // all successes
        if (this.deployResults.every((result) => isSuccessLike(result))) {
            return this.setExitCode(0);
        }
        // 1 and 0 === 68 "partial success"
        if (this.deployResults.some((result) => isSuccessLike(result)) &&
            this.deployResults.some((result) => StatusCodeMap.get(result.response.status) === 1)) {
            return this.setExitCode(68);
        }
        // all fails
        if (this.deployResults.every((result) => StatusCodeMap.get(result.response.status) === 1)) {
            return this.setExitCode(1);
        }
        this.warn(` Unexpected exit code ${this.deployResults.map((result) => result.response.errorMessage).join(', ')}`);
        this.setExitCode(1);
    }
    catch(error) {
        const formatter = new pushResultFormatter_1.PushResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), {
            quiet: this.flags.quiet ?? false,
        }, this.deployResults, this.deletes);
        try {
            formatter.getJson();
        }
        catch (e) {
            if (this.jsonEnabled()) {
                const err = this.toErrorJson(e);
                // restore json format
                err.message = 'Push Failed.';
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
                err.stack = e.stack;
                err.context = 'Push';
                err.status = 1;
                this.logJson(err);
            }
        }
        throw error;
    }
    formatResult() {
        if (!this.deployResults.length) {
            this.log('No results found');
        }
        const formatterOptions = {
            quiet: this.flags.quiet ?? false,
        };
        const formatter = new pushResultFormatter_1.PushResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), formatterOptions, this.deployResults, this.deletes);
        // Only display results to console when JSON flag is unset.
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.default = Push;
Push.state = 'deprecated';
Push.deprecationOptions = {
    to: replacement,
    message: messages.getMessage('deprecation', [replacement]),
};
Push.description = messages.getMessage('description');
Push.summary = messages.getMessage('summary');
Push.examples = messages.getMessages('examples');
Push.requiresProject = true;
Push.flags = {
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    forceoverwrite: sf_plugins_core_1.Flags.boolean({
        char: 'f',
        summary: messages.getMessage('flags.forceoverwrite.summary'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        default: kit_1.Duration.minutes(deployCommand_1.DeployCommand.DEFAULT_WAIT_MINUTES),
        min: 1,
        description: messages.getMessage('flags.wait.description'),
        summary: messages.getMessage('flags.wait.summary'),
    }),
    ignorewarnings: sf_plugins_core_1.Flags.boolean({
        char: 'g',
        summary: messages.getMessage('flags.ignorewarnings.summary'),
    }),
    quiet: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.quiet.summary'),
    }),
};
//# sourceMappingURL=push.js.map