"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Report = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const sourceCommand_1 = require("../../../../sourceCommand");
const stash_1 = require("../../../../stash");
const retrieveResultFormatter_1 = require("../../../../formatters/mdapi/retrieveResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'md.retrieve');
const spinnerMessages = core_1.Messages.loadMessages('@salesforce/plugin-source', 'spinner');
class Report extends sourceCommand_1.SourceCommand {
    async run() {
        this.flags = (await this.parse(Report)).flags;
        this.org = this.flags['target-org'];
        await this.report();
        this.resolveSuccess();
        return this.formatResult();
    }
    async report() {
        let retrieveId = this.flags.jobid;
        if (!retrieveId) {
            // Get stashed retrieve data
            const mdRetrieveStash = stash_1.Stash.get('MDAPI_RETRIEVE');
            // throw if no Retrieve ID in stash either
            if (!mdRetrieveStash?.jobid) {
                throw new core_1.SfError(messages.getMessage('MissingRetrieveId'), 'MissingRetrieveId');
            }
            retrieveId = mdRetrieveStash.jobid;
            this.retrieveTargetDir = this.resolveOutputDir(mdRetrieveStash?.retrievetargetdir);
            this.zipFileName = (0, sourceCommand_1.resolveZipFileName)(mdRetrieveStash?.zipfilename);
            this.unzip = mdRetrieveStash?.unzip;
        }
        else {
            this.retrieveTargetDir = this.resolveOutputDir(this.flags.retrievetargetdir);
            this.zipFileName = (0, sourceCommand_1.resolveZipFileName)(this.flags.zipfilename);
            this.unzip = this.flags.unzip;
        }
        const waitFlag = this.flags.wait;
        this.wait = waitFlag.minutes === -1 ? kit_1.Duration.days(7) : waitFlag;
        this.isAsync = this.wait.quantity === 0;
        this.spinner.start(spinnerMessages.getMessage('retrieve.main', [this.org.getUsername()]));
        this.mdapiRetrieve = new source_deploy_retrieve_1.MetadataApiRetrieve({
            id: retrieveId,
            usernameOrConnection: this.org.getUsername(),
            output: this.retrieveTargetDir,
            format: 'metadata',
            zipFileName: this.zipFileName,
            unzip: this.unzip,
        });
        if (this.isAsync) {
            // For async reports (wait == 0) we just check the status and call post()
            // to write the zip file if it's done.
            this.retrieveStatus = await this.mdapiRetrieve.checkStatus();
            if (this.retrieveStatus.done) {
                this.retrieveResult = await this.mdapiRetrieve.post(this.retrieveStatus);
            }
        }
        else {
            this.spinner.status = spinnerMessages.getMessage('retrieve.polling');
            this.retrieveResult = await this.mdapiRetrieve.pollStatus(1000, this.wait.seconds);
        }
        this.spinner.stop();
    }
    // No-op implementation since any RetrieveResult status would be a success.
    // The only time this command would report an error is if it failed
    // flag parsing or some error during the request, and those are captured
    // by the command framework.
    /* eslint-disable-next-line @typescript-eslint/no-empty-function, class-methods-use-this */
    resolveSuccess() { }
    formatResult() {
        if (this.isAsync && !this.retrieveResult) {
            this.log('');
            this.log(`Retrieve Status: ${this.retrieveStatus.status}`);
            return {
                done: this.retrieveStatus.done,
                id: this.retrieveStatus.id,
                state: this.retrieveStatus.status,
                status: this.retrieveStatus.status,
                timedOut: true,
            };
        }
        const formatterOptions = {
            waitTime: this.wait.quantity,
            verbose: this.flags.verbose ?? false,
            retrieveTargetDir: this.retrieveTargetDir,
            zipFileName: this.zipFileName,
            unzip: this.unzip,
        };
        const formatter = new retrieveResultFormatter_1.RetrieveResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), formatterOptions, this.retrieveResult);
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
    resolveOutputDir(dirPath) {
        return this.ensureFlagPath({
            flagName: 'retrievetargetdir',
            path: dirPath,
            type: 'dir',
        });
    }
}
exports.Report = Report;
Report.summary = messages.getMessage('report.summary');
Report.description = messages.getMessage('report.description');
Report.examples = messages.getMessages('report.examples');
Report.state = 'deprecated';
Report.flags = {
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    // NOTE: this flag is not required because the value is stashed
    // from the force:mdapi:retrieve command.
    retrievetargetdir: sf_plugins_core_1.Flags.directory({
        char: 'r',
        summary: messages.getMessage('flags.retrievetargetdir.summary'),
    }),
    jobid: sf_plugins_core_1.Flags.salesforceId({
        char: 'i',
        description: messages.getMessage('flags.jobid.description'),
        summary: messages.getMessage('flags.jobid.summary'),
    }),
    zipfilename: sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.zipfilename.summary'),
    }),
    unzip: sf_plugins_core_1.Flags.boolean({
        char: 'z',
        summary: messages.getMessage('flags.unzip.summary'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        unit: 'minutes',
        summary: messages.getMessage('flags.wait.summary'),
        min: -1,
        default: kit_1.Duration.minutes(1440),
        defaultValue: 1440, // 24 hours is a reasonable default versus -1 (no timeout)
    }),
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
};
//# sourceMappingURL=report.js.map