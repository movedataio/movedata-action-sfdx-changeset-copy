"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployResultFormatter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const path = require("path");
const fs = require("fs");
const core_1 = require("@oclif/core");
const chalk_1 = require("chalk");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_2 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const apex_node_1 = require("@salesforce/apex-node");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const types_1 = require("../utils/types");
const coverage_1 = require("../utils/coverage");
const output_1 = require("../utils/output");
class DeployResultFormatter {
    constructor(result, flags) {
        this.result = result;
        this.flags = flags;
        this.absoluteFiles = (0, output_1.sortFileResponses)(this.result.getFileResponses() ?? []);
        this.relativeFiles = (0, output_1.asRelativePaths)(this.absoluteFiles);
        this.testLevel = this.flags['test-level'] ?? types_1.TestLevel.NoTestRun;
        this.verbosity = this.determineVerbosity();
        this.resultsDir = this.flags['results-dir'] ?? 'coverage';
        this.coverageOptions = (0, coverage_1.getCoverageFormattersOptions)(this.flags['coverage-formatters']);
        this.junit = this.flags.junit;
    }
    getJson() {
        if (this.verbosity === 'concise') {
            return {
                ...this.result.response,
                details: {
                    componentFailures: this.result.response.details.componentFailures,
                    runTestResult: this.result.response.details.runTestResult,
                },
                files: this.absoluteFiles.filter((f) => f.state === 'Failed'),
            };
        }
        else {
            return {
                ...this.result.response,
                files: this.absoluteFiles,
                ...(this.result.replacements.size
                    ? {
                        replacements: Object.fromEntries(this.result.replacements),
                    }
                    : {}),
            };
        }
    }
    display() {
        if (this.verbosity !== 'concise') {
            this.displaySuccesses();
        }
        this.displayFailures();
        this.displayDeletes();
        this.displayTestResults();
        this.maybeCreateRequestedReports();
        this.displayReplacements();
    }
    maybeCreateRequestedReports() {
        // only generate reports if test results are presented
        if (this.result.response?.numberTestsTotal) {
            if (this.coverageOptions.reportFormats?.length) {
                core_1.ux.log(`Code Coverage formats, [${this.flags['coverage-formatters']?.join(', ')}], written to ${this.resultsDir}/`);
                this.createCoverageReport('no-map');
            }
            if (this.junit) {
                core_1.ux.log(`Junit results written to ${this.resultsDir}/junit/junit.xml`);
                this.createJunitResults();
            }
        }
    }
    createJunitResults() {
        const testResult = this.transformDeployTestsResultsToTestResult();
        if (testResult.summary.testsRan > 0) {
            const jUnitReporter = new apex_node_1.JUnitReporter();
            const junitResults = jUnitReporter.format(testResult);
            const junitReportPath = path.join(this.resultsDir ?? '', 'junit');
            fs.mkdirSync(junitReportPath, { recursive: true });
            fs.writeFileSync(path.join(junitReportPath, 'junit.xml'), junitResults, 'utf8');
        }
    }
    transformDeployTestsResultsToTestResult() {
        if (!this.result.response?.details?.runTestResult) {
            throw new core_2.SfError('No test results found');
        }
        const runTestResult = this.result.response?.details?.runTestResult;
        const numTestsRun = parseInt(runTestResult.numTestsRun, 10);
        const numTestFailures = parseInt(runTestResult.numFailures, 10);
        return {
            summary: {
                commandTimeInMs: 0,
                failRate: ((numTestFailures / numTestsRun) * 100).toFixed(2) + '%',
                failing: numTestFailures,
                hostname: this.flags['target-org']?.getConnection().getConnectionOptions().instanceUrl,
                orgId: this.flags['target-org']?.getConnection().getAuthInfoFields().orgId,
                outcome: '',
                passRate: numTestFailures === 0 ? '100%' : ((1 - numTestFailures / numTestsRun) * 100).toFixed(2) + '%',
                passing: numTestsRun - numTestFailures,
                skipRate: '',
                skipped: 0,
                testExecutionTimeInMs: parseFloat(runTestResult.totalTime),
                testRunId: '',
                testStartTime: new Date().toISOString(),
                testTotalTimeInMs: parseFloat(runTestResult.totalTime),
                testsRan: numTestsRun,
                userId: this.flags['target-org']?.getConnection().getConnectionOptions().userId,
                username: this.flags['target-org']?.getConnection().getUsername(),
            },
            tests: [
                ...(0, coverage_1.mapTestResults)((0, kit_1.ensureArray)(runTestResult.successes)),
                ...(0, coverage_1.mapTestResults)((0, kit_1.ensureArray)(runTestResult.failures)),
            ],
            codecoverage: (0, kit_1.ensureArray)(runTestResult?.codeCoverage).map((cov) => {
                const numLinesUncovered = parseInt(cov.numLocationsNotCovered, 10);
                const [uncoveredLines, coveredLines] = (0, coverage_1.generateCoveredLines)(cov);
                const numLocationsNum = parseInt(cov.numLocations, 10);
                const numLocationsNotCovered = parseInt(cov.numLocationsNotCovered, 10);
                return {
                    // TODO: fix this type in SDR?
                    type: cov.type,
                    apexId: cov.id,
                    name: cov.name,
                    numLinesUncovered,
                    numLinesCovered: parseInt(cov.numLocations, 10) - numLinesUncovered,
                    coveredLines,
                    uncoveredLines,
                    percentage: numLocationsNum > 0
                        ? (((numLocationsNum - numLocationsNotCovered) / numLocationsNum) * 100).toFixed() + '%'
                        : '',
                };
            }),
        };
    }
    createCoverageReport(sourceDir) {
        if (this.resultsDir) {
            const apexCoverage = (0, coverage_1.transformCoverageToApexCoverage)((0, kit_1.ensureArray)(this.result.response?.details?.runTestResult?.codeCoverage));
            fs.mkdirSync(this.resultsDir, { recursive: true });
            const coverageReport = new apex_node_1.CoverageReporter(apexCoverage, this.resultsDir, sourceDir, this.coverageOptions);
            coverageReport.generateReports();
        }
    }
    displayReplacements() {
        if (this.verbosity === 'verbose' && this.result.replacements?.size) {
            const replacements = Array.from(this.result.replacements.entries()).flatMap(([filepath, stringsReplaced]) => stringsReplaced.map((replaced) => ({
                filePath: path.relative(process.cwd(), filepath),
                replaced,
            })));
            core_1.ux.table(replacements, {
                filePath: { header: 'PROJECT PATH' },
                replaced: { header: 'TEXT REPLACED' },
            }, {
                title: (0, output_1.tableHeader)('Metadata Replacements'),
            });
        }
    }
    displaySuccesses() {
        const successes = this.relativeFiles.filter((f) => f.state !== 'Failed');
        if (!successes.length || this.result.response.status === source_deploy_retrieve_1.RequestStatus.Failed)
            return;
        const columns = {
            state: { header: 'State' },
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const title = this.result.response.checkOnly ? 'Validated Source' : 'Deployed Source';
        const options = { title: (0, output_1.tableHeader)(title) };
        core_1.ux.log();
        core_1.ux.table(successes.map((s) => ({ filePath: s.filePath, fullName: s.fullName, type: s.type, state: s.state })), columns, options);
    }
    displayFailures() {
        if (this.result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded)
            return;
        const failures = this.relativeFiles.filter(types_1.isSdrFailure);
        if (!failures.length)
            return;
        const columns = {
            problemType: { header: 'Type' },
            fullName: { header: 'Name' },
            error: { header: 'Problem' },
        };
        const options = { title: error(`Component Failures [${failures.length}]`) };
        core_1.ux.log();
        core_1.ux.table(failures.map((f) => ({ problemType: f.problemType, fullName: f.fullName, error: f.error })), columns, options);
    }
    displayDeletes() {
        const deletions = this.relativeFiles.filter(types_1.isSdrSuccess).filter((f) => f.state === 'Deleted');
        if (!deletions.length)
            return;
        const columns = {
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const options = { title: (0, output_1.tableHeader)('Deleted Source') };
        core_1.ux.log();
        core_1.ux.table((0, output_1.getFileResponseSuccessProps)(deletions), columns, options);
    }
    displayTestResults() {
        if (this.testLevel === types_1.TestLevel.NoTestRun) {
            core_1.ux.log();
            return;
        }
        this.displayVerboseTestFailures();
        if (this.verbosity === 'verbose') {
            this.displayVerboseTestSuccesses();
            this.displayVerboseTestCoverage();
        }
        core_1.ux.log();
        core_1.ux.log((0, output_1.tableHeader)('Test Results Summary'));
        const passing = this.result.response.numberTestsCompleted ?? 0;
        const failing = this.result.response.numberTestErrors ?? 0;
        const total = this.result.response.numberTestsTotal ?? 0;
        const time = this.result.response.details.runTestResult?.totalTime ?? 0;
        core_1.ux.log(`Passing: ${passing}`);
        core_1.ux.log(`Failing: ${failing}`);
        core_1.ux.log(`Total: ${total}`);
        if (time)
            core_1.ux.log(`Time: ${time}`);
    }
    displayVerboseTestSuccesses() {
        const successes = (0, kit_1.ensureArray)(this.result.response.details.runTestResult?.successes);
        if (successes.length > 0) {
            const testSuccesses = sortTestResults(successes);
            core_1.ux.log();
            core_1.ux.log(success(`Test Success [${successes.length}]`));
            for (const test of testSuccesses) {
                const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
                core_1.ux.log(`${check} ${testName}`);
            }
        }
    }
    displayVerboseTestFailures() {
        if (!this.result.response.numberTestErrors)
            return;
        const failures = (0, kit_1.ensureArray)(this.result.response.details.runTestResult?.failures);
        const failureCount = this.result.response.details.runTestResult?.numFailures;
        const testFailures = sortTestResults(failures);
        core_1.ux.log();
        core_1.ux.log(error(`Test Failures [${failureCount}]`));
        for (const test of testFailures) {
            const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
            const stackTrace = test.stackTrace.replace(/\n/g, `${os.EOL}    `);
            core_1.ux.log(`• ${testName}`);
            core_1.ux.log(`  ${(0, chalk_1.dim)('message')}: ${test.message}`);
            core_1.ux.log(`  ${(0, chalk_1.dim)('stacktrace')}: ${os.EOL}    ${stackTrace}`);
            core_1.ux.log();
        }
    }
    displayVerboseTestCoverage() {
        const codeCoverage = (0, kit_1.ensureArray)(this.result.response.details.runTestResult?.codeCoverage);
        if (codeCoverage.length) {
            const coverage = codeCoverage.sort((a, b) => (a.name.toUpperCase() > b.name.toUpperCase() ? 1 : -1));
            core_1.ux.log();
            core_1.ux.log((0, output_1.tableHeader)('Apex Code Coverage'));
            core_1.ux.table(coverage.map(coverage_1.coverageOutput), {
                name: { header: 'Name' },
                numLocations: { header: '% Covered' },
                lineNotCovered: { header: 'Uncovered Lines' },
            });
        }
    }
    determineVerbosity() {
        if (this.flags.verbose)
            return 'verbose';
        if (this.flags.concise)
            return 'concise';
        return 'normal';
    }
}
exports.DeployResultFormatter = DeployResultFormatter;
function sortTestResults(results) {
    return results.sort((a, b) => {
        if (a.methodName === b.methodName) {
            return a.name.localeCompare(b.name);
        }
        return a.methodName.localeCompare(b.methodName);
    });
}
function error(message) {
    return sf_plugins_core_1.StandardColors.error((0, chalk_1.bold)(message));
}
function success(message) {
    return sf_plugins_core_1.StandardColors.success((0, chalk_1.bold)(message));
}
const check = sf_plugins_core_1.StandardColors.success('✓');
//# sourceMappingURL=deployResultFormatter.js.map