"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConflictFiles = exports.printTables = exports.printIgnoredTable = exports.compileResults = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const core_1 = require("@oclif/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const chalk_1 = require("chalk");
const core_2 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const filePathGenerator_1 = require("@salesforce/source-deploy-retrieve/lib/src/utils/filePathGenerator");
const types_1 = require("./types");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'previewMessages');
const ensureAbsolutePath = (f) => (path.isAbsolute(f) ? f : path.resolve(f));
// borrowed from STL populateFilesPaths.
// TODO: this goes in SDR maybe?
const resolvePaths = (filenames) => {
    // component set generated from the filenames on all local changes
    const resolver = new source_deploy_retrieve_1.MetadataResolver(undefined, source_deploy_retrieve_1.VirtualTreeContainer.fromFilePaths(filenames), false);
    const sourceComponents = filenames
        .flatMap((filename) => {
        try {
            return resolver.getComponentsFromPath(filename);
        }
        catch (e) {
            // resolver will do logging before throw we don't do it here
            return undefined;
        }
    })
        .filter(types_1.isSourceComponent)
        .map((sc) => ({ fullName: sc.fullName, type: sc.type.name, path: ensureAbsolutePath(sc.xml) }));
    // dedupe by xml path
    return Array.from(new Map(sourceComponents.map((sc) => [sc.path, sc])).values());
};
const calculateDeployOperation = (destructiveChangesType) => {
    switch (destructiveChangesType) {
        case source_deploy_retrieve_1.DestructiveChangesType.POST:
            return 'deletePost';
        case source_deploy_retrieve_1.DestructiveChangesType.PRE:
            return 'deletePre';
        default:
            return 'deploy';
    }
};
const getNonIgnoredConflicts = (files) => files.filter((f) => f.conflict && !f.ignored);
const willGo = (previewFile) => !previewFile.conflict && !previewFile.ignored;
const getWillDeploy = (files) => files.filter((f) => willGo(f) && f.operation === 'deploy');
const getWillRetrieve = (files) => files.filter((f) => willGo(f) && f.operation === 'retrieve');
const getWillDelete = (files) => files.filter((f) => willGo(f) && f.operation && ['deletePre', 'deletePost'].includes(f.operation));
// relative paths are easier on tables
const columns = { type: {}, fullName: {}, projectRelativePath: { header: 'Path' } };
const makeKey = ({ type, fullName }) => `${type.name}#${fullName}`;
const compileResults = ({ componentSet, projectPath, filesWithConflicts, forceIgnore, baseOperation, remoteDeletes, }) => {
    // when we iterate all the componentSet,
    // this map makes it easy to get the source-backed local components
    const sourceBackedComponents = new Map(componentSet.getSourceComponents().map((sc) => [makeKey({ type: sc.type, fullName: sc.fullName }), sc]));
    const sourceComponentToPreviewFile = (c) => ({
        type: c.type.name,
        fullName: c.fullName,
        conflict: [c.xml, c.content].some((v) => v && filesWithConflicts.has(v)),
        // There should not be anything in forceignore returned by the componentSet
        ignored: [c.xml, c.content].some((v) => v && forceIgnore.denies(v)),
        // properties to return if we have an xml path
        ...getPaths(c),
    });
    /** resolve absolute and relative paths for a source component, with a preference for the xml file, but able to use the content file as backup */
    const getPaths = (c) => {
        const someFile = c.xml ?? c.content;
        if (someFile) {
            return {
                path: path.isAbsolute(someFile) ? someFile : path.resolve(someFile),
                // for cleaner output
                projectRelativePath: path.relative(projectPath, someFile),
            };
        }
        return {};
    };
    const actionableFiles = componentSet
        .filter((f) => f.fullName !== '*')
        .toArray()
        .map((c) => sourceBackedComponents.get(makeKey(c)) ?? c)
        .map((cmp) => {
        const maybeSourceBackedComponent = sourceBackedComponents.get(makeKey(cmp)) ?? cmp;
        if ('xml' in maybeSourceBackedComponent) {
            // source backed components exist locally
            return {
                ...sourceComponentToPreviewFile(maybeSourceBackedComponent),
                operation: baseOperation === 'deploy'
                    ? calculateDeployOperation(maybeSourceBackedComponent.getDestructiveChangesType())
                    : baseOperation,
            };
        }
        else {
            return {
                type: maybeSourceBackedComponent.type.name,
                fullName: maybeSourceBackedComponent.fullName,
                // if it doesn't exist locally, it can't be a conflict
                conflict: false,
                operation: baseOperation,
                // we have to calculate the "potential filename" to know if a remote retrieve would be ignored
                ignored: (0, filePathGenerator_1.filePathsFromMetadataComponent)(maybeSourceBackedComponent).some((p) => forceIgnore.denies(p)),
            };
        }
    })
        // remote deletes are not in the componentSet
        .concat((remoteDeletes ?? []).map((c) => ({
        ...sourceComponentToPreviewFile(c),
        operation: 'deletePre',
    })));
    // Source backed components won't appear in the ComponentSet if ignored
    const ignoredSourceComponents = resolvePaths([...(componentSet.forceIgnoredPaths ?? [])]).map((resolved) => ({
        ...resolved,
        ...(resolved.path ? { projectRelativePath: path.relative(projectPath, resolved.path) } : {}),
        conflict: false,
        ignored: true,
    }));
    return {
        ignored: ignoredSourceComponents.concat(actionableFiles.filter((f) => f.ignored)),
        toDeploy: getWillDeploy(actionableFiles),
        toRetrieve: getWillRetrieve(actionableFiles),
        toDelete: getWillDelete(actionableFiles),
        conflicts: getNonIgnoredConflicts(actionableFiles),
    };
};
exports.compileResults = compileResults;
const printDeployTable = (files) => {
    core_1.ux.log();
    if (files.length === 0) {
        core_1.ux.log((0, chalk_1.dim)(messages.getMessage('deploy.none')));
    }
    else {
        // not using table title property to avoid all the ASCII art
        core_1.ux.log(sf_plugins_core_1.StandardColors.success((0, chalk_1.bold)(messages.getMessage('deploy.header', [files.length]))));
        core_1.ux.table(files, columns);
    }
};
const printRetrieveTable = (files) => {
    core_1.ux.log();
    if (files.length === 0) {
        core_1.ux.log((0, chalk_1.dim)(messages.getMessage('retrieve.none')));
    }
    else {
        // not using table title property to avoid all the ASCII art
        core_1.ux.log(sf_plugins_core_1.StandardColors.success((0, chalk_1.bold)(messages.getMessage('retrieve.header', [files.length]))));
        core_1.ux.table(files, columns);
    }
};
const printDeleteTable = (files) => {
    core_1.ux.log();
    if (files.length === 0) {
        core_1.ux.log((0, chalk_1.dim)(messages.getMessage('delete.none')));
    }
    else {
        core_1.ux.log(sf_plugins_core_1.StandardColors.warning((0, chalk_1.bold)(messages.getMessage('delete.header', [files.length]))));
        core_1.ux.table(files, columns);
    }
};
const printConflictsTable = (files) => {
    core_1.ux.log();
    if (files.length === 0) {
        core_1.ux.log((0, chalk_1.dim)(messages.getMessage('conflicts.none')));
    }
    else {
        core_1.ux.log(sf_plugins_core_1.StandardColors.error((0, chalk_1.bold)(messages.getMessage('conflicts.header', [files.length]))));
        core_1.ux.table(files, columns, { sort: 'path' });
    }
};
const printIgnoredTable = (files, baseOperation) => {
    core_1.ux.log();
    if (files.length === 0) {
        core_1.ux.log((0, chalk_1.dim)(messages.getMessage('ignored.none')));
    }
    else {
        core_1.ux.log((0, chalk_1.dim)(messages.getMessage('ignored.header', [files.length, baseOperation])));
        core_1.ux.table(files, columns, { sort: 'path' });
    }
};
exports.printIgnoredTable = printIgnoredTable;
const printTables = (result, baseOperation) => {
    printConflictsTable(result.conflicts);
    printDeleteTable(result.toDelete);
    if (baseOperation === 'deploy') {
        printDeployTable(result.toDeploy);
    }
    else if (baseOperation === 'retrieve') {
        printRetrieveTable(result.toRetrieve);
    }
    (0, exports.printIgnoredTable)(result.ignored, baseOperation);
};
exports.printTables = printTables;
const getConflictFiles = async (stl, ignore = false) => !stl || ignore
    ? new Set()
    : new Set((await stl.getConflicts()).flatMap((conflict) => (conflict.filenames ?? []).map((f) => path.resolve(f))));
exports.getConflictFiles = getConflictFiles;
//# sourceMappingURL=previewOutput.js.map