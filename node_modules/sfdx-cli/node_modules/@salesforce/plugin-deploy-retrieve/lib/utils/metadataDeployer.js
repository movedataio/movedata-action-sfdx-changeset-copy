"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable class-methods-use-this */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataDeployer = exports.DeployablePackage = void 0;
const os_1 = require("os");
const chalk_1 = require("chalk");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const deployResultFormatter_1 = require("../formatters/deployResultFormatter");
const types_1 = require("./types");
const progressBar_1 = require("./progressBar");
const deploy_1 = require("./deploy");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'deploy');
const compareOrgs = (a, b) => {
    // scratch orgs before other orgs
    if (a.isScratchOrg && !b.isScratchOrg) {
        // all scratch orgs come before non-scratch orgs
        return -1;
    }
    else {
        // sort scratch orgs by timestamp - descending
        if (a.isScratchOrg && b.isScratchOrg) {
            const aTimestamp = new Date(a.timestamp);
            const bTimestamp = new Date(b.timestamp);
            return bTimestamp.getTime() - aTimestamp.getTime();
        }
        // dev hubs after scratch but before remaining orgs
        if (a.isDevHub && !b.isScratchOrg && !b.isDevHub) {
            return -1;
        }
        // not a scratch org and not a devhub means "other" sorts last
        if (!a.isDevHub) {
            return 1;
        }
    }
    // orgs are equal by type - sort by name ascending
    return a.username.localeCompare(b.username);
};
class DeployablePackage extends sf_plugins_core_1.Deployable {
    constructor(pkg, parent) {
        super();
        this.pkg = pkg;
        this.parent = parent;
    }
    getName() {
        return this.pkg.name;
    }
    getType() {
        return 'Salesforce App';
    }
    getPath() {
        return this.pkg.path;
    }
    getParent() {
        return this.parent;
    }
}
exports.DeployablePackage = DeployablePackage;
class MetadataDeployer extends sf_plugins_core_1.Deployer {
    constructor(packages) {
        super();
        this.packages = packages;
        this.testLevel = types_1.TestLevel.NoTestRun;
        this.deployables = this.packages.map((pkg) => new DeployablePackage(pkg, this));
    }
    getName() {
        return MetadataDeployer.NAME;
    }
    async setup(flags, options) {
        if (flags.interactive) {
            this.testLevel = await this.promptForTestLevel();
            this.username = await this.promptForUsername();
        }
        else {
            if (options.directories?.length) {
                const directories = options.directories || [];
                const selected = this.deployables.filter((d) => directories.includes(d.getPath()));
                this.selectDeployables(selected);
            }
            this.testLevel = options.testLevel ?? (await this.promptForTestLevel());
            this.username = options.username ?? (await this.promptForUsername());
        }
        return {
            testLevel: this.testLevel,
            username: this.username,
            apps: this.deployables.map((d) => d.getPath()),
        };
    }
    async deploy() {
        const directories = this.deployables.map((d) => d.pkg.fullPath);
        const name = this.deployables.map((p) => chalk_1.cyan.bold(p.getPath())).join(', ');
        const api = await (0, deploy_1.resolveApi)();
        this.log(`${os_1.EOL}Deploying ${name} to ${this.username} using ${api} API`);
        const { deploy } = await (0, deploy_1.executeDeploy)({
            'target-org': this.username,
            'source-dir': directories,
            'test-level': this.testLevel,
            api,
        });
        new progressBar_1.DeployProgress(deploy).start();
        const result = await deploy.pollStatus(500, kit_1.Duration.minutes(33).seconds);
        const formatter = new deployResultFormatter_1.DeployResultFormatter(result, {
            'test-level': this.testLevel,
            verbose: false,
            concise: false,
            'target-org': await core_1.Org.create({ aliasOrUsername: this.username }),
        });
        formatter.display();
        const deployerResult = {
            exitCode: (0, deploy_1.determineExitCode)(result),
        };
        return deployerResult;
    }
    async promptForUsername() {
        const aliasOrUsername = core_1.ConfigAggregator.getValue(core_1.OrgConfigProperties.TARGET_ORG)?.value;
        const stateAggregator = await core_1.StateAggregator.getInstance();
        await stateAggregator.orgs.readAll();
        const allAliases = stateAggregator.aliases.getAll();
        let targetOrgAuth;
        // make sure the "target-org" can be used in this deploy
        if (aliasOrUsername) {
            targetOrgAuth = (await core_1.AuthInfo.listAllAuthorizations((a) => (a.username === aliasOrUsername || a.aliases?.some((alias) => alias === aliasOrUsername)) ?? false)).find((a) => a);
            if (targetOrgAuth) {
                if (targetOrgAuth?.isExpired) {
                    const continueAnswer = await this.prompt([
                        {
                            name: 'continue',
                            type: 'confirm',
                            message: (0, chalk_1.red)(messages.getMessage('warning.TargetOrgIsExpired', [aliasOrUsername])),
                        },
                    ]);
                    if (!continueAnswer.continue) {
                        throw messages.createError('error.UserTerminatedDeployForExpiredOrg');
                    }
                }
                else {
                    return stateAggregator.aliases.resolveUsername(aliasOrUsername);
                }
            }
        }
        if (!aliasOrUsername || targetOrgAuth?.isExpired) {
            const promises = (await core_1.AuthInfo.listAllAuthorizations((orgAuth) => !orgAuth.error && orgAuth.isExpired !== true)).map(async (orgAuth) => {
                const stat = await stateAggregator.orgs.stat(orgAuth.username);
                const timestamp = stat ? new Date(stat.mtimeMs) : new Date();
                return { ...orgAuth, timestamp };
            });
            const authorizations = await Promise.all(promises);
            if (authorizations.length > 0) {
                const newestAuths = authorizations.sort(compareOrgs);
                const options = newestAuths.map((auth) => ({
                    name: auth.username,
                    aliases: Object.entries(allAliases)
                        .filter(([, usernameOrAlias]) => usernameOrAlias === auth.username)
                        .map(([alias]) => alias)
                        .join(', '),
                    isScratchOrg: auth.isScratchOrg ? 'Yes' : 'No',
                    value: auth.username,
                }));
                const columns = { name: 'Org', aliases: 'Aliases', isScratchOrg: 'Scratch Org' };
                const { username } = await this.prompt([
                    {
                        name: 'username',
                        message: 'Select the org you want to deploy to:',
                        type: 'list',
                        choices: (0, sf_plugins_core_1.generateTableChoices)(columns, options, false),
                    },
                ]);
                if (targetOrgAuth?.isExpired) {
                    const setTargetOrg = await this.prompt([
                        {
                            name: 'save',
                            type: 'confirm',
                            message: messages.getMessage('save.as.default', [username]),
                        },
                    ]);
                    if (setTargetOrg.save) {
                        const authInfo = await core_1.AuthInfo.create({ username });
                        await authInfo.setAsDefault({ org: true });
                    }
                }
                return username;
            }
            else {
                throw messages.createError('errors.NoOrgsToSelect');
            }
        }
        throw new Error('Unexpected: You should not have arrived here.');
    }
    async promptForTestLevel() {
        const { testLevel } = await this.prompt([
            {
                name: 'testLevel',
                message: 'Select the test level you would like to run:',
                type: 'list',
                loop: false,
                pageSize: 4,
                choices: [
                    { name: "Don't run tests", value: types_1.TestLevel.NoTestRun, short: "Don't run tests" },
                    { name: 'Run local tests', value: types_1.TestLevel.RunLocalTests, short: 'Run local tests' },
                    {
                        name: 'Run all tests in environment',
                        value: types_1.TestLevel.RunAllTestsInOrg,
                        short: 'Run all tests in environment',
                    },
                ],
            },
        ]);
        return testLevel;
    }
}
exports.MetadataDeployer = MetadataDeployer;
MetadataDeployer.NAME = 'Salesforce Apps';
//# sourceMappingURL=metadataDeployer.js.map