"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployCache = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const deploy_1 = require("./deploy");
const manifestCache_1 = require("./manifestCache");
class DeployCache extends core_1.TTLConfig {
    static getFileName() {
        return 'deploy-cache.json';
    }
    static getDefaultOptions() {
        return {
            isGlobal: false,
            isState: true,
            filename: DeployCache.getFileName(),
            stateFolder: core_1.Global.SF_STATE_FOLDER,
            ttl: kit_1.Duration.days(3),
        };
    }
    /**
     *
     * @param key jobId
     * @param value a DeployOptions object (wait is a duration, can use non-manifest options)
     * @param manifestFilePath the path to the manifest file generated by the deploy
     */
    static async set(key, value) {
        const cache = await DeployCache.create();
        // remove properties we won't cache or that are not primitives
        const { 'metadata-dir': mdDir, 'source-dir': sourceDir, wait, ...cleanValue } = value;
        cache.set(key, { ...cleanValue, wait: wait?.minutes ?? 33, isMdapi: Boolean(mdDir) });
        await cache.write();
    }
    static async unset(key) {
        const cache = await DeployCache.create();
        cache.unset(key);
        await Promise.all([cache.write(), (0, manifestCache_1.maybeDestroyManifest)(key)]);
    }
    static async update(key, obj) {
        const cache = await DeployCache.create();
        cache.update(key, obj);
        await cache.write();
    }
    resolveLatest(useMostRecent, key, throwOnNotFound = true) {
        const keyFromLatest = useMostRecent ? this.getLatestKey() : key;
        if (!keyFromLatest)
            throw deploy_1.cacheMessages.createError('error.NoRecentJobId');
        const jobId = this.resolveLongId(keyFromLatest);
        if (throwOnNotFound && !this.has(jobId)) {
            throw deploy_1.cacheMessages.createError('error.InvalidJobId', [jobId]);
        }
        return jobId;
    }
    resolveLongId(jobId) {
        if (jobId.length === 18) {
            return jobId;
        }
        else if (jobId.length === 15) {
            const match = this.keys().find((k) => k.startsWith(jobId));
            if (match) {
                return match;
            }
            throw deploy_1.cacheMessages.createError('error.InvalidJobId', [jobId]);
        }
        else {
            throw deploy_1.cacheMessages.createError('error.InvalidJobId', [jobId]);
        }
    }
    get(jobId) {
        return super.get(this.resolveLongId(jobId));
    }
}
exports.DeployCache = DeployCache;
//# sourceMappingURL=deployCache.js.map