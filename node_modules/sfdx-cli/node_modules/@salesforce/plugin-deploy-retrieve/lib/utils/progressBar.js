"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployProgress = void 0;
const core_1 = require("@salesforce/core");
const core_2 = require("@salesforce/core");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
core_2.Messages.importMessagesDirectory(__dirname);
const mdTrasferMessages = core_2.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'metadata.transfer');
class DeployProgress extends sf_plugins_core_1.Progress {
    constructor(deploy, jsonEnabled = false) {
        super(!jsonEnabled && core_1.envVars.getBoolean(core_1.EnvironmentVariable.SF_USE_PROGRESS_BAR, true));
        this.deploy = deploy;
    }
    start() {
        super.start(0, { status: 'Waiting' }, DeployProgress.OPTIONS);
        this.deploy.onUpdate((data) => this.updateProgress(data));
        // any thing else should make one final update, then stop the progress bar
        this.deploy.onFinish((data) => {
            this.updateProgress(data.response);
            this.finish({ status: mdTrasferMessages.getMessage(data.response.status) });
        });
        this.deploy.onCancel(() => this.stop());
        this.deploy.onError((error) => {
            this.stop();
            throw error;
        });
    }
    updateProgress(data) {
        // the numCompTot. isn't computed right away, wait to start until we know how many we have
        if (data.numberComponentsTotal) {
            this.setTotal(data.numberComponentsTotal + data.numberTestsTotal);
            this.update(data.numberComponentsDeployed + data.numberTestsCompleted, {
                status: mdTrasferMessages.getMessage(data.status),
            });
        }
        else {
            this.update(0, { status: mdTrasferMessages.getMessage(data.status) ?? 'Waiting' });
        }
        // the numTestsTot. isn't computed until validated as tests by the server, update the PB once we know
        if (data.numberTestsTotal && data.numberComponentsTotal) {
            this.setTotal(data.numberComponentsTotal + data.numberTestsTotal);
        }
    }
}
exports.DeployProgress = DeployProgress;
DeployProgress.OPTIONS = {
    title: 'Status',
    format: '%s: {status} | {bar} | {value}/{total} Components',
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    linewrap: true,
};
//# sourceMappingURL=progressBar.js.map