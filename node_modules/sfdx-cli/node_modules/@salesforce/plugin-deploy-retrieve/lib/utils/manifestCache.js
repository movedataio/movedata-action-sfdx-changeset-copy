"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeDestroyManifest = exports.writeManifest = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const os_1 = require("os");
const fs = require("fs");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const MANIFEST_CACHE_DIR = 'manifestCache';
/** Give it a jobId, ComponentSet it will write the manifest file
 * returns the file path it wrote to */
const writeManifest = async (jobId, componentSet) => {
    const types = new Set((await componentSet.getObject()).Package.types.map((t) => t.name));
    // when we write a manifest, we will omit the CustomLabels component since it's redundant with the individual labels.
    // this makes the use of the manifest in report/resume/etc accurate in certain mpd scenarios where it would otherwise pull in ALL labels from every dir
    // regardless of whether they were actually deployed
    // we'll only do this when something like `-m CustomLabels:*` or `-d labels/CustomLabels.labels-meta.xml` is specified which will include every CustomLabel
    // in the project. When only a single label is specified, we need to strip out the `CustomLabels` entry otherwise we'll display information for every
    // CustomLabel in the project instead of the single on specified
    let xml;
    if (types.has('CustomLabels') && types.has('CustomLabel')) {
        // cs.filter doesn't return the SAME component set, it just returns a new one...
        // and so when we set anything on the component set that was passed in, it won't be set on the filtered one
        // so, we create a new CS, and set the values from the original
        const cs = new source_deploy_retrieve_1.ComponentSet(componentSet.filter((c) => c.type.name !== 'CustomLabels'));
        cs.sourceApiVersion = componentSet.sourceApiVersion;
        cs.apiVersion = componentSet.apiVersion;
        xml = await cs.getPackageXml();
    }
    else {
        xml = await componentSet.getPackageXml();
    }
    const filePath = getManifestFilePath(jobId);
    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
    await fs.promises.writeFile(filePath, xml);
    return filePath;
};
exports.writeManifest = writeManifest;
const maybeDestroyManifest = async (jobId) => {
    try {
        return await fs.promises.rm(getManifestFilePath(jobId));
    }
    catch (e) {
        // that's ok in a maybe
    }
};
exports.maybeDestroyManifest = maybeDestroyManifest;
const getManifestFilePath = (jobId) => path.join((0, os_1.homedir)(), core_1.Global.SF_STATE_FOLDER, MANIFEST_CACHE_DIR, `${jobId}.xml`);
//# sourceMappingURL=manifestCache.js.map