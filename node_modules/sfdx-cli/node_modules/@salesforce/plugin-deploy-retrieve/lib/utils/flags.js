"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipFileFlag = exports.fileOrDirFlag = exports.testLevelFlag = exports.ensuredDirFlag = exports.DEFAULT_ZIP_FILE_NAME = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path_1 = require("path");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const types_1 = require("./types");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'validation');
const parsePathInfo = async (input, opts) => {
    if (opts.exists && !fs.existsSync(input)) {
        throw messages.createError('error.InvalidFlagPath', [input, messages.getMessage('error.ExpectedFileOrDirToExist')]);
    }
    const stat = await fs.promises.stat(input);
    if (stat.isDirectory()) {
        return { type: 'directory', path: input };
    }
    return { type: 'file', path: input };
};
/**
 * Ensures that the specified directory exists. If it does not, it is created.
 */
async function ensureDirectoryPath(path) {
    const trimmedPath = path.trim();
    const resolvedPath = trimmedPath?.length ? (0, path_1.resolve)(trimmedPath) : '';
    try {
        const stats = await fs.promises.stat(resolvedPath);
        const isDir = stats.isDirectory();
        if (!isDir) {
            throw messages.createError('error.InvalidFlagPath', [path, messages.getMessage('error.ExpectedDirectory')]);
        }
    }
    catch (error) {
        if (error instanceof Error && 'code' in error && error.code !== 'ENOENT') {
            throw error;
        }
        else {
            await fs.promises.mkdir(resolvedPath, { recursive: true });
        }
    }
    return resolvedPath;
}
function resolveZipFileName(zipFileName) {
    if (!zipFileName) {
        return exports.DEFAULT_ZIP_FILE_NAME;
    }
    // If no file extension was provided append, '.zip'
    return !(0, path_1.extname)(zipFileName) ? (zipFileName += '.zip') : zipFileName;
}
exports.DEFAULT_ZIP_FILE_NAME = 'unpackaged.zip';
/**
 * Flag value is a directory path that may or may not exist. If it doesn't exist, then it will be created.
 */
exports.ensuredDirFlag = core_1.Flags.custom({
    parse: async (input) => ensureDirectoryPath(input),
});
exports.testLevelFlag = core_1.Flags.custom({
    char: 'l',
    parse: (input) => Promise.resolve(input),
    options: Object.values(types_1.TestLevel),
});
/**
 * Flag value could either be a file path or a directory path.
 */
exports.fileOrDirFlag = core_1.Flags.custom({
    parse: async (input, _, opts) => parsePathInfo(input, opts),
});
/**
 * Flag value is the name of a zip file that defaults to 'unpackaged.zip'.
 */
exports.zipFileFlag = core_1.Flags.custom({
    parse: async (input) => Promise.resolve(resolveZipFileName(input)),
});
//# sourceMappingURL=flags.js.map