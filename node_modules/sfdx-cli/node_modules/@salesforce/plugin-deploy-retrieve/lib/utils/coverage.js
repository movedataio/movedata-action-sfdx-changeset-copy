"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coverageOutput = exports.transformCoverageToApexCoverage = exports.getCoverageFormattersOptions = exports.generateCoveredLines = exports.mapTestResults = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const apex_node_1 = require("@salesforce/apex-node");
const kit_1 = require("@salesforce/kit");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const mapTestResults = (testResults) => testResults.map((testResult) => ({
    apexClass: { fullName: testResult.name, id: testResult.id, name: testResult.name, namespacePrefix: '' },
    apexLogId: '',
    asyncApexJobId: '',
    fullName: testResult.name,
    id: testResult.id,
    ...('message' in testResult && testResult.message
        ? { message: testResult.message, outcome: "Pass" /* ApexTestResultOutcome.Pass */ }
        : { message: null, outcome: "Fail" /* ApexTestResultOutcome.Fail */ }),
    methodName: testResult.methodName,
    queueItemId: '',
    runTime: parseInt(testResult.time, 10),
    stackTrace: 'stackTrace' in testResult ? testResult.stackTrace : null,
    testTimestamp: '',
}));
exports.mapTestResults = mapTestResults;
const generateCoveredLines = (cov) => {
    const numCovered = parseInt(cov.numLocations, 10);
    const numUncovered = parseInt(cov.numLocationsNotCovered, 10);
    const uncoveredLines = (0, kit_1.ensureArray)(cov.locationsNotCovered).map((location) => parseInt(location.line, 10));
    const minLineNumber = uncoveredLines.length ? Math.min(...uncoveredLines) : 1;
    const lines = [...Array(numCovered + numUncovered).keys()].map((i) => i + minLineNumber);
    const coveredLines = lines.filter((line) => !uncoveredLines.includes(line));
    return [uncoveredLines, coveredLines];
};
exports.generateCoveredLines = generateCoveredLines;
const getCoverageFormattersOptions = (formatters = []) => {
    const reportFormats = formatters;
    const reportOptions = Object.fromEntries(reportFormats.map((format) => {
        const formatDefaults = apex_node_1.DefaultReportOptions[format];
        return [
            format,
            {
                ...formatDefaults,
                // always join any subdir from the defaults with our custom coverage dir
                ...('subdir' in formatDefaults ? { subdir: path.join('coverage', formatDefaults.subdir) } : {}),
                // if there is no subdir, we also put the file in the coverage dir, otherwise leave it alone
                ...('file' in formatDefaults && !('subdir' in formatDefaults)
                    ? { file: path.join('coverage', formatDefaults.file) }
                    : {}),
            },
        ];
    }));
    return {
        reportFormats,
        reportOptions,
    };
};
exports.getCoverageFormattersOptions = getCoverageFormattersOptions;
const transformCoverageToApexCoverage = (mdCoverage) => {
    const apexCoverage = mdCoverage.map((cov) => {
        const numCovered = parseInt(cov.numLocations, 10);
        const numUncovered = parseInt(cov.numLocationsNotCovered, 10);
        const [uncoveredLines, coveredLines] = (0, exports.generateCoveredLines)(cov);
        const ac = {
            ApexClassOrTrigger: {
                Id: cov.id,
                Name: cov.name,
            },
            NumLinesCovered: numCovered,
            NumLinesUncovered: numUncovered,
            Coverage: {
                coveredLines,
                uncoveredLines,
            },
        };
        return ac;
    });
    return { done: true, totalSize: apexCoverage.length, records: apexCoverage };
};
exports.transformCoverageToApexCoverage = transformCoverageToApexCoverage;
const coverageOutput = (cov) => {
    const numLocationsNum = parseInt(cov.numLocations, 10);
    const numLocationsNotCovered = parseInt(cov.numLocationsNotCovered, 10);
    const color = numLocationsNotCovered > 0 ? sf_plugins_core_1.StandardColors.error : sf_plugins_core_1.StandardColors.success;
    let pctCovered = 100;
    const coverageDecimal = parseFloat(((numLocationsNum - numLocationsNotCovered) / numLocationsNum).toFixed(2));
    if (numLocationsNum > 0) {
        pctCovered = coverageDecimal * 100;
    }
    // cov.numLocations = color(`${pctCovered}%`);
    const base = {
        name: cov.name,
        numLocations: color(`${pctCovered}%`),
    };
    if (!cov.locationsNotCovered) {
        return { ...base, lineNotCovered: '' };
    }
    const locations = (0, kit_1.ensureArray)(cov.locationsNotCovered);
    return {
        ...base,
        lineNotCovered: locations.map((location) => location.line).join(','),
    };
};
exports.coverageOutput = coverageOutput;
//# sourceMappingURL=coverage.js.map