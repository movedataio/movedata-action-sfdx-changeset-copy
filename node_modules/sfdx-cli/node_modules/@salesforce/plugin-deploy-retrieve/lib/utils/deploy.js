"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNotResumable = exports.determineExitCode = exports.poll = exports.cancelDeployAsync = exports.cancelDeploy = exports.executeDeploy = exports.buildComponentSet = exports.resolveApi = exports.validateTests = exports.cacheMessages = void 0;
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const source_tracking_1 = require("@salesforce/source-tracking");
const configMeta_1 = require("../configMeta");
const project_1 = require("./project");
const types_1 = require("./types");
const errorCodes_1 = require("./errorCodes");
const deployCache_1 = require("./deployCache");
const manifestCache_1 = require("./manifestCache");
core_1.Messages.importMessagesDirectory(__dirname);
exports.cacheMessages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'cache');
const deployMessages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'deploy.metadata');
function validateTests(testLevel, tests) {
    return !(testLevel === types_1.TestLevel.RunSpecifiedTests && (tests ?? []).length === 0);
}
exports.validateTests = validateTests;
async function resolveApi(existingConfigAggregator) {
    const agg = existingConfigAggregator ?? (await core_1.ConfigAggregator.create({ customConfigMeta: configMeta_1.default }));
    const restDeployConfig = agg.getInfo(configMeta_1.ConfigVars.ORG_METADATA_REST_DEPLOY)?.value;
    return restDeployConfig === 'true' ? types_1.API.REST : types_1.API.SOAP;
}
exports.resolveApi = resolveApi;
async function buildComponentSet(opts, stl) {
    // if you specify nothing, you'll get the changes, like sfdx push, as long as there's an stl
    if (!opts['source-dir'] && !opts.manifest && !opts.metadata && stl) {
        /** localChangesAsComponentSet returned an array to support multiple sequential deploys.
         * `sf` chooses not to support this so we force one ComponentSet
         */
        const cs = (await stl.localChangesAsComponentSet(false))?.[0] ?? new source_deploy_retrieve_1.ComponentSet();
        // stl produces a cs with api version already set.  command might have specified a version.
        if (opts['api-version']) {
            cs.apiVersion = opts['api-version'];
            cs.sourceApiVersion = opts['api-version'];
        }
        return cs;
    }
    return source_deploy_retrieve_1.ComponentSetBuilder.build({
        apiversion: opts['api-version'],
        sourceapiversion: await (0, project_1.getSourceApiVersion)(),
        sourcepath: opts['source-dir'],
        ...(opts.manifest
            ? {
                manifest: {
                    manifestPath: opts.manifest,
                    directoryPaths: await (0, project_1.getPackageDirs)(),
                    destructiveChangesPre: opts['pre-destructive-changes'],
                    destructiveChangesPost: opts['post-destructive-changes'],
                },
            }
            : {}),
        ...(opts.metadata ? { metadata: { metadataEntries: opts.metadata, directoryPaths: await (0, project_1.getPackageDirs)() } } : {}),
    });
}
exports.buildComponentSet = buildComponentSet;
async function executeDeploy(opts, bin = 'sf', project, id) {
    project ?? (project = await core_1.SfProject.resolve());
    const apiOptions = {
        checkOnly: opts['dry-run'] ?? false,
        ignoreWarnings: opts['ignore-warnings'] ?? false,
        rest: opts.api === 'REST',
        rollbackOnError: !opts['ignore-errors'] || false,
        runTests: opts.tests ?? [],
        testLevel: opts['test-level'],
        purgeOnDelete: opts['purge-on-delete'] ?? false,
    };
    let deploy;
    let componentSet;
    const org = await core_1.Org.create({ aliasOrUsername: opts['target-org'] });
    const usernameOrConnection = org.getConnection();
    if (opts['metadata-dir']) {
        if (id) {
            deploy = new source_deploy_retrieve_1.MetadataApiDeploy({ id, usernameOrConnection });
        }
        else {
            const key = opts['metadata-dir'].type === 'directory' ? 'mdapiPath' : 'zipPath';
            deploy = new source_deploy_retrieve_1.MetadataApiDeploy({
                [key]: opts['metadata-dir'].path,
                usernameOrConnection,
                apiOptions: { ...apiOptions, singlePackage: opts['single-package'] ?? false },
            });
            await deploy.start();
        }
    }
    else {
        // instantiate source tracking
        // stl will decide, based on the org's properties, what needs to be done
        const stl = await source_tracking_1.SourceTracking.create({
            org,
            project,
            subscribeSDREvents: true,
            ignoreConflicts: opts['ignore-conflicts'],
        });
        componentSet = await buildComponentSet(opts, stl);
        if (componentSet.size === 0) {
            throw new core_1.SfError(deployMessages.getMessage('error.nothingToDeploy'), 'NothingToDeploy', deployMessages.getMessages('error.nothingToDeploy.Actions', [bin]));
        }
        deploy = id
            ? new source_deploy_retrieve_1.MetadataApiDeploy({ id, usernameOrConnection, components: componentSet })
            : await componentSet.deploy({
                usernameOrConnection,
                apiOptions,
            });
    }
    if (!deploy.id) {
        throw new core_1.SfError('The deploy id is not available.');
    }
    // does not apply to mdapi deploys
    const manifestPath = componentSet ? await (0, manifestCache_1.writeManifest)(deploy.id, componentSet) : undefined;
    await deployCache_1.DeployCache.set(deploy.id, { ...opts, manifest: manifestPath });
    return { deploy, componentSet };
}
exports.executeDeploy = executeDeploy;
async function cancelDeploy(opts, id) {
    const org = await core_1.Org.create({ aliasOrUsername: opts['target-org'] });
    const usernameOrConnection = org.getUsername() ?? org.getConnection();
    const deploy = new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection, id });
    if (!deploy.id) {
        throw new core_1.SfError('The deploy id is not available.');
    }
    const componentSet = await buildComponentSet({ ...opts });
    await deployCache_1.DeployCache.set(deploy.id, { ...opts });
    await deploy.cancel();
    return poll(org, deploy.id, opts.wait ?? kit_1.Duration.minutes(33), componentSet);
}
exports.cancelDeploy = cancelDeploy;
async function cancelDeployAsync(opts, id) {
    const org = await core_1.Org.create({ aliasOrUsername: opts['target-org'] });
    const usernameOrConnection = org.getUsername() ?? org.getConnection();
    const deploy = new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection, id });
    await deploy.cancel();
    if (!deploy.id) {
        throw new core_1.SfError('The deploy id is not available.');
    }
    return { id: deploy.id };
}
exports.cancelDeployAsync = cancelDeployAsync;
async function poll(org, id, wait, componentSet) {
    const report = async () => {
        const res = await org.getConnection().metadata.checkDeployStatus(id, true);
        const deployStatus = res;
        return new source_deploy_retrieve_1.DeployResult(deployStatus, componentSet);
    };
    const opts = {
        frequency: kit_1.Duration.milliseconds(1000),
        timeout: wait,
        poll: async () => {
            const deployResult = await report();
            return {
                completed: deployResult.response.done,
                payload: deployResult,
            };
        },
    };
    const pollingClient = await core_1.PollingClient.create(opts);
    return pollingClient.subscribe();
}
exports.poll = poll;
function determineExitCode(result, async = false) {
    if (async) {
        return result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded ? 0 : 1;
    }
    return errorCodes_1.DEPLOY_STATUS_CODES.get(result.response.status) ?? 1;
}
exports.determineExitCode = determineExitCode;
const isNotResumable = (status) => status !== undefined &&
    [source_deploy_retrieve_1.RequestStatus.Succeeded, source_deploy_retrieve_1.RequestStatus.Failed, source_deploy_retrieve_1.RequestStatus.SucceededPartial, source_deploy_retrieve_1.RequestStatus.Canceled].includes(status);
exports.isNotResumable = isNotResumable;
//# sourceMappingURL=deploy.js.map