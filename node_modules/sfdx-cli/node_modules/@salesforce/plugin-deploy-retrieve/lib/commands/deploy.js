"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable class-methods-use-this */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEPLOY_OPTIONS_FILE = void 0;
const os_1 = require("os");
const core_1 = require("@salesforce/core");
const fs_extra_1 = require("fs-extra");
const kit_1 = require("@salesforce/kit");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const shelljs_1 = require("shelljs");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'deploy');
exports.DEPLOY_OPTIONS_FILE = 'deploy-options.json';
class Deploy extends sf_plugins_core_1.SfCommand {
    async run() {
        process.setMaxListeners(new kit_1.Env().getNumber('SF_MAX_EVENT_LISTENERS') ?? 1000);
        const { flags } = await this.parse(Deploy);
        flags.interactive = await this.isInteractive(flags.interactive);
        const options = await this.readOptions();
        this.log(messages.getMessage('AnalyzingProject'));
        if (!flags.interactive) {
            this.log(messages.getMessage('UsingOptionsFromFile', [exports.DEPLOY_OPTIONS_FILE]));
        }
        const hookResults = await sf_plugins_core_1.SfHook.run(this.config, 'sf:deploy', options);
        this.checkForHookFailures(hookResults);
        let deployers = hookResults.successes.flatMap((s) => s.result);
        if (deployers.length === 0) {
            this.log(messages.getMessage('FoundNothingToDeploy'));
        }
        else {
            if (flags.interactive) {
                deployers = await this.selectDeployers(deployers);
            }
            else {
                deployers = deployers.filter((d) => !!options[d.getName()]);
            }
            if (deployers.length === 0) {
                this.log(messages.getMessage('NothingSelectedToDeploy'));
            }
            const deployOptions = {};
            for (const deployer of deployers) {
                const opts = options[deployer.getName()] ?? {};
                // setup must be done sequentially
                // eslint-disable-next-line no-await-in-loop
                deployOptions[deployer.getName()] = await deployer.setup(flags, opts);
            }
            if (flags.interactive && (await this.askToSave())) {
                await (0, fs_extra_1.writeJson)(exports.DEPLOY_OPTIONS_FILE, deployOptions);
                this.log();
                this.log(messages.getMessage('DeployOptionsSavedToFile', [exports.DEPLOY_OPTIONS_FILE]));
                if (await this.shouldCommit()) {
                    await this.commit();
                    this.log(messages.getMessage('DeployOptionsIncludedInGitIgnore', [exports.DEPLOY_OPTIONS_FILE]));
                }
            }
            const deployResults = [];
            for (const deployer of deployers) {
                // deployments must be done sequentially?
                // eslint-disable-next-line no-await-in-loop
                deployResults.push([deployer, await deployer.deploy()]);
            }
            if (deployResults.some(([, result]) => !!result && result.exitCode !== 0)) {
                process.exitCode = 1;
                this.warn(messages.getMessage('DeployersHaveNonZeroExitCode'));
                deployResults
                    .filter(([, result]) => !!result && result.exitCode !== 0)
                    .forEach(([deployer, result]) => {
                    this.log(messages.getMessage('DeployerExitCode', [deployer.getName(), result ? result.exitCode : 'unknown']));
                });
            }
        }
    }
    /**
     * If the deploy file exists, we do not want the command to be interactive. But if the file
     * does not exist then we want to force the command to be interactive.
     */
    async isInteractive(interactive) {
        if (interactive)
            return true;
        const deployFileExists = await (0, fs_extra_1.pathExists)(exports.DEPLOY_OPTIONS_FILE);
        return deployFileExists ? false : true;
    }
    async readOptions() {
        if (await (0, fs_extra_1.pathExists)(exports.DEPLOY_OPTIONS_FILE)) {
            return (0, kit_1.parseJsonMap)(await (0, fs_extra_1.readFile)(exports.DEPLOY_OPTIONS_FILE, 'utf8'));
        }
        else {
            return {};
        }
    }
    async commit() {
        const gitignore = await (0, fs_extra_1.readFile)('.gitignore', 'utf-8');
        if (!gitignore.includes(exports.DEPLOY_OPTIONS_FILE)) {
            const addition = `${os_1.EOL}${os_1.EOL}# Deploy Options${os_1.EOL}${exports.DEPLOY_OPTIONS_FILE}${os_1.EOL}`;
            await (0, fs_extra_1.writeFile)('.gitignore', `${gitignore}${addition}`);
        }
        (0, shelljs_1.exec)('git add .gitignore', { silent: true });
        (0, shelljs_1.exec)(`git commit -am "Add ${exports.DEPLOY_OPTIONS_FILE} to .gitignore"`, { silent: true });
    }
    async shouldCommit() {
        return (await (0, fs_extra_1.pathExists)('.git')) && (await (0, fs_extra_1.pathExists)('functions'));
    }
    async askToSave() {
        const prompter = new sf_plugins_core_1.Prompter();
        const { save } = await prompter.prompt({
            name: 'save',
            message: 'Would you like to save these deploy options for future runs?',
            type: 'confirm',
        });
        return save;
    }
    async selectDeployers(deployers) {
        const deployables = deployers.reduce((x, y) => x.concat(y.deployables), []);
        const columns = { name: 'APP OR PACKAGE', type: 'TYPE', path: 'PATH' };
        const options = deployables.map((deployable) => ({
            name: deployable.getName(),
            type: deployable.getType(),
            path: deployable.getPath(),
            value: deployable,
        }));
        const prompter = new sf_plugins_core_1.Prompter();
        const responses = await prompter.prompt([
            {
                name: 'deployables',
                message: 'Select apps and packages to deploy:',
                type: 'checkbox',
                choices: (0, sf_plugins_core_1.generateTableChoices)(columns, options),
            },
        ]);
        const chosenDeployers = new Map();
        for (const deployable of responses.deployables) {
            const parent = deployable.getParent();
            if (chosenDeployers.has(parent)) {
                const existing = chosenDeployers.get(parent) ?? [];
                chosenDeployers.set(parent, [...existing, deployable]);
            }
            else {
                chosenDeployers.set(parent, [deployable]);
            }
        }
        const final = [];
        for (const [parent, children] of Array.from(chosenDeployers.entries())) {
            parent.selectDeployables(children);
            final.push(parent);
        }
        return final;
    }
    checkForHookFailures(hookResults) {
        if (hookResults.failures?.length) {
            // display a table of the errors encountered; Plugin Name, Error Message
            const columns = {
                errorName: { header: 'Error Name' },
                errorMessage: { header: 'Error Message' },
            };
            const failureData = hookResults.failures.map((failure) => ({
                errorName: failure.error.name,
                errorMessage: failure.error.message,
            }));
            this.styledHeader(messages.getMessage('error.initialization.title'));
            this.table(failureData, columns);
            const err = messages.createError('error.initialization');
            err.data = hookResults.failures;
            throw err;
        }
    }
}
exports.default = Deploy;
Deploy.summary = messages.getMessage('summary');
Deploy.description = messages.getMessage('description');
Deploy.examples = messages.getMessages('examples');
Deploy.enableJsonFlag = false;
Deploy.state = 'deprecated';
Deploy.deprecationOptions = {
    version: '59.0',
    message: messages.getMessage('deprecation'),
};
Deploy.flags = {
    interactive: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.interactive.summary'),
    }),
};
//# sourceMappingURL=deploy.js.map