"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mdapi = void 0;
const path_1 = require("path");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const metadataConvertResultFormatter_1 = require("../../../formatters/metadataConvertResultFormatter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'convert.mdapi');
class Mdapi extends sf_plugins_core_1.SfCommand {
    async run() {
        this.flags = (await this.parse(Mdapi)).flags;
        await this.convert();
        return this.formatResult();
    }
    async convert() {
        const [outputDir] = await Promise.all([
            resolveOutputDir(this.flags['output-dir'] ?? this.project.getDefaultPackage().path),
            resolveMetadataPaths(this.flags['metadata-dir'] ?? []),
        ]);
        let paths = [];
        if (this.flags['metadata-dir']) {
            paths = this.flags['metadata-dir'];
        }
        else if (!this.flags.manifest && !this.flags.metadata) {
            paths = [this.flags['root-dir']];
        }
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            sourcepath: paths,
            manifest: this.flags.manifest
                ? {
                    manifestPath: this.flags.manifest,
                    directoryPaths: [this.flags['root-dir']],
                }
                : undefined,
            metadata: this.flags.metadata
                ? {
                    metadataEntries: this.flags.metadata,
                    directoryPaths: [this.flags['root-dir']],
                }
                : undefined,
        });
        const numOfComponents = this.componentSet.getSourceComponents().toArray().length;
        if (numOfComponents > 0) {
            this.spinner.start(`Converting ${numOfComponents} metadata components`);
            const converter = new source_deploy_retrieve_1.MetadataConverter();
            this.convertResult = await converter.convert(this.componentSet, 'source', {
                type: 'directory',
                outputDirectory: outputDir,
                genUniqueDir: false,
            });
            this.spinner.stop();
        }
    }
    formatResult() {
        if (!this.convertResult) {
            throw new core_1.SfError('No results to format');
        }
        const formatter = new metadataConvertResultFormatter_1.MetadataConvertResultFormatter(this.convertResult);
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
exports.Mdapi = Mdapi;
Mdapi.aliases = ['force:mdapi:convert'];
Mdapi.deprecateAliases = true;
Mdapi.summary = messages.getMessage('summary');
Mdapi.description = messages.getMessage('description');
Mdapi.examples = messages.getMessages('examples');
Mdapi.requiresProject = true;
Mdapi.flags = {
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'root-dir': sf_plugins_core_1.Flags.directory({
        aliases: ['rootdir'],
        deprecateAliases: true,
        char: 'r',
        summary: messages.getMessage('flags.root-dir.summary'),
        required: true,
        exists: true,
    }),
    'output-dir': sf_plugins_core_1.Flags.directory({
        aliases: ['outputdir'],
        deprecateAliases: true,
        char: 'd',
        summary: messages.getMessage('flags.output-dir.summary'),
    }),
    manifest: sf_plugins_core_1.Flags.file({
        char: 'x',
        description: messages.getMessage('flags.manifest.description'),
        summary: messages.getMessage('flags.manifest.summary'),
        exists: true,
    }),
    'metadata-dir': (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'p',
        aliases: ['metadatapath'],
        deprecateAliases: true,
        description: messages.getMessage('flags.metadata-dir.description'),
        summary: messages.getMessage('flags.metadata-dir.summary'),
        exclusive: ['manifest', 'metadata'],
    }),
    metadata: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'm',
        summary: messages.getMessage('flags.metadata.summary'),
        exclusive: ['manifest', 'metadatapath'],
    }),
};
const resolveOutputDir = async (outputDir) => ensureFlagPath({
    flagName: 'outputdir',
    path: outputDir,
    type: 'dir',
});
const resolveMetadataPaths = async (metadataPaths) => Promise.all(metadataPaths
    .filter((mdPath) => mdPath?.length)
    .map((mdPath) => ensureFlagPath({
    flagName: 'metadatapath',
    path: mdPath,
    type: 'any',
    throwOnENOENT: true,
})));
/**
 * Ensures command flags that are file system paths are set properly before
 * continuing command execution.  Can also create directories that don't yet
 * exist in the path.
 *
 * @param options defines the path to resolve and the expectations
 * @returns the resolved flag path
 */
const ensureFlagPath = async (options) => {
    const { flagName, path, type, throwOnENOENT } = options;
    const resolvedPath = (0, path_1.resolve)(path?.trim());
    try {
        const stats = await fs.promises.stat(resolvedPath);
        if (type !== 'any') {
            const isDir = stats.isDirectory();
            if (type === 'dir' && !isDir) {
                throw messages.createError('InvalidFlagPath', [flagName, path, messages.getMessage('expectedDirectory')]);
            }
            else if (type === 'file' && isDir) {
                throw messages.createError(messages.getMessage('InvalidFlagPath', [flagName, path, messages.getMessage('expectedFile')]));
            }
        }
        return resolvedPath;
    }
    catch (error) {
        if (error instanceof Error && 'code' in error && error.code !== 'ENOENT') {
            throw error;
        }
        else {
            if (throwOnENOENT) {
                const enoent = messages.getMessage('notFound');
                throw new core_1.SfError(messages.getMessage('InvalidFlagPath', [flagName, path, enoent]), 'InvalidFlagPath');
            }
            const dir = type === 'dir' ? resolvedPath : (0, path_1.dirname)(resolvedPath);
            // using as because fs promises always returns a string when recursive is true
            return fs.promises.mkdir(dir, { recursive: true });
        }
    }
};
//# sourceMappingURL=mdapi.js.map