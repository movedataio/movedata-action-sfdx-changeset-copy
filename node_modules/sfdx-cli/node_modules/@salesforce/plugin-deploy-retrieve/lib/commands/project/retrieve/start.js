"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const path_1 = require("path");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const ts_types_1 = require("@salesforce/ts-types");
const source_tracking_1 = require("@salesforce/source-tracking");
const kit_1 = require("@salesforce/kit");
const flags_1 = require("../../../utils/flags");
const retrieveResultFormatter_1 = require("../../../formatters/retrieveResultFormatter");
const metadataRetrieveResultFormatter_1 = require("../../../formatters/metadataRetrieveResultFormatter");
const project_1 = require("../../../utils/project");
const conflicts_1 = require("../../../utils/conflicts");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'retrieve.metadata');
const mdTransferMessages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'metadata.transfer');
class RetrieveMetadata extends sf_plugins_core_1.SfCommand {
    // eslint-disable-next-line complexity
    async run() {
        const { flags } = await this.parse(RetrieveMetadata);
        this.spinner.start(messages.getMessage('spinner.start'));
        const format = flags['target-metadata-dir'] ? 'metadata' : 'source';
        const stl = await source_tracking_1.SourceTracking.create({
            org: flags['target-org'],
            project: this.project,
            subscribeSDREvents: true,
            ignoreConflicts: format === 'metadata' || flags['ignore-conflicts'],
        });
        const isChanges = !flags['source-dir'] && !flags['manifest'] && !flags['metadata'];
        const { componentSetFromNonDeletes, fileResponsesFromDelete } = isChanges
            ? await stl.maybeApplyRemoteDeletesToLocal(true)
            : {
                componentSetFromNonDeletes: await source_deploy_retrieve_1.ComponentSetBuilder.build({
                    apiversion: flags['api-version'],
                    sourcepath: flags['source-dir'],
                    packagenames: flags['package-name'],
                    ...(flags.manifest
                        ? {
                            manifest: {
                                manifestPath: flags.manifest,
                                directoryPaths: await (0, project_1.getPackageDirs)(),
                            },
                        }
                        : {}),
                    ...(flags.metadata
                        ? { metadata: { metadataEntries: flags.metadata, directoryPaths: await (0, project_1.getPackageDirs)() } }
                        : {}),
                }),
                fileResponsesFromDelete: [],
            };
        // stl sets version based on config/files--if the command overrides it, we need to update
        if (isChanges && flags['api-version']) {
            componentSetFromNonDeletes.apiVersion = flags['api-version'];
        }
        this.spinner.status = messages.getMessage('spinner.sending', [
            componentSetFromNonDeletes.sourceApiVersion ?? componentSetFromNonDeletes.apiVersion,
        ]);
        const zipFileName = flags['zip-file-name'] ?? flags_1.DEFAULT_ZIP_FILE_NAME;
        const retrieveOpts = {
            usernameOrConnection: flags['target-org'].getUsername() ?? flags['target-org'].getConnection(flags['api-version']),
            merge: true,
            output: this.project.getDefaultPackage().fullPath,
            packageOptions: flags['package-name'],
            format,
            ...(format === 'metadata'
                ? {
                    singlePackage: flags['single-package'],
                    unzip: flags.unzip,
                    zipFileName,
                    output: flags['target-metadata-dir'],
                }
                : {}),
        };
        const retrieve = await componentSetFromNonDeletes.retrieve(retrieveOpts);
        this.spinner.status = messages.getMessage('spinner.polling');
        retrieve.onUpdate((data) => {
            this.spinner.status = mdTransferMessages.getMessage(data.status);
        });
        // any thing else should stop the progress bar
        retrieve.onFinish((data) => this.spinner.stop(mdTransferMessages.getMessage(data.response.status)));
        retrieve.onCancel((data) => this.spinner.stop(mdTransferMessages.getMessage(data?.status ?? 'Canceled')));
        retrieve.onError((error) => {
            this.spinner.stop(error.name);
            throw error;
        });
        await retrieve.start();
        const result = await retrieve.pollStatus(500, flags.wait.seconds);
        this.spinner.stop();
        // reference the flag instead of `format` so we get correct type
        const formatter = flags['target-metadata-dir']
            ? new metadataRetrieveResultFormatter_1.MetadataRetrieveResultFormatter(result, {
                'target-metadata-dir': flags['target-metadata-dir'],
                'zip-file-name': zipFileName,
                unzip: flags.unzip,
            })
            : new retrieveResultFormatter_1.RetrieveResultFormatter(result, flags['package-name'], fileResponsesFromDelete);
        if (!this.jsonEnabled()) {
            if (result.response.status === 'Succeeded') {
                await formatter.display();
            }
            else {
                throw new core_1.SfError((0, ts_types_1.getString)(result.response, 'errorMessage', result.response.status), (0, ts_types_1.getString)(result.response, 'errorStatusCode', 'unknown'));
            }
        }
        if (format === 'metadata' && flags.unzip) {
            try {
                await (0, promises_1.rm)((0, path_1.resolve)((0, path_1.join)(flags['target-metadata-dir'] ?? '', zipFileName)), {
                    recursive: true,
                });
            }
            catch (e) {
                // do nothing
            }
        }
        return formatter.getJson();
    }
    catch(error) {
        if (error instanceof source_tracking_1.SourceConflictError) {
            if (!this.jsonEnabled()) {
                (0, conflicts_1.writeConflictTable)(error.data);
                // set the message and add plugin-specific actions
                return super.catch({
                    ...error,
                    message: messages.getMessage('error.Conflicts'),
                    actions: messages.getMessages('error.Conflicts.Actions', [this.config.bin]),
                });
            }
        }
        return super.catch(error);
    }
}
exports.default = RetrieveMetadata;
RetrieveMetadata.summary = messages.getMessage('summary');
RetrieveMetadata.description = messages.getMessage('description');
RetrieveMetadata.examples = messages.getMessages('examples');
RetrieveMetadata.requiresProject = true;
RetrieveMetadata.aliases = ['retrieve:metadata'];
RetrieveMetadata.deprecateAliases = true;
RetrieveMetadata.flags = {
    'api-version': sf_plugins_core_1.Flags.orgApiVersion({
        char: 'a',
        summary: messages.getMessage('flags.api-version.summary'),
        description: messages.getMessage('flags.api-version.description'),
    }),
    'ignore-conflicts': sf_plugins_core_1.Flags.boolean({
        char: 'c',
        summary: messages.getMessage('flags.ignore-conflicts.summary'),
        description: messages.getMessage('flags.ignore-conflicts.description'),
        default: false,
    }),
    manifest: sf_plugins_core_1.Flags.file({
        char: 'x',
        summary: messages.getMessage('flags.manifest.summary'),
        description: messages.getMessage('flags.manifest.description'),
        exclusive: ['metadata', 'source-dir'],
        exists: true,
    }),
    metadata: sf_plugins_core_1.Flags.string({
        char: 'm',
        summary: messages.getMessage('flags.metadata.summary'),
        multiple: true,
        exclusive: ['manifest', 'source-dir'],
    }),
    'package-name': sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.package-name.summary'),
        multiple: true,
    }),
    'single-package': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.single-package.summary'),
        dependsOn: ['target-metadata-dir'],
        exclusive: ['ignore-conflicts'],
    }),
    'source-dir': sf_plugins_core_1.Flags.string({
        char: 'd',
        summary: messages.getMessage('flags.source-dir.summary'),
        description: messages.getMessage('flags.source-dir.description'),
        multiple: true,
        exclusive: ['manifest', 'metadata'],
    }),
    'target-metadata-dir': (0, flags_1.ensuredDirFlag)({
        char: 't',
        summary: messages.getMessage('flags.target-metadata-dir.summary'),
        relationships: [
            {
                type: 'some',
                flags: ['manifest', 'metadata', 'source-dir', 'package-name'],
            },
        ],
        exclusive: ['ignore-conflicts'],
    }),
    'target-org': sf_plugins_core_1.Flags.requiredOrg({
        char: 'o',
        summary: messages.getMessage('flags.target-org.summary'),
        description: messages.getMessage('flags.target-org.description'),
        required: true,
    }),
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        defaultValue: 33,
        default: kit_1.Duration.minutes(33),
        unit: 'minutes',
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
    }),
    unzip: sf_plugins_core_1.Flags.boolean({
        char: 'z',
        summary: messages.getMessage('flags.unzip.summary'),
        dependsOn: ['target-metadata-dir'],
        exclusive: ['ignore-conflicts'],
    }),
    'zip-file-name': (0, flags_1.zipFileFlag)({
        summary: messages.getMessage('flags.zip-file-name.summary'),
        dependsOn: ['target-metadata-dir'],
        exclusive: ['ignore-conflicts'],
    }),
};
RetrieveMetadata.configurationVariablesSection = (0, sf_plugins_core_1.toHelpSection)('CONFIGURATION VARIABLES', core_1.OrgConfigProperties.TARGET_ORG, core_1.OrgConfigProperties.ORG_API_VERSION);
RetrieveMetadata.envVariablesSection = (0, sf_plugins_core_1.toHelpSection)('ENVIRONMENT VARIABLES', core_1.EnvironmentVariable.SF_TARGET_ORG, core_1.EnvironmentVariable.SF_USE_PROGRESS_BAR);
//# sourceMappingURL=start.js.map