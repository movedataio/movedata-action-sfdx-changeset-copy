"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Source = void 0;
const fs = require("fs");
const path = require("path");
const os = require("os");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const kit_1 = require("@salesforce/kit");
const source_tracking_1 = require("@salesforce/source-tracking");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const chalk = require("chalk");
const types_1 = require("../../../utils/types");
const project_1 = require("../../../utils/project");
const deploy_1 = require("../../../utils/deploy");
const deployResultFormatter_1 = require("../../../formatters/deployResultFormatter");
const deleteResultFormatter_1 = require("../../../formatters/deleteResultFormatter");
const progressBar_1 = require("../../../utils/progressBar");
const deployCache_1 = require("../../../utils/deployCache");
const flags_1 = require("../../../utils/flags");
const fsPromises = fs.promises;
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'delete.source');
const xorFlags = ['metadata', 'source-dir'];
class Source extends sf_plugins_core_1.SfCommand {
    constructor() {
        super(...arguments);
        // private deleteResultFormatter: DeleteResultFormatter | DeployResultFormatter;
        this.aborted = false;
        // create the delete FileResponse as we're parsing the comp. set to use in the output
        this.mixedDeployDelete = { delete: [], deploy: [] };
        // map of component in project, to where it is stashed
        this.stashPath = new Map();
        this.tempDir = path.join(os.tmpdir(), 'source_delete');
        /**
         * Check if any conflicts exist in a specific component set.
         * If conflicts exist, this will output the table and throw
         */
        this.filterConflictsByComponentSet = async () => {
            const filteredConflicts = (await this.tracking?.getConflicts())?.filter((cr) => this.componentSet.has({ fullName: cr.name, type: cr.type })) ?? [];
            this.processConflicts(filteredConflicts, messages.getMessage('conflictMsg'));
            return filteredConflicts;
        };
        /**
         * Write a table (if not json) and throw an error that includes a custom message and the conflict data
         *
         * @param conflicts
         * @param message
         */
        this.processConflicts = (conflicts, message) => {
            if (conflicts.length === 0) {
                return;
            }
            this.table(conflicts, {
                state: { header: 'STATE' },
                fullName: { header: 'FULL NAME' },
                type: { header: 'TYPE' },
                filePath: { header: 'FILE PATH' },
            });
            // map do dedupe by name-type-filename
            const conflictMap = new Map();
            conflicts.forEach((c) => {
                c.filenames?.forEach((f) => {
                    conflictMap.set(`${c.name}#${c.type}#${f}`, {
                        state: 'Conflict',
                        fullName: c.name,
                        type: c.type,
                        filePath: path.resolve(f),
                    });
                });
            });
            const reformattedConflicts = Array.from(conflictMap.values());
            const err = new core_1.SfError(message, 'sourceConflictDetected');
            err.setData(reformattedConflicts);
            throw err;
        };
    }
    async run() {
        this.flags = (await this.parse(Source)).flags;
        this.org = this.flags['target-org'];
        await this.preChecks();
        await this.delete();
        await this.resolveSuccess();
        const result = this.formatResult();
        // The DeleteResultFormatter will use SDR and scan the directory, if the files have been deleted, it will throw an error
        // so we'll delete the files locally now
        await this.deleteFilesLocally();
        // makes sure files are deleted before updating tracking files
        await this.maybeUpdateTracking();
        return result;
    }
    async preChecks() {
        if (this.flags['track-source']) {
            this.tracking = await source_tracking_1.SourceTracking.create({ org: this.org, project: this.project });
        }
    }
    async delete() {
        const sourcepaths = this.flags['source-dir'];
        this.componentSet = await source_deploy_retrieve_1.ComponentSetBuilder.build({
            apiversion: this.flags['api-version'],
            sourceapiversion: await (0, project_1.getSourceApiVersion)(),
            sourcepath: sourcepaths,
            metadata: this.flags.metadata
                ? {
                    metadataEntries: this.flags.metadata,
                    directoryPaths: await (0, project_1.getPackageDirs)(),
                }
                : undefined,
        });
        if (this.flags['track-source'] && !this.flags['force-overwrite']) {
            await this.filterConflictsByComponentSet();
        }
        this.components = this.componentSet.toArray();
        if (!this.components.length) {
            // if we didn't find any components to delete, let the user know and exit
            this.styledHeader(chalk.blue('Deleted Source'));
            this.log('No results found');
            return;
        }
        // create a new ComponentSet and mark everything for deletion
        const cs = new source_deploy_retrieve_1.ComponentSet([]);
        cs.apiVersion =
            this.componentSet.apiVersion ?? this.flags['api-version'] ?? (await this.org.retrieveMaxApiVersion());
        cs.sourceApiVersion =
            this.componentSet.sourceApiVersion ?? this.flags['api-version'] ?? (await (0, project_1.getSourceApiVersion)());
        this.components.map((component) => {
            if (component instanceof source_deploy_retrieve_1.SourceComponent) {
                cs.add(component, source_deploy_retrieve_1.DestructiveChangesType.POST);
            }
            else {
                // a remote-only delete
                cs.add(new source_deploy_retrieve_1.SourceComponent({ name: component.fullName, type: component.type }), source_deploy_retrieve_1.DestructiveChangesType.POST);
            }
        });
        this.componentSet = cs;
        if (sourcepaths) {
            // determine if user is trying to delete a single file from a bundle, which is actually just an fs delete operation
            // and then a constructive deploy on the "new" bundle
            this.components
                .filter((comp) => comp.type.strategies?.adapter === 'bundle')
                .filter(types_1.isSourceComponent)
                .map((bundle) => {
                sourcepaths.map(async (sourcepath) => {
                    // walkContent returns absolute paths while sourcepath will usually be relative
                    if (bundle.walkContent().find((content) => content.endsWith(sourcepath))) {
                        await this.moveBundleToManifest(bundle, sourcepath);
                    }
                });
            });
        }
        this.aborted = !(await this.handlePrompt());
        if (this.aborted)
            return;
        // fire predeploy event for the delete
        await core_1.Lifecycle.getInstance().emit('predeploy', this.components);
        this.isRest = (await (0, deploy_1.resolveApi)()) === 'REST';
        this.log(`*** Deleting with ${this.isRest ? 'REST' : 'SOAP'} API ***`);
        const deploy = await this.componentSet.deploy({
            usernameOrConnection: this.org.getUsername(),
            apiOptions: {
                rest: this.isRest,
                checkOnly: this.flags['check-only'] ?? false,
                testLevel: this.flags['test-level'],
            },
        });
        new progressBar_1.DeployProgress(deploy, this.jsonEnabled()).start();
        this.deployResult = await deploy.pollStatus({ timeout: this.flags.wait });
        if (!deploy.id) {
            throw new core_1.SfError('The deploy id is not available.');
        }
        await deployCache_1.DeployCache.update(deploy.id, { status: this.deployResult.response.status });
        await core_1.Lifecycle.getInstance().emit('postdeploy', this.deployResult);
        // result.getFileResponses() will crawl the tree, but that would throw after the delete occurs.
        // Extract them here for updateTracking to use later
        this.fileResponses = this.mixedDeployDelete.delete.length
            ? this.mixedDeployDelete.delete
            : this.deployResult.getFileResponses();
    }
    /**
     * Checks the response status to determine whether the delete was successful.
     */
    async resolveSuccess() {
        const status = this.deployResult?.response?.status;
        if (status !== source_deploy_retrieve_1.RequestStatus.Succeeded && !this.aborted) {
            process.exitCode = 1;
        }
        // if deploy failed OR the operation was cancelled, restore the stashed files if they exist
        else if (status !== source_deploy_retrieve_1.RequestStatus.Succeeded || this.aborted) {
            await Promise.all(this.mixedDeployDelete.delete.map(async (file) => {
                await this.restoreFileFromStash(file.filePath);
            }));
        }
        else if (this.mixedDeployDelete.delete.length) {
            // successful delete -> delete the stashed file
            await this.deleteStash();
        }
    }
    formatResult() {
        const formatterOptions = {
            verbose: this.flags.verbose ?? false,
        };
        this.deleteResultFormatter = this.mixedDeployDelete.deploy.length
            ? new deployResultFormatter_1.DeployResultFormatter(this.deployResult, formatterOptions)
            : new deleteResultFormatter_1.DeleteResultFormatter(this.deployResult);
        // Only display results to console when JSON flag is unset.
        if (!this.jsonEnabled()) {
            this.deleteResultFormatter.display();
        }
        if (this.mixedDeployDelete.deploy.length && !this.aborted) {
            // override JSON output when we actually deployed
            const json = this.deleteResultFormatter.getJson();
            json.deletedSource = this.mixedDeployDelete.delete; // to match toolbelt json output
            json.outboundFiles = []; // to match toolbelt version
            json.deletes = json.deploys; // to match toolbelt version
            delete json.deploys;
            return json;
        }
        if (this.aborted) {
            return {
                status: 0,
                result: {
                    deletedSource: [],
                    deletes: [{}],
                    outboundFiles: [],
                },
            };
        }
        return this.deleteResultFormatter.getJson();
    }
    async maybeUpdateTracking() {
        if (this.flags['track-source'] ?? false) {
            // might not exist if we exited from the operation early
            if (!this.deployResult) {
                return;
            }
            this.spinner.start('Updating source tracking');
            const successes = (this.fileResponses ?? this.deployResult.getFileResponses()).filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Failed);
            if (!successes.length) {
                this.spinner.stop();
                return;
            }
            await Promise.all([
                this.tracking?.updateLocalTracking({
                    files: successes
                        .filter((fileResponse) => fileResponse.state !== source_deploy_retrieve_1.ComponentStatus.Deleted)
                        .map((fileResponse) => fileResponse.filePath),
                    deletedFiles: successes
                        .filter((fileResponse) => fileResponse.state === source_deploy_retrieve_1.ComponentStatus.Deleted)
                        .map((fileResponse) => fileResponse.filePath),
                }),
                this.tracking?.updateRemoteTracking(successes.map(({ state, fullName, type, filePath }) => ({ state, fullName, type, filePath }))),
            ]);
            this.spinner.stop();
        }
    }
    async deleteFilesLocally() {
        if (!this.flags['check-only'] && this.deployResult?.response?.status === source_deploy_retrieve_1.RequestStatus.Succeeded) {
            const promises = [];
            this.components?.filter(types_1.isSourceComponent).map((component) => {
                // mixed delete/deploy operations have already been deleted and stashed
                if (!this.mixedDeployDelete.delete.length) {
                    if (component.content) {
                        const stats = fs.statSync(component.content);
                        if (stats.isDirectory()) {
                            promises.push(fsPromises.rm(component.content, { recursive: true }));
                        }
                        else {
                            promises.push(fsPromises.unlink(component.content));
                        }
                    }
                    if (component.xml) {
                        promises.push(fsPromises.unlink(component.xml));
                    }
                }
            });
            await Promise.all(promises);
        }
    }
    async moveFileToStash(file) {
        await fsPromises.mkdir(path.dirname(this.stashPath.get(file)), { recursive: true });
        await fsPromises.copyFile(file, this.stashPath.get(file));
        await fsPromises.unlink(file);
    }
    async restoreFileFromStash(file) {
        await fsPromises.rename(this.stashPath.get(file), file);
    }
    async deleteStash() {
        await fsPromises.rm(this.tempDir, { recursive: true, force: true });
    }
    async moveBundleToManifest(bundle, sourcepath) {
        // if one of the passed in sourcepaths is to a bundle component
        const fileName = path.basename(sourcepath);
        const fullName = path.join(bundle.name, fileName);
        this.mixedDeployDelete.delete.push({
            state: source_deploy_retrieve_1.ComponentStatus.Deleted,
            fullName,
            type: bundle.type.name,
            filePath: sourcepath,
        });
        // stash the file in case we need to restore it due to failed deploy/aborted command
        this.stashPath.set(sourcepath, path.join(this.tempDir, fullName));
        await this.moveFileToStash(sourcepath);
        // re-walk the directory to avoid picking up the deleted file
        this.mixedDeployDelete.deploy.push(...bundle.walkContent());
        // now remove the bundle from destructive changes and add to manifest
        // set the bundle as NOT marked for delete
        this.componentSet.destructiveChangesPost.delete(`${bundle.type.id}#${bundle.fullName}`);
        bundle.setMarkedForDelete(false);
        this.componentSet.add(bundle);
    }
    async handlePrompt() {
        if (!this.flags['no-prompt']) {
            const remote = [];
            let local = [];
            const message = [];
            this.components?.flatMap((component) => {
                if (component instanceof source_deploy_retrieve_1.SourceComponent) {
                    local.push(component.xml, ...component.walkContent());
                }
                else {
                    // remote only metadata
                    remote.push(`${component.type.name}:${component.fullName}`);
                }
            });
            if (this.mixedDeployDelete.delete.length) {
                local = this.mixedDeployDelete.delete.map((fr) => fr.fullName);
            }
            if (this.mixedDeployDelete.deploy.length) {
                message.push(messages.getMessage('deployPrompt', [[...new Set(this.mixedDeployDelete.deploy)].join('\n')]));
            }
            if (remote.length) {
                message.push(messages.getMessage('remotePrompt', [[...new Set(remote)].join('\n')]));
            }
            if (local.length) {
                if (message.length) {
                    // add a whitespace between remote and local
                    message.push('\n');
                }
                message.push('\n', messages.getMessage('localPrompt', [[...new Set(local)].join('\n')]));
            }
            message.push(this.flags['check-only'] ?? false
                ? messages.getMessage('areYouSureCheckOnly')
                : messages.getMessage('areYouSure'));
            return this.confirm(message.join('\n'));
        }
        return true;
    }
}
exports.Source = Source;
Source.summary = messages.getMessage('summary');
Source.description = messages.getMessage('description');
Source.examples = messages.getMessages('examples');
Source.aliases = ['force:source:delete'];
Source.deprecateAliases = true;
Source.requiresProject = true;
Source.flags = {
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'check-only': sf_plugins_core_1.Flags.boolean({
        aliases: ['checkonly'],
        deprecateAliases: true,
        char: 'c',
        description: messages.getMessage('flags.check-only.description'),
        summary: messages.getMessage('flags.check-only.summary'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        default: kit_1.Duration.minutes(33),
        min: 1,
        description: messages.getMessage('flags.wait.description'),
        summary: messages.getMessage('flags.wait.summary'),
    }),
    'test-level': (0, flags_1.testLevelFlag)({
        aliases: ['testlevel'],
        deprecateAliases: true,
        description: messages.getMessage('flags.test-Level.description'),
        summary: messages.getMessage('flags.test-Level.summary'),
        options: ['NoTestRun', 'RunLocalTests', 'RunAllTestsInOrg'],
        default: types_1.TestLevel.NoTestRun,
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        char: 'r',
        aliases: ['noprompt'],
        deprecateAliases: true,
        summary: messages.getMessage('flags.no-prompt.summary'),
    }),
    metadata: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'm',
        description: messages.getMessage('flags.metadata.description'),
        summary: messages.getMessage('flags.metadata.summary'),
        exactlyOne: xorFlags,
    }),
    'source-dir': (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'p',
        aliases: ['sourcepath'],
        deprecateAliases: true,
        description: messages.getMessage('flags.source-dir.description'),
        summary: messages.getMessage('flags.source-dir.summary'),
        exactlyOne: xorFlags,
    }),
    'track-source': sf_plugins_core_1.Flags.boolean({
        char: 't',
        aliases: ['tracksource'],
        deprecateAliases: true,
        summary: messages.getMessage('flags.track-source.summary'),
        exclusive: ['check-only'],
    }),
    'force-overwrite': sf_plugins_core_1.Flags.boolean({
        char: 'f',
        aliases: ['forceoverwrite'],
        deprecateAliases: true,
        summary: messages.getMessage('flags.force-overwrite.summary'),
        dependsOn: ['track-source'],
    }),
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
};
//# sourceMappingURL=source.js.map