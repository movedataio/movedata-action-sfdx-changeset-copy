"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Set = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const config_1 = require("../../config");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-settings', 'config.set');
class Set extends config_1.ConfigCommand {
    constructor() {
        super(...arguments);
        this.setResponses = { successes: [], failures: [] };
    }
    async run() {
        const { args, argv, flags } = await this.parse(Set);
        const config = await loadConfig(flags.global);
        if (!argv.length)
            throw messages.createError('error.ArgumentsRequired');
        const parsed = (0, sf_plugins_core_1.parseVarArgs)(args, argv);
        for (const name of Object.keys(parsed)) {
            const value = parsed[name];
            try {
                if (!value) {
                    // Push a failure if users are try to unset a value with `set=`.
                    this.pushFailure(name, messages.createError('error.ValueRequired'), value);
                }
                else {
                    // core's builtin config validation requires synchronous functions but there's
                    // currently no way to validate an org synchronously. Therefore, we have to manually
                    // validate the org here and manually set the error message if it fails
                    // eslint-disable-next-line no-await-in-loop
                    if (isOrgKey(name) && value)
                        await validateOrg(value);
                    config.set(name, value);
                    this.setResponses.successes.push({ name, value, success: true });
                }
            }
            catch (err) {
                const error = err;
                if (error.name === 'DeprecatedConfigKeyError') {
                    const newKey = core_1.Config.getPropertyConfigMeta(name)?.key ?? name;
                    try {
                        config.set(newKey, value);
                        this.setResponses.successes.push({
                            name,
                            value,
                            success: true,
                            error,
                            message: error.message.replace(/\.\.$/, '.'),
                        });
                    }
                    catch (e) {
                        const secondError = e;
                        // if that deprecated value was also set to an invalid value
                        this.setResponses.failures.push({
                            name,
                            key: name,
                            success: false,
                            value,
                            error: secondError,
                            message: secondError.message.replace(/\.\.$/, '.'),
                        });
                    }
                }
                else if (error.name.includes('UnknownConfigKeyError')) {
                    if (this.jsonEnabled()) {
                        process.exitCode = 1;
                        this.setResponses.failures.push({
                            name,
                            value,
                            success: false,
                            error,
                            message: error.message.replace(/\.\.$/, '.'),
                        });
                    }
                    else {
                        const suggestion = this.calculateSuggestion(name);
                        // eslint-disable-next-line no-await-in-loop
                        const answer = (await this.confirm(messages.getMessage('didYouMean', [suggestion]), 10 * 1000)) ?? false;
                        if (answer) {
                            const key = core_1.Config.getPropertyConfigMeta(suggestion)?.key ?? suggestion;
                            config.set(key, value);
                            this.setResponses.successes.push({ name: key, value, success: true });
                        }
                    }
                }
                else {
                    this.pushFailure(name, err, value);
                }
            }
        }
        await config.write();
        if (!this.jsonEnabled()) {
            this.responses = [...this.setResponses.successes, ...this.setResponses.failures];
            this.output('Set Config', false);
        }
        return this.setResponses;
    }
    pushFailure(name, err, value) {
        const error = core_1.SfError.wrap(err);
        this.setResponses.failures.push({
            name,
            success: false,
            value,
            error,
            message: error.message.replace(/\.\.$/, '.'),
        });
        process.exitCode = 1;
    }
}
exports.Set = Set;
Set.description = messages.getMessage('description');
Set.summary = messages.getMessage('summary');
Set.examples = messages.getMessages('examples');
Set.aliases = ['force:config:set'];
Set.deprecateAliases = true;
Set.strict = false;
Set.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    global: sf_plugins_core_1.Flags.boolean({
        char: 'g',
        summary: messages.getMessage('flags.global.summary'),
    }),
};
Set.configurationVariablesSection = config_1.CONFIG_HELP_SECTION;
const loadConfig = async (global) => {
    try {
        await core_1.SfdxConfigAggregator.create({});
        const config = await core_1.Config.create(core_1.Config.getDefaultOptions(global));
        await config.read();
        return config;
    }
    catch (error) {
        if (error instanceof core_1.SfError) {
            error.actions = error.actions ?? [];
            error.actions.push('Run with --global to set for your entire workspace.');
        }
        throw error;
    }
};
const isOrgKey = (name) => [core_1.OrgConfigProperties.TARGET_DEV_HUB, core_1.OrgConfigProperties.TARGET_ORG].includes(name);
const validateOrg = async (value) => {
    try {
        await core_1.Org.create({ aliasOrUsername: value });
    }
    catch {
        throw new Error(`Invalid config value: org "${value}" is not authenticated.`);
    }
};
//# sourceMappingURL=set.js.map