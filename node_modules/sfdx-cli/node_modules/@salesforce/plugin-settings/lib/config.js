"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigCommand = exports.CONFIG_HELP_SECTION = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const sf_plugins_core_2 = require("@salesforce/sf-plugins-core");
const Levenshtein = require("fast-levenshtein");
exports.CONFIG_HELP_SECTION = (0, sf_plugins_core_2.toHelpSection)('CONFIGURATION VARIABLES', ...new Set(core_1.Config.getAllowedProperties().map((k) => k.newKey ?? k.key)));
class ConfigCommand extends sf_plugins_core_1.SfCommand {
    constructor() {
        super(...arguments);
        this.responses = [];
    }
    // eslint-disable-next-line class-methods-use-this
    calculateSuggestion(userEnteredConfig) {
        // we'll use this array to keep track of which key is the closest to the users entered value.
        // keys closer to the index 0 will be a closer guess than keys indexed further from 0
        // an entry at 0 would be a direct match, an entry at 1 would be a single character off, etc.
        const index = [];
        core_1.Config.getAllowedProperties()
            .map((k) => k.newKey ?? k.key)
            .map((k) => (index[Levenshtein.get(userEnteredConfig, k)] = k));
        return index.find((item) => item !== undefined) ?? '';
    }
    pushSuccess(configInfo) {
        this.responses.push({
            name: configInfo.key,
            key: configInfo.key,
            value: configInfo.value,
            success: true,
            location: configInfo.location,
        });
    }
    pushFailure(name, err, value) {
        const error = core_1.SfError.wrap(err);
        this.responses.push({
            name,
            success: false,
            value,
            error,
            message: error.message.replace(/\.\.$/, '.'),
        });
        process.exitCode = 1;
    }
    output(title, verbose) {
        if (this.responses.length === 0) {
            this.log('No results found');
            return;
        }
        const columns = {
            name: { header: 'Name' },
        };
        if (!title.includes('Unset')) {
            columns.value = {
                header: 'Value',
                get: (row) => row.value ?? '',
            };
        }
        if (!title.includes('List')) {
            columns.success = { header: 'Success' };
        }
        if (verbose) {
            columns.location = {
                header: 'Location',
                get: (row) => row.location ?? '',
            };
        }
        if (this.responses.some((msg) => msg.error)) {
            columns.message = {
                header: 'Message',
                get: (row) => row.message ?? '',
            };
            this.responses.map((msg) => (msg.message = msg.error?.message));
        }
        this.table(this.responses, columns, { title });
    }
}
exports.ConfigCommand = ConfigCommand;
//# sourceMappingURL=config.js.map