import { AnyJson, KeyValue } from '@salesforce/ts-types';
import { Interfaces } from '@oclif/core';
import { PluginVersionDetail } from '@oclif/core/lib/interfaces';
import { DiagnosticStatus } from './diagnostics';
export interface SfDoctor {
    addCommandName(commandName: string): void;
    addDiagnosticStatus(status: DiagnosticStatus): void;
    addPluginData(pluginName: string, data: AnyJson): void;
    addSuggestion(suggestion: string): void;
    closeStderr(): void;
    closeStdout(): void;
    createStderrWriteStream(fullPath: string): void;
    createStdoutWriteStream(fullPath: string): void;
    diagnose(): Array<Promise<void>>;
    getDiagnosis(): SfDoctorDiagnosis;
    getDoctoredFilePath(filePath: string): string;
    setExitCode(code: string | number): void;
    writeFileSync(filePath: string, contents: string): string;
    writeStderr(contents: string): Promise<boolean>;
    writeStdout(contents: string): Promise<boolean>;
}
type CliConfig = Partial<Interfaces.Config> & {
    nodeEngine: string;
};
export interface SfDoctorDiagnosis {
    versionDetail: Omit<Interfaces.VersionDetails, 'pluginVersions'> & {
        pluginVersions: string[];
    };
    sfdxEnvVars: Array<KeyValue<string>>;
    sfEnvVars: Array<KeyValue<string>>;
    cliConfig: CliConfig;
    pluginSpecificData: {
        [pluginName: string]: AnyJson[];
    };
    diagnosticResults: DiagnosticStatus[];
    suggestions: string[];
    commandName?: string;
    commandExitCode?: string | number;
    logFilePaths: string[];
}
export declare class Doctor implements SfDoctor {
    private static instance;
    readonly id: number;
    private diagnosis;
    private stdoutWriteStream;
    private stderrWriteStream;
    private constructor();
    /**
     * Returns a singleton instance of an SfDoctor.
     */
    static getInstance(): SfDoctor;
    /**
     * Returns true if Doctor has been initialized.
     */
    static isDoctorEnabled(): boolean;
    /**
     * Initializes a new instance of SfDoctor with CLI config data.
     *
     * @param config The oclif config for the CLI
     * @param versionDetail The result of running a verbose version command
     * @returns An instance of SfDoctor
     */
    static init(config: Interfaces.Config): SfDoctor;
    /**
     * Use the gathered data to discover potential problems by running all diagnostics.
     *
     * @returns An array of diagnostic promises.
     */
    diagnose(): Array<Promise<void>>;
    /**
     * Add a suggestion in the form of:
     * "Because of <this data point> we recommend to <suggestion>"
     *
     * @param suggestion A suggestion for the CLI user to try based on gathered data
     */
    addSuggestion(suggestion: string): void;
    /**
     * Add a diagnostic test status.
     *
     * @param status a diagnostic test status
     */
    addDiagnosticStatus(status: DiagnosticStatus): void;
    /**
     * Add diagnostic data that is specific to the passed plugin name.
     *
     * @param pluginName The name in the plugin's package.json
     * @param data Any data to add to the doctor diagnosis that is specific
     * to the plugin and a valid JSON value.
     */
    addPluginData(pluginName: string, data: AnyJson): void;
    /**
     * Add a command name that the doctor will run to the diagnosis data for
     * use by diagnostics.
     *
     * @param commandName The name of the command that the doctor will run. E.g., "force:org:list"
     */
    addCommandName(commandName: string): void;
    /**
     * Returns all the data gathered, paths to doctor files, and recommendations.
     */
    getDiagnosis(): SfDoctorDiagnosis;
    /**
     * Write a file with the provided path. The file name will be prepended
     * with this doctor's id.
     *
     * E.g., `name = myContent.json` will write `1658350735579-myContent.json`
     *
     * @param filePath The path of the file to write.
     * @param contents The string contents to write.
     * @return The full path to the file.
     */
    writeFileSync(filePath: string, contents: string): string;
    writeStdout(contents: string): Promise<boolean>;
    writeStderr(contents: string): Promise<boolean>;
    createStdoutWriteStream(fullPath: string): void;
    createStderrWriteStream(fullPath: string): void;
    closeStderr(): void;
    closeStdout(): void;
    getDoctoredFilePath(filePath: string): string;
    setExitCode(code: string | number): void;
    private writeFile;
    private createOutputDir;
}
export declare function formatPlugins(config: Interfaces.Config, plugins: Record<string, PluginVersionDetail>): string[];
export {};
