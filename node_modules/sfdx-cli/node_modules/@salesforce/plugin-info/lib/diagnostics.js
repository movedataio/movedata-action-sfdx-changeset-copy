"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Diagnostics = void 0;
const childProcess = require("child_process");
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-info', 'diagnostics');
/**
 * Diagnostics are all the tests that ensure a known, clean CLI configuration
 * and a way to run them asynchronously. Typically this is used only by the
 * Doctor class.
 *
 * Create a new diagnostic test by adding a method to the `Diagnostics` class,
 * appending "Check" to the name. Emit a "Doctor:diagnostic" event with a
 * `DiagnosticStatus` payload so the CLI can report on the diagnostic result.
 */
class Diagnostics {
    constructor(doctor, config) {
        this.doctor = doctor;
        this.config = config;
        this.diagnosis = doctor.getDiagnosis();
    }
    /**
     * Run all diagnostics using the data gathered by the doctor and add
     * suggestions to the diagnosis.
     */
    run() {
        const keys = Reflect.ownKeys(Diagnostics.prototype);
        return keys.filter((key) => key.endsWith('Check')).map((diagnostic) => this[diagnostic]());
    }
    // **********************************************************
    //                 D I A G N O S T I C S
    //
    // NOTE: Diagnostic function names must end with "Check"
    //       or they will not be run with all diagnostics.
    //
    // **********************************************************
    /**
     * Checks to see if the running version of the CLI is the latest.
     */
    async outdatedCliVersionCheck() {
        const cliName = this.config.name;
        const cliVersion = this.config.version;
        return new Promise((resolve) => {
            const testName = 'using latest or latest-rc CLI version';
            let status = 'unknown';
            childProcess.exec(`npm view ${cliName} dist-tags.latest`, {}, (error, stdout, stderr) => {
                const code = error?.code ?? 0;
                if (code === 0) {
                    const latest = stdout.trim();
                    if (cliVersion < latest) {
                        status = 'fail';
                        this.doctor.addSuggestion(messages.getMessage('updateCliVersion', [cliVersion, latest]));
                    }
                    else {
                        status = 'pass';
                    }
                }
                else {
                    this.doctor.addSuggestion(messages.getMessage('latestCliVersionError', [stderr]));
                }
                void core_1.Lifecycle.getInstance()
                    .emit('Doctor:diagnostic', { testName, status })
                    .then(() => resolve());
            });
        });
    }
    /**
     * Checks if the salesforcedx plugin is installed and suggests
     * to uninstall it if there.
     */
    async salesforceDxPluginCheck() {
        const testName = 'salesforcedx plugin not installed';
        let status = 'pass';
        const plugins = Object.keys(this.config.versionDetails.pluginVersions ?? {});
        if (plugins?.some((p) => p === 'salesforcedx')) {
            status = 'fail';
            const bin = this.diagnosis.cliConfig.bin;
            this.doctor.addSuggestion(messages.getMessage('salesforceDxPluginDetected', [bin]));
        }
        await core_1.Lifecycle.getInstance().emit('Doctor:diagnostic', { testName, status });
    }
    /**
     * Checks and warns if any plugins are linked.
     */
    async linkedPluginCheck() {
        const testName = 'no linked plugins';
        let status = 'pass';
        const plugins = this.config.plugins;
        const linkedPlugins = plugins.filter((p) => p.type === 'link');
        linkedPlugins.forEach((lp) => {
            status = 'fail';
            this.doctor.addSuggestion(messages.getMessage('linkedPluginWarning', [lp.name]));
        });
        await core_1.Lifecycle.getInstance().emit('Doctor:diagnostic', { testName, status });
    }
}
exports.Diagnostics = Diagnostics;
//# sourceMappingURL=diagnostics.js.map