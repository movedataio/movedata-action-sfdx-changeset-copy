"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatPlugins = exports.Doctor = void 0;
const fs = require("fs");
const path = require("path");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const diagnostics_1 = require("./diagnostics");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-info', 'doctor');
const PINNED_SUGGESTIONS = [
    messages.getMessage('pinnedSuggestions.checkGitHubIssues'),
    messages.getMessage('pinnedSuggestions.checkSfdcStatus'),
];
// private config from the CLI
// eslint-disable-next-line no-underscore-dangle
let __cliConfig;
class Doctor {
    constructor(config) {
        this.id = Date.now();
        __cliConfig = config;
        const sfdxEnvVars = new kit_1.Env().entries().filter((e) => e[0].startsWith('SFDX_'));
        const sfEnvVars = new kit_1.Env().entries().filter((e) => e[0].startsWith('SF_'));
        const cliConfig = (0, kit_1.omit)(config, ['plugins', 'pjson', 'userPJSON', 'options']);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        cliConfig.nodeEngine = config.pjson.engines.node;
        const { pluginVersions, ...versionDetails } = config.versionDetails;
        this.diagnosis = {
            versionDetail: { ...versionDetails, pluginVersions: formatPlugins(config, pluginVersions ?? {}) },
            sfdxEnvVars,
            sfEnvVars,
            cliConfig,
            pluginSpecificData: {},
            diagnosticResults: [],
            suggestions: [...PINNED_SUGGESTIONS],
            logFilePaths: [],
            commandExitCode: 0,
        };
    }
    /**
     * Returns a singleton instance of an SfDoctor.
     */
    static getInstance() {
        if (!Doctor.instance) {
            throw new core_1.SfError(messages.getMessage('doctorNotInitializedError'), 'SfDoctorInitError');
        }
        return Doctor.instance;
    }
    /**
     * Returns true if Doctor has been initialized.
     */
    static isDoctorEnabled() {
        return !!Doctor.instance;
    }
    /**
     * Initializes a new instance of SfDoctor with CLI config data.
     *
     * @param config The oclif config for the CLI
     * @param versionDetail The result of running a verbose version command
     * @returns An instance of SfDoctor
     */
    static init(config) {
        if (Doctor.instance) {
            throw new core_1.SfError(messages.getMessage('doctorAlreadyInitializedError'), 'SfDoctorInitError');
        }
        Doctor.instance = new this(config);
        return Doctor.instance;
    }
    /**
     * Use the gathered data to discover potential problems by running all diagnostics.
     *
     * @returns An array of diagnostic promises.
     */
    diagnose() {
        return new diagnostics_1.Diagnostics(this, __cliConfig).run();
    }
    /**
     * Add a suggestion in the form of:
     * "Because of <this data point> we recommend to <suggestion>"
     *
     * @param suggestion A suggestion for the CLI user to try based on gathered data
     */
    addSuggestion(suggestion) {
        this.diagnosis.suggestions.push(suggestion);
    }
    /**
     * Add a diagnostic test status.
     *
     * @param status a diagnostic test status
     */
    addDiagnosticStatus(status) {
        this.diagnosis.diagnosticResults.push(status);
    }
    /**
     * Add diagnostic data that is specific to the passed plugin name.
     *
     * @param pluginName The name in the plugin's package.json
     * @param data Any data to add to the doctor diagnosis that is specific
     * to the plugin and a valid JSON value.
     */
    addPluginData(pluginName, data) {
        const pluginEntry = this.diagnosis.pluginSpecificData[pluginName];
        if (pluginEntry) {
            pluginEntry.push(data);
        }
        else {
            this.diagnosis.pluginSpecificData[pluginName] = [data];
        }
    }
    /**
     * Add a command name that the doctor will run to the diagnosis data for
     * use by diagnostics.
     *
     * @param commandName The name of the command that the doctor will run. E.g., "force:org:list"
     */
    addCommandName(commandName) {
        this.diagnosis.commandName = commandName;
    }
    /**
     * Returns all the data gathered, paths to doctor files, and recommendations.
     */
    getDiagnosis() {
        return { ...this.diagnosis };
    }
    /**
     * Write a file with the provided path. The file name will be prepended
     * with this doctor's id.
     *
     * E.g., `name = myContent.json` will write `1658350735579-myContent.json`
     *
     * @param filePath The path of the file to write.
     * @param contents The string contents to write.
     * @return The full path to the file.
     */
    writeFileSync(filePath, contents) {
        const fullPath = this.getDoctoredFilePath(filePath);
        this.createOutputDir(fullPath);
        this.diagnosis.logFilePaths.push(fullPath);
        fs.writeFileSync(fullPath, contents);
        return fullPath;
    }
    writeStdout(contents) {
        if (!this.stdoutWriteStream) {
            throw new core_1.SfError(messages.getMessage('doctorNotInitializedError'), 'SfDoctorInitError');
        }
        return this.writeFile(this.stdoutWriteStream, contents);
    }
    writeStderr(contents) {
        if (!this.stderrWriteStream) {
            throw new core_1.SfError(messages.getMessage('doctorNotInitializedError'), 'SfDoctorInitError');
        }
        return this.writeFile(this.stderrWriteStream, contents);
    }
    createStdoutWriteStream(fullPath) {
        if (!this.stdoutWriteStream) {
            this.createOutputDir(fullPath);
            this.stdoutWriteStream = fs.createWriteStream(fullPath);
        }
    }
    createStderrWriteStream(fullPath) {
        if (!this.stderrWriteStream) {
            this.createOutputDir(fullPath);
            this.stderrWriteStream = fs.createWriteStream(path.join(fullPath));
        }
    }
    closeStderr() {
        this.stderrWriteStream?.end();
        this.stderrWriteStream?.close();
    }
    closeStdout() {
        this.stdoutWriteStream?.end();
        this.stdoutWriteStream?.close();
    }
    getDoctoredFilePath(filePath) {
        const dir = path.dirname(filePath);
        const fileName = `${this.id}-${path.basename(filePath)}`;
        const fullPath = path.join(dir, fileName);
        this.diagnosis.logFilePaths.push(fullPath);
        return fullPath;
    }
    setExitCode(code) {
        this.diagnosis.commandExitCode = code;
    }
    // eslint-disable-next-line class-methods-use-this
    writeFile(stream, contents) {
        return Promise.resolve(stream.write(contents));
    }
    // eslint-disable-next-line class-methods-use-this
    createOutputDir(fullPath) {
        const dir = path.dirname(fullPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    }
}
exports.Doctor = Doctor;
function formatPlugins(config, plugins) {
    function getFriendlyName(name) {
        const scope = config?.pjson?.oclif?.scope;
        if (!scope)
            return name;
        const match = name.match(`@${scope}/plugin-(.+)`);
        if (!match)
            return name;
        return match[1];
    }
    return Object.entries(plugins)
        .map(([name, plugin]) => ({ name, ...plugin }))
        .sort((a, b) => (a.name > b.name ? 1 : -1))
        .map((plugin) => `${getFriendlyName(plugin.name)} ${plugin.version} (${plugin.type}) ${plugin.type === 'link' ? plugin.root : ''}`.trim());
}
exports.formatPlugins = formatPlugins;
//# sourceMappingURL=doctor.js.map