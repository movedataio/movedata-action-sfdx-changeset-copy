"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const child_process_1 = require("child_process");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const open = require("open");
const got_1 = require("got");
const ProxyAgent = require("proxy-agent");
const proxy_from_env_1 = require("proxy-from-env");
const doctor_1 = require("../doctor");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-info', 'doctor');
class Doctor extends sf_plugins_core_1.SfCommand {
    constructor() {
        super(...arguments);
        // Array of promises that are various doctor tasks to perform
        // such as running a command and running diagnostics.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.tasks = [];
        this.outputDir = process.cwd();
        this.filesWrittenMsgs = [];
    }
    async run() {
        const { flags } = await this.parse(Doctor);
        this.doctor = doctor_1.Doctor.getInstance();
        const lifecycle = core_1.Lifecycle.getInstance();
        this.outputDir = path.resolve(flags['output-dir'] ?? process.cwd());
        // eslint-disable-next-line @typescript-eslint/require-await
        lifecycle.on('Doctor:diagnostic', async (data) => {
            this.log(`${data.status} - ${data.testName}`);
            this.doctor.addDiagnosticStatus(data);
        });
        if (flags.command) {
            this.setupCommandExecution(flags.command);
        }
        if (flags.plugin) {
            // verify the plugin flag matches an installed plugin
            const plugin = this.config.plugins.find((p) => p.name === flags.plugin);
            if (plugin) {
                const eventName = `sf-doctor-${flags.plugin}`;
                const hasDoctorHook = plugin.hooks && Object.keys(plugin.hooks).some((hook) => hook === eventName);
                if (hasDoctorHook) {
                    this.styledHeader(`Running diagnostics for plugin: ${flags.plugin}`);
                    this.tasks.push(this.config.runHook(eventName, { doctor: this.doctor }));
                }
                else {
                    this.log(`${flags.plugin} doesn't have diagnostic tests to run.`);
                }
            }
            else {
                throw new core_1.SfError(messages.getMessage('pluginNotInstalledError', [flags.plugin]), 'UnknownPluginError');
            }
        }
        else {
            this.styledHeader('Running all diagnostics');
            // Fire events for plugins that have sf-doctor hooks
            this.config.plugins.forEach((plugin) => {
                const eventName = `sf-doctor-${plugin.name}`;
                if (plugin.hooks && Object.keys(plugin.hooks).find((hook) => hook === eventName)) {
                    this.tasks.push(this.config.runHook(eventName, { doctor: this.doctor }));
                }
            });
            this.tasks = [...this.tasks, ...this.doctor.diagnose()];
        }
        await Promise.all(this.tasks);
        const diagnosis = this.doctor.getDiagnosis();
        const diagnosisLocation = this.doctor.writeFileSync(path.join(this.outputDir, 'diagnosis.json'), JSON.stringify(diagnosis, null, 2));
        this.filesWrittenMsgs.push(`Wrote doctor diagnosis to: ${diagnosisLocation}`);
        this.log();
        this.filesWrittenMsgs.forEach((msg) => this.log(msg));
        this.log();
        this.styledHeader('Suggestions');
        diagnosis.suggestions.forEach((s) => this.log(`  * ${s}`));
        if (flags['create-issue']) {
            const raw = 'https://raw.githubusercontent.com/forcedotcom/cli/main/.github/ISSUE_TEMPLATE/bug_report.md';
            const ghIssue = await (0, got_1.default)(raw, {
                throwHttpErrors: false,
                agent: { https: ProxyAgent((0, proxy_from_env_1.getProxyForUrl)(raw)) },
            });
            const title = (await this.prompt({
                type: 'input',
                name: 'title',
                message: 'Enter a title for your new issue',
            })).title;
            const url = encodeURI(`https://github.com/forcedotcom/cli/issues/new?title=${title}&body=${this.generateIssueMarkdown(ghIssue.body, diagnosis)}&labels=doctor,investigating,${this.config.bin}`);
            await this.openUrl(url);
        }
        return diagnosis;
    }
    /**
     * Only made into its own method for unit testing purposes
     *
     * @param url: url string to open
     */
    // eslint-disable-next-line class-methods-use-this
    async openUrl(url) {
        await open(url);
    }
    generateIssueMarkdown(body, diagnosis) {
        const info = `
\`\`\`
${diagnosis.cliConfig.userAgent}
${(diagnosis.versionDetail.pluginVersions ?? []).join(os.EOL)}
\`\`\`
${diagnosis.sfdxEnvVars.length
            ? `
\`\`\`
SFDX ENV. VARS.
${diagnosis.sfdxEnvVars.join(os.EOL)}
\`\`\`
`
            : ''}

${diagnosis.sfEnvVars.length
            ? `
\`\`\`
SF ENV. VARS.
${diagnosis.sfEnvVars.join(os.EOL)}
\`\`\`
`
            : ''}
\`\`\`
Windows: ${diagnosis.cliConfig.windows}
Shell: ${diagnosis.cliConfig.shell}
Channel: ${diagnosis.cliConfig.channel}
${diagnosis.cliConfig.userAgent}
\`\`\`
---
### Diagnostics
${this.doctor
            .getDiagnosis()
            .diagnosticResults.map((res) => `${res.status === 'pass' ? ':white_check_mark:' : ':x:'} ${res.status} - ${res.testName}`)
            .join(os.EOL)}
`;
        return body
            .replace(new RegExp(`---(.|${os.EOL})*---${os.EOL}${os.EOL}`), '')
            .replace(new RegExp(`${os.EOL}- Which shell/terminal (.|${os.EOL})*- Paste the output here`), info);
    }
    // Takes the command flag and:
    //   1. ensures it begins with `${config.bin}`; typically "sfdx" or "sf"
    //   2. ensures the `--dev-debug` flag is set
    parseCommand(command) {
        let fullCmd = command.trim();
        if (!fullCmd.startsWith(`${this.config.bin} `)) {
            fullCmd = `${this.config.bin} ${fullCmd}`;
        }
        if (!command.includes('--dev-debug')) {
            fullCmd += ' --dev-debug';
        }
        return fullCmd;
    }
    // Adds a promise to execute the provided command and all
    // parameters in debug mode, writing stdout and stderr to files
    // in the current or specified directory.
    setupCommandExecution(command) {
        const cmdString = this.parseCommand(command);
        this.styledHeader('Running command with debugging');
        this.log(`${cmdString}\n`);
        this.doctor.addCommandName(cmdString);
        const execPromise = new Promise((resolve) => {
            const stdoutLogLocation = this.doctor.getDoctoredFilePath(path.join(this.outputDir, 'command-stdout.log'));
            const debugLogLocation = this.doctor.getDoctoredFilePath(path.join(this.outputDir, 'command-debug.log'));
            this.doctor.createStdoutWriteStream(stdoutLogLocation);
            this.doctor.createStderrWriteStream(debugLogLocation);
            const cp = (0, child_process_1.spawn)(cmdString, [], { shell: true, env: Object.assign({}, process.env) });
            cp.on('error', (err) => {
                this.log(`Error executing command: ${err.message}`);
                // no-op
            });
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            cp.stdout.on('data', async (data) => {
                await this.doctor.writeStdout(data.toString());
            });
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            cp.stderr.on('data', async (data) => {
                await this.doctor.writeStderr(data.toString());
            });
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            cp.on('exit', async (code) => {
                this.doctor.setExitCode(code ?? 0);
                await this.doctor.writeStdout(`\nCommand exit code: ${code}\n`);
                this.doctor.closeStdout();
                this.doctor.closeStderr();
                this.filesWrittenMsgs.push(`Wrote command stdout log to: ${stdoutLogLocation}`);
                this.filesWrittenMsgs.push(`Wrote command debug log to: ${debugLogLocation}`);
                resolve();
            });
        });
        this.tasks.push(execPromise);
    }
}
exports.default = Doctor;
Doctor.summary = messages.getMessage('summary');
Doctor.description = messages.getMessage('description');
Doctor.examples = messages.getMessages('examples');
Doctor.flags = {
    command: sf_plugins_core_1.Flags.string({
        char: 'c',
        summary: messages.getMessage('flags.command'),
    }),
    plugin: sf_plugins_core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.plugin'),
    }),
    'output-dir': sf_plugins_core_1.Flags.directory({
        char: 'd',
        summary: messages.getMessage('flags.output-dir.summary'),
        aliases: ['outputdir', 'o'],
    }),
    'create-issue': sf_plugins_core_1.Flags.boolean({
        char: 'i',
        summary: messages.getMessage('flags.create-issue.summary'),
        default: false,
        aliases: ['createissue'],
    }),
    loglevel: sf_plugins_core_1.loglevel,
};
//# sourceMappingURL=doctor.js.map