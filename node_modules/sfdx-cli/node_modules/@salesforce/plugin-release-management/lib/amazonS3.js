"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmazonS3 = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const path = require("path");
const fs = require("fs");
const core_1 = require("@oclif/core");
const got_1 = require("got");
const core_2 = require("@salesforce/core");
const chalk = require("chalk");
const AWS = require("aws-sdk");
const packAndSign_1 = require("./codeSigning/packAndSign");
const BASE_URL = 'https://developer.salesforce.com';
const BUCKET = 'dfc-data-production';
class AmazonS3 {
    constructor(options) {
        this.options = options;
        this.directory = `https://developer.salesforce.com/media/salesforce-cli/${this.options.cli || ''}`;
        this.baseKey = this.directory.replace(BASE_URL, '').replace(/^\//, '');
        const agent = packAndSign_1.api.getAgentForUri('https://s3.amazonaws.com');
        this.s3 = new AWS.S3({
            ...this.resolveCredentials(),
            httpOptions: { agent: agent.http },
        });
    }
    // eslint-disable-next-line class-methods-use-this
    async ping() {
        const { statusCode } = await got_1.default.get(AmazonS3.STATUS_URL);
        return { service: 'Amazon S3', available: statusCode >= 200 && statusCode < 300 };
    }
    // eslint-disable-next-line class-methods-use-this
    async fileIsAvailable(url) {
        const { statusCode } = await got_1.default.get(url, { throwHttpErrors: false });
        return { service: 'file', name: url, available: statusCode >= 200 && statusCode < 300 };
    }
    // eslint-disable-next-line class-methods-use-this
    async download(url, location, silent = false) {
        const downloadStream = got_1.default.stream(url);
        const fileWriterStream = fs.createWriteStream(location);
        return new Promise((resolve) => {
            downloadStream.on('error', (error) => {
                if (!silent)
                    core_1.ux.error(`Download failed: ${error.message}`);
            });
            fileWriterStream
                .on('error', (error) => {
                if (!silent)
                    core_1.ux.action.stop('Failed');
                if (!silent)
                    core_1.ux.error(`Could not write file to system: ${error.message}`);
            })
                .on('finish', () => {
                if (!silent)
                    core_1.ux.action.stop();
                resolve();
            });
            if (!silent)
                core_1.ux.action.start(`Downloading ${chalk.cyan(url)}`);
            downloadStream.pipe(fileWriterStream);
        });
    }
    async getManifestFromChannel(channel) {
        const url = `${this.directory}/channels/${channel}/${this.options.cli}-darwin-x64-buildmanifest`;
        const filename = await this.getFileAtUrl(url);
        return JSON.parse(fs.readFileSync(filename, 'utf8'));
    }
    async getManifestFromVersion(version, sha) {
        const url = `${this.directory}/versions/${version}/${sha}/${this.options.cli}-v${version}-darwin-x64-buildmanifest`;
        const filename = await this.getFileAtUrl(url);
        return JSON.parse(fs.readFileSync(filename, 'utf8'));
    }
    async getFileAtUrl(url) {
        const availability = await this.fileIsAvailable(url);
        if (availability.available) {
            const filename = path.join(os.tmpdir(), `file${Math.random()}`);
            await this.download(url, filename, true);
            return filename;
        }
        else {
            throw new core_2.SfError(`File at url: ${url} does not exist`);
        }
    }
    async getObject(options) {
        options.Key = options.Key.replace(BASE_URL, '').replace(/^\//, '');
        const object = (await this.s3
            .getObject({ ...options, ...{ Bucket: this.options.bucket || BUCKET } })
            .promise());
        return object;
    }
    async listCommonPrefixes(key) {
        const prefix = key.startsWith(this.baseKey) ? key : `${this.baseKey}/${key}/`;
        const objects = await this.s3
            .listObjectsV2({ Bucket: this.options.bucket || BUCKET, Delimiter: '/', Prefix: prefix })
            .promise();
        return objects.CommonPrefixes;
    }
    async listKeyContents(key, filter = (entry) => !!entry) {
        const prefix = key.startsWith(this.baseKey) ? key : `${this.baseKey}/${key}/`;
        const objects = await this.s3
            .listObjectsV2({ Bucket: this.options.bucket || BUCKET, Delimiter: '/', Prefix: prefix })
            .promise();
        return objects.Contents.filter(filter);
    }
    resolveCredentials() {
        const credentials = {};
        if (this.options.credentials) {
            return { credentials: this.options.credentials };
        }
        if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
            return {
                credentials: { accessKeyId: process.env.AWS_ACCESS_KEY_ID, secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY },
            };
        }
        return credentials;
    }
}
exports.AmazonS3 = AmazonS3;
AmazonS3.STATUS_URL = 'https://s3.amazonaws.com';
//# sourceMappingURL=amazonS3.js.map