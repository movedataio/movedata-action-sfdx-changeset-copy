"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const chalk = require("chalk");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const shelljs_1 = require("shelljs");
const dependencies_1 = require("../../../dependencies");
const repository_1 = require("../../../repository");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-release-management', 'npm.package.release');
class Release extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Release);
        const deps = (0, dependencies_1.verifyDependencies)(flags);
        if (deps.failures > 0) {
            const errType = 'MissingDependencies';
            const missing = deps.results.filter((d) => d.passed === false).map((d) => d.message);
            throw new core_1.SfError(messages.getMessage(errType), errType, missing);
        }
        const pkg = await repository_1.PackageRepo.create({
            ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }),
            useprerelease: flags.prerelease,
        });
        if (!pkg.shouldBePublished) {
            this.log('Found no commits that warrant a release. Exiting...');
            return;
        }
        await pkg.writeNpmToken();
        if (flags.githubtag) {
            this.log(`Using Version: ${pkg.nextVersion}`);
        }
        else {
            pkg.printStage('Validate Next Version');
            const pkgValidation = pkg.validate();
            if (!pkgValidation.valid) {
                const errType = 'InvalidNextVersion';
                throw new core_1.SfError(messages.getMessage(errType, [pkgValidation.nextVersion]), errType);
            }
            this.log(`Name: ${pkgValidation.name}`);
            this.log(`Current Version: ${pkgValidation.currentVersion}`);
            this.log(`Next Version: ${pkgValidation.nextVersion}`);
        }
        if (flags.install) {
            pkg.printStage('Install');
            pkg.install();
            pkg.printStage('Build');
            pkg.build();
        }
        if (!flags.githubtag) {
            pkg.printStage('Prepare Release');
            pkg.prepare({ dryrun: flags.dryrun });
        }
        let signature;
        if (flags.sign && !flags.dryrun) {
            pkg.printStage('Sign and Upload Security Files');
            signature = await pkg.sign();
        }
        pkg.printStage('Publish');
        try {
            await pkg.publish({
                signatures: [signature],
                access: flags.npmaccess,
                tag: flags.npmtag,
                dryrun: flags.dryrun,
            });
        }
        catch (err) {
            if (!(err instanceof Error) || typeof err !== 'string') {
                throw err;
            }
            this.error(err, { code: 'NPM_PUBLISH_FAILED', exit: 1 });
        }
        if (!flags.dryrun && flags.verify) {
            pkg.printStage('Waiting For Availability');
            const found = await pkg.waitForAvailability();
            if (!found) {
                this.warn(`Exceeded timeout waiting for ${pkg.name}@${pkg.nextVersion} to become available`);
            }
        }
        try {
            if (flags.sign && flags.verify && !flags.dryrun) {
                pkg.printStage('Verify Signed Packaged');
                this.verifySign(pkg.getPkgInfo());
            }
        }
        finally {
            if (!flags.dryrun && !flags.githubtag) {
                pkg.printStage('Push Changes to Git');
                pkg.pushChangesToGit();
            }
        }
        this.log(pkg.getSuccessMessage());
        return {
            version: pkg.nextVersion,
            name: pkg.name,
        };
    }
    verifySign(pkgInfo) {
        const cmd = 'plugins:trust:verify';
        const argv = `--npm ${pkgInfo.name}@${pkgInfo.nextVersion} ${pkgInfo.registryParam}`;
        this.log(chalk.dim(`sf-release ${cmd} ${argv}`) + os.EOL);
        try {
            const result = (0, shelljs_1.exec)(`DEBUG=sfdx:* ${this.config.root}/bin/run ${cmd} ${argv}`);
            if (result.code !== 0) {
                const sfdxVerifyCmd = `sfdx plugins:trust:verify ${argv}`;
                this.warn('Unable to verify the package signature due to:\n\nFailed to find @salesforce/sfdx-scanner@3.1.0 in the registry\n' +
                    `\nYou can manually validate the package signature by running:\n\n${sfdxVerifyCmd}\n`);
            }
        }
        catch (err) {
            if (!(err instanceof Error) || typeof err !== 'string') {
                throw err;
            }
            throw new core_1.SfError(err, 'FailedCommandExecution');
        }
    }
}
exports.default = Release;
Release.summary = messages.getMessage('description');
Release.description = messages.getMessage('description');
Release.flags = {
    dryrun: sf_plugins_core_1.Flags.boolean({
        char: 'd',
        default: false,
        summary: messages.getMessage('dryrun'),
    }),
    sign: sf_plugins_core_1.Flags.boolean({
        char: 's',
        default: false,
        summary: messages.getMessage('sign'),
    }),
    npmtag: sf_plugins_core_1.Flags.string({
        char: 't',
        default: 'latest',
        summary: messages.getMessage('npmTag'),
    }),
    npmaccess: sf_plugins_core_1.Flags.string({
        char: 'a',
        default: 'public',
        summary: messages.getMessage('npmAccess'),
    }),
    install: sf_plugins_core_1.Flags.boolean({
        default: true,
        summary: messages.getMessage('install'),
        allowNo: true,
    }),
    prerelease: sf_plugins_core_1.Flags.string({
        summary: messages.getMessage('prerelease'),
    }),
    verify: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('verify'),
        default: true,
        allowNo: true,
    }),
    githubtag: sf_plugins_core_1.Flags.string({
        summary: messages.getMessage('githubtag'),
    }),
};
//# sourceMappingURL=release.js.map