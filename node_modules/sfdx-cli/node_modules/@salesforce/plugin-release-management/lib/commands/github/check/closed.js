"use strict";
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const core_2 = require("@octokit/core");
const plugin_throttling_1 = require("@octokit/plugin-throttling");
const ts_types_1 = require("@salesforce/ts-types");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-release-management', 'github.check.closed');
class GithubCheckClosed extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(GithubCheckClosed);
        const ThrottledOctokit = core_2.Octokit.plugin(plugin_throttling_1.throttling);
        const octokit = new ThrottledOctokit({
            auth: flags['github-token'],
            throttle: {
                onRateLimit: () => true,
                onSecondaryRateLimit: () => true,
            },
        });
        // search open issues for W- in any comments
        const issues = await octokit.request('GET /search/issues', {
            q: 'is:open is:issue repo:forcedotcom/cli W- in:comments',
        });
        // get all comments for those issues
        const commentsWithWI = (await Promise.all(issues.data.items.map((issue) => octokit.request('GET /repos/{owner}/{repo}/issues/{issue_number}/comments', {
            // eslint-disable-next-line camelcase
            issue_number: issue.number,
            owner: 'forcedotcom',
            repo: 'cli',
        }))))
            // comment includes W-
            .map((issueComments) => issueComments.data.find((comment) => comment.body.includes('W-')))
            .filter(ts_types_1.isObject)
            // extract url and WI number
            .map((comment) => ({ issueUrl: comment.issue_url, workItem: comment.body.match(/W-[0-9]{8,9}/g) }))
            .filter((item) => item.workItem?.length)
            .map((item) => ({ issueUrl: item.issueUrl, workItem: item.workItem[0] }));
        const wiToQuery = commentsWithWI.map((item) => item.workItem);
        // query all those WI in GUS, and turn into a Map
        const wiQueryResult = new Map((await flags.gus
            .getConnection()
            .sobject('ADM_Work__c')
            .find({ Name: { $in: wiToQuery } })).map((item) => [item.Name, item.Status__c]));
        // join GH and GUS results
        const results = commentsWithWI
            .map((item) => ({
            ...item,
            status: wiQueryResult.get(item.workItem),
            issueUrl: item.issueUrl.replace('api.', '').replace('repos/', ''),
        }))
            .filter((item) => item.status);
        this.table(results, {
            issueUrl: { header: 'github issue' },
            workItem: { header: 'work item' },
            status: { header: 'status' },
        }, { sort: 'status' });
        return results;
    }
}
exports.default = GithubCheckClosed;
GithubCheckClosed.summary = messages.getMessage('summary');
GithubCheckClosed.description = messages.getMessage('description');
GithubCheckClosed.examples = messages.getMessages('examples');
GithubCheckClosed.flags = {
    gus: sf_plugins_core_1.Flags.requiredOrg({
        summary: messages.getMessage('flags.gus'),
    }),
    'github-token': sf_plugins_core_1.Flags.string({
        summary: messages.getMessage('flags.github-token'),
        env: 'GITHUB_TOKEN',
        required: true,
    }),
};
//# sourceMappingURL=closed.js.map