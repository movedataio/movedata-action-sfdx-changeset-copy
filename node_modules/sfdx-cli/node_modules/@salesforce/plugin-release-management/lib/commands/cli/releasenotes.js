"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@octokit/core");
const chalk_1 = require("chalk");
const core_2 = require("@salesforce/core");
const shelljs_1 = require("shelljs");
const semver = require("semver");
const types_1 = require("../../types");
const package_1 = require("../../package");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-release-management', 'cli.releasenotes');
function isNotEmpty(obj) {
    return Object.keys(obj).length > 0;
}
class ReleaseNotes extends sf_plugins_core_1.SfCommand {
    constructor() {
        super(...arguments);
        this.usernames = {};
    }
    async run() {
        const { flags } = await this.parse(ReleaseNotes);
        const auth = (0, ts_types_1.ensureString)(new kit_1.Env().getString('GH_TOKEN'), 'GH_TOKEN is required to be set in the environment');
        this.octokit = new core_1.Octokit({ auth });
        const cli = (0, ts_types_1.ensure)(flags.cli);
        const fullName = cli === types_1.CLI.SF ? '@salesforce/cli' : 'sfdx-cli';
        const npmPackage = getNpmPackage(fullName, flags.since ?? 'latest');
        const latestrc = getNpmPackage(fullName, 'latest-rc');
        const oldPlugins = normalizePlugins(npmPackage);
        const newPlugins = normalizePlugins(latestrc);
        const differences = findDifferences(oldPlugins, newPlugins);
        if (isNotEmpty(differences.upgraded)) {
            this.styledHeader('Upgraded Plugins');
            for (const [plugin, version] of Object.entries(differences.upgraded)) {
                this.log(`• ${plugin} ${oldPlugins[plugin]} => ${version}`);
            }
        }
        if (isNotEmpty(differences.downgraded)) {
            this.styledHeader('Downgraded Plugins');
            for (const [plugin, version] of Object.entries(differences.downgraded)) {
                this.log(`• ${plugin} ${oldPlugins[plugin]} => ${version}`);
            }
        }
        if (isNotEmpty(differences.added)) {
            this.styledHeader('Added Plugins');
            for (const [plugin, version] of Object.entries(differences.added)) {
                this.log(`• ${plugin} ${version}`);
            }
        }
        if (isNotEmpty(differences.removed)) {
            this.styledHeader('Removed Plugins');
            for (const [plugin, version] of Object.entries(differences.removed)) {
                this.log(`• ${plugin} ${version}`);
            }
        }
        const changesByPlugin = {};
        for (const [plugin] of Object.entries(differences.upgraded)) {
            const pkg = getNpmPackage(plugin, oldPlugins[plugin]);
            const publishDate = pkg.time[pkg.version];
            // eslint-disable-next-line no-await-in-loop
            const changes = await this.getPullsForPlugin(plugin, publishDate);
            if (changes.length)
                changesByPlugin[plugin] = changes;
        }
        if (flags.markdown) {
            this.logChangesMarkdown(changesByPlugin);
        }
        else {
            this.logChanges(changesByPlugin);
        }
        return changesByPlugin;
    }
    async getNameOfUser(username) {
        if (this.usernames[username])
            return this.usernames[username];
        const { data } = await this.octokit.request('GET /users/{username}', { username });
        const name = (data.name ?? data.login ?? username);
        this.usernames[username] = name;
        return name;
    }
    async getPullsForPlugin(plugin, publishDate) {
        const npmPackage = getNpmPackage(plugin);
        const homepage = npmPackage.homepage ?? (npmPackage.name === 'salesforce-alm' ? 'salesforcecli/toolbelt' : null);
        if (!homepage) {
            throw new core_2.SfError(`No github url found for ${npmPackage.name}`, 'GitUrlNotFound');
        }
        const [owner, repo] = homepage.replace('https://github.com/', '').replace(/#(.*)/g, '').split('/');
        const pullRequests = await this.octokit.request('GET /repos/{owner}/{repo}/pulls', {
            owner,
            repo,
            state: 'closed',
            base: 'main',
            // eslint-disable-next-line camelcase
            per_page: 100,
        });
        const changes = (await Promise.all(pullRequests.data
            .filter((pr) => pr.merged_at && pr.merged_at > publishDate && !pr.user.login.includes('dependabot'))
            .map(async (pr) => {
            const username = await this.getNameOfUser(pr.user.login);
            const author = pr.user.login === username ? username : `${username} (${pr.user.login})`;
            return {
                author,
                mergedAt: pr.merged_at,
                mergedInto: pr.base.ref,
                link: pr.html_url,
                title: pr.title,
                description: (pr.body ?? '').trim(),
                plugin,
            };
        })));
        return changes;
    }
    logChanges(changesByPlugin) {
        for (const [plugin, changes] of Object.entries(changesByPlugin)) {
            this.styledHeader((0, chalk_1.cyan)(plugin));
            for (const change of changes) {
                this.log((0, chalk_1.bold)(`${change.title}`));
                for (const [key, value] of Object.entries(change)) {
                    if (['title', 'plugin'].includes(key))
                        continue;
                    if (key === 'description') {
                        this.log(`${key}:\n${(0, chalk_1.dim)(value)}`);
                    }
                    else {
                        this.log(`${key}: ${(0, chalk_1.dim)(value)}`);
                    }
                }
                this.log();
            }
            this.log();
        }
    }
    logChangesMarkdown(changesByPlugin) {
        for (const [plugin, changes] of Object.entries(changesByPlugin)) {
            this.log(`## ${plugin}`);
            for (const change of changes) {
                this.log(`\n### ${change.title}`);
                for (const [key, value] of Object.entries(change)) {
                    if (['title', 'plugin'].includes(key))
                        continue;
                    if (key === 'description') {
                        this.log(`- ${key}:\n\`\`\`\n${value}\n\`\`\``);
                    }
                    else {
                        this.log(`- ${key}: ${value}`);
                    }
                }
                this.log();
            }
            this.log();
        }
    }
}
exports.default = ReleaseNotes;
ReleaseNotes.summary = messages.getMessage('description');
ReleaseNotes.description = messages.getMessage('description');
ReleaseNotes.examples = messages.getMessages('examples');
ReleaseNotes.flags = {
    cli: sf_plugins_core_1.Flags.string({
        summary: messages.getMessage('cliFlag'),
        options: Object.values(types_1.CLI),
        char: 'c',
        required: true,
    }),
    since: sf_plugins_core_1.Flags.string({
        summary: messages.getMessage('sinceFlag'),
        char: 's',
    }),
    markdown: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('markdownFlag'),
        char: 'm',
        default: false,
    }),
};
const getNpmPackage = (name, version = 'latest') => {
    const result = (0, shelljs_1.exec)(`npm view ${name}@${version} --json`, { silent: true });
    return JSON.parse(result.stdout);
};
const normalizePlugins = (npmPackage) => {
    const plugins = npmPackage.oclif?.plugins ?? [];
    const normalized = { [npmPackage.name]: npmPackage.version };
    plugins.forEach((p) => {
        const version = (0, package_1.parsePackageVersion)(npmPackage.dependencies[p]);
        if (npmPackage.dependencies[p].startsWith('npm:')) {
            const name = (0, package_1.parseAliasedPackageName)(npmPackage.dependencies[p]);
            normalized[name] = version;
        }
        else {
            normalized[p] = version;
        }
    });
    return normalized;
};
const findDifferences = (oldPlugins, newPlugins) => {
    const removed = {};
    const added = {};
    const upgraded = {};
    const downgraded = {};
    const unchanged = {};
    for (const [name, version] of Object.entries(oldPlugins)) {
        if (!newPlugins[name])
            removed[name] = version;
    }
    for (const [name, version] of Object.entries(newPlugins)) {
        if (!oldPlugins[name])
            added[name] = version;
        else if (semver.gt(version, oldPlugins[name]))
            upgraded[name] = version;
        else if (semver.lt(version, oldPlugins[name]))
            downgraded[name] = version;
        else
            unchanged[name] = version;
    }
    return { removed, added, upgraded, downgraded, unchanged };
};
//# sourceMappingURL=releasenotes.js.map