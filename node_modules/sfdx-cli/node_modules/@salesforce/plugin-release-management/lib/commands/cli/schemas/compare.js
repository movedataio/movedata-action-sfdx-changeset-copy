"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs/promises");
const kit_1 = require("@salesforce/kit");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const collect_1 = require("./collect");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-release-management', 'cli.schemas.compare', [
    'description',
    'examples',
]);
class Compare extends sf_plugins_core_1.SfCommand {
    async run() {
        // The "existing schema" is the schema that is stored at the CLI level
        const existing = await (0, collect_1.getExistingSchemaFiles)();
        // The "latest schema" is the schema that is found in the node_modules
        const latest = await (0, collect_1.getLatestSchemaFiles)();
        // If there are more latest schema than existing schema, that means that new
        // schema was added without also being added at the CLI level.
        if (latest.length > existing.length) {
            const normalized = latest.map((c) => normalizeFilename(c));
            const missing = normalized.filter((f) => !existing.includes(f));
            throw new core_1.SfError(`Missing files: ${missing.join(', ')}`, 'MissingFilesError', [
                'This error means that a new schema file was found in an installed plugin. Try running cli:schemas:collect first.',
            ], 1);
        }
        const results = Object.fromEntries(await Promise.all(existing.map(async (file) => {
            const correspondingFile = latest.find((f) => normalizeFilename(f) === file);
            if (correspondingFile) {
                const [fileData, correspondingFileData] = await Promise.all([
                    fs.readFile(file, 'utf8'),
                    fs.readFile(correspondingFile, 'utf8'),
                ]);
                const fileContents = (0, kit_1.parseJsonMap)(fileData, file);
                const correspondingFileContents = (0, kit_1.parseJsonMap)(correspondingFileData, correspondingFile);
                const matches = (0, collect_1.deepEqual)(fileContents, correspondingFileContents);
                return [file, { correspondingFile, matches }];
            }
            else {
                return [
                    file,
                    {
                        correspondingFile: null,
                        matches: false,
                        reason: 'No corresponding file found in node_modules',
                    },
                ];
            }
        })));
        const data = Object.entries(results).reduce((x, [file, d]) => x.concat(Object.assign({ file }, d)), []);
        const columns = {
            file: { header: 'File' },
            correspondingFile: { header: 'Corresponding File' },
            matches: { header: 'Matches?' },
        };
        this.table(data, columns);
        const hasErrors = Object.values(results).some((result) => result.matches === false);
        if (hasErrors) {
            throw new core_1.SfError('Found schema changes', 'SchemaMismatchError', [
                'This error means that the schema in an installed plugin have changed. If this is intentional, try running cli:schemas:collect first.',
            ], 1);
        }
        return results;
    }
}
exports.default = Compare;
Compare.summary = messages.getMessage('description');
Compare.description = messages.getMessage('description');
Compare.examples = messages.getMessages('examples');
Compare.flags = {};
Compare.state = 'deprecated';
const normalizeFilename = (file) => {
    const normalized = file
        .split(path.sep)
        .filter((p) => !['node_modules', 'schemas'].includes(p))
        .join(path.sep);
    return path.join('schemas', normalized);
};
//# sourceMappingURL=compare.js.map