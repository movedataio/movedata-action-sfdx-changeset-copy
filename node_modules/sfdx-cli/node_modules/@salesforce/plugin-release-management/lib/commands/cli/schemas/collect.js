"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepEqual = exports.getExistingSchemaFiles = exports.getLatestSchemaFiles = void 0;
const path = require("path");
const fs = require("fs/promises");
const assert = require("assert");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const shelljs_1 = require("shelljs");
const fg = require("fast-glob");
const kit_1 = require("@salesforce/kit");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-release-management', 'cli.schemas.collect', [
    'description',
    'examples',
]);
const getLatestSchemaFiles = async () => {
    const fileData = await fs.readFile(path.join(process.cwd(), 'package.json'), 'utf-8');
    const pjson = (0, kit_1.parseJsonMap)(fileData, path.join(process.cwd(), 'package.json'));
    const globs = (pjson.oclif?.plugins || []).map((plugin) => {
        const normalized = plugin.replace(/\\/g, '/');
        return `node_modules/${normalized}/schemas/**/*.json`; // We need to use / for path sep since fg only works with Unix paths
    });
    const schemaFiles = (await fg(globs))
        .map((f) => path.normalize(f)) // normalize paths so this will work on Windows since fg only returns Unix paths
        .filter((f) => !f.includes(path.join('@salesforce', 'schemas')));
    return schemaFiles;
};
exports.getLatestSchemaFiles = getLatestSchemaFiles;
const getExistingSchemaFiles = async () => {
    const globs = ['schemas/**/*.json'];
    const schemaFiles = await fg(globs);
    return schemaFiles;
};
exports.getExistingSchemaFiles = getExistingSchemaFiles;
const deepEqual = (a, b) => {
    try {
        assert.deepEqual(a, b);
        return true;
    }
    catch {
        return false;
    }
};
exports.deepEqual = deepEqual;
class Collect extends sf_plugins_core_1.SfCommand {
    // eslint-disable-next-line class-methods-use-this
    async run() {
        const schemaFiles = await (0, exports.getLatestSchemaFiles)();
        const schemaFilesByPlugin = new Map();
        for (const file of schemaFiles) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const [_, namespace, pluginName] = file.split(path.sep);
            const plugin = path.join(namespace, pluginName);
            if (schemaFilesByPlugin.has(plugin)) {
                const existing = schemaFilesByPlugin.get(plugin);
                schemaFilesByPlugin.set(plugin, [...existing, file]);
            }
            else {
                schemaFilesByPlugin.set(plugin, [file]);
            }
        }
        const outputDir = path.join(process.cwd(), 'schemas');
        await fs.mkdir(outputDir, { recursive: true });
        await Promise.all(Array.from(schemaFilesByPlugin.entries()).map(async ([plugin, files]) => {
            const pluginOutputDir = path.join(outputDir, plugin);
            await fs.mkdir(pluginOutputDir, { recursive: true });
            await Promise.all(files.map(async (file) => {
                if (file.split(path.sep).includes('hooks')) {
                    const hooksOutputDir = path.join(pluginOutputDir, 'hooks');
                    await fs.mkdir(hooksOutputDir, { recursive: true });
                    (0, shelljs_1.cp)('-f', file, path.join(hooksOutputDir, path.basename(file)));
                }
                else {
                    (0, shelljs_1.cp)('-f', file, path.join(pluginOutputDir, path.basename(file)));
                }
            }));
        }));
    }
}
exports.default = Collect;
Collect.summary = messages.getMessage('description');
Collect.description = messages.getMessage('description');
Collect.examples = messages.getMessages('examples');
Collect.flags = {};
Collect.state = 'deprecated';
//# sourceMappingURL=collect.js.map