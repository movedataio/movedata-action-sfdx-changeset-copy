"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable no-await-in-loop */
const fs = require("fs");
const os = require("os");
const path = require("path");
const child_process_1 = require("child_process");
const node_util_1 = require("node:util");
const chalk = require("chalk");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const types_1 = require("../../../types");
const exec = (0, node_util_1.promisify)(child_process_1.exec);
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-release-management', 'cli.tarballs.smoke');
class SmokeTest extends sf_plugins_core_1.SfCommand {
    async run() {
        this.flags = (await this.parse(SmokeTest)).flags;
        const executables = [path.join('tmp', this.flags.cli, 'bin', this.flags.cli)];
        if (this.flags.cli === types_1.CLI.SFDX) {
            executables.push(path.join('tmp', this.flags.cli, 'bin', types_1.CLI.SF));
        }
        await Promise.all(executables.map((executable) => this.smokeTest(executable)));
    }
    async smokeTest(executable) {
        await Promise.all([
            this.execute(executable, '--version'),
            this.execute(executable, '--help'),
            this.execute(executable, 'plugins --core'),
            this.testInstall(executable, '@salesforce/plugin-alias', 'latest'),
        ]);
        // Only run JIT tests for the main executable
        if (this.flags.cli === types_1.CLI.SFDX && !executable.endsWith('sf')) {
            await this.testJITInstall(executable);
        }
        await this.initializeAllCommands(executable);
    }
    async testJITInstall(executable) {
        this.styledHeader('Testing JIT installation');
        const fileData = await fs.promises.readFile('package.json', 'utf8');
        const packageJson = (0, kit_1.parseJson)(fileData);
        const jitPlugins = Object.keys(packageJson.oclif?.jitPlugins ?? {});
        if (jitPlugins.length === 0)
            return;
        const manifestData = await fs.promises.readFile(path.join('tmp', this.flags.cli, 'oclif.manifest.json'), 'utf8');
        const manifest = (0, kit_1.parseJson)(manifestData);
        const commands = Object.values(manifest.commands);
        let failed = false;
        const help = async (command) => {
            try {
                await exec(`${executable} ${command} --help`);
                return true;
            }
            catch (e) {
                return false;
            }
        };
        // We have to test these serially in order to avoid issues when running plugin installs concurrently.
        for (const plugin of jitPlugins) {
            try {
                this.log(`Testing JIT install for ${plugin}`);
                const firstCommand = commands.find((c) => c.pluginName === plugin);
                // Test that --help works on JIT commands
                const helpResult = await help(firstCommand.id);
                this.log(`${executable} ${firstCommand.id} --help ${helpResult ? chalk.green('PASSED') : chalk.red('FAILED')}`);
                this.log(`${executable} ${firstCommand.id}`);
                // Test that executing the command will trigger JIT install
                // This will likely always fail because we're not providing all the required flags or it depends on some other setup.
                // However, this is okay because all we need to verify is that running the command will trigger the JIT install
                const { stdout, stderr } = await exec(`${executable} ${firstCommand.id}`, { maxBuffer: 1024 * 1024 * 100 });
                this.log(stdout);
                this.log(stderr);
            }
            catch (e) {
                const err = e;
                // @ts-expect-error ExecException type doesn't have a stdout or stderr property
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                this.log(err.stdout);
                // @ts-expect-error ExecException type doesn't have a stdout or stderr property
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                this.log(err.stderr);
            }
            finally {
                const result = await this.verifyInstall(plugin, executable, true);
                if (result) {
                    this.log(`✅ ${chalk.green(`Verified installation of ${plugin}\n`)}`);
                }
                else {
                    failed = true;
                    this.log(`❌ ${chalk.red(`Failed installation of ${plugin}\n`)}`);
                }
            }
        }
        if (failed) {
            throw new core_1.SfError('Failed JIT installation');
        }
    }
    async testInstall(executable, plugin, tag) {
        await this.execute(executable, `plugins:install ${plugin}${tag ? `@${tag}` : ''}`);
        await this.verifyInstall(plugin, executable);
    }
    async verifyInstall(plugin, executable, silent = false) {
        const fileData = await fs.promises.readFile(path.join(os.homedir(), '.local', 'share', path.basename(executable), 'package.json'), 'utf-8');
        const packageJson = (0, kit_1.parseJson)(fileData);
        if (!packageJson.dependencies?.[plugin]) {
            if (silent) {
                return false;
            }
            else {
                throw new core_1.SfError(`Failed to install ${plugin}\n`);
            }
        }
        else if (!silent) {
            this.log('✅ ', chalk.green(`Verified installation of ${plugin}\n`));
            return true;
        }
        return true;
    }
    async initializeAllCommands(executable) {
        this.styledHeader(`Initializing help for all ${this.flags.cli} commands`);
        // Ran into memory issues when running all commands at once. Now we run them in batches of 10.
        const throttledPromise = new kit_1.ThrottledPromiseAll({ concurrency: 10, timeout: kit_1.Duration.minutes(10) });
        const allCommands = await this.getAllCommands(executable);
        const executePromise = async (command) => this.flags.verbose
            ? this.execute(executable, `${command} --help`)
            : this.nonVerboseCommandExecution(executable, command);
        throttledPromise.add(allCommands, executePromise);
        await throttledPromise.all();
    }
    async getAllCommands(executable) {
        const commandsJson = JSON.parse(await this.execute(executable, 'commands --json', true));
        return commandsJson.map((c) => c.id);
    }
    async nonVerboseCommandExecution(executable, command) {
        try {
            await this.execute(executable, `${command} --help`, true);
            this.log(`${executable} ${command} --help ${chalk.green('PASSED')}`);
        }
        catch (err) {
            this.log(`${executable} ${command} --help ${chalk.red('FAILED')}`);
            throw err;
        }
    }
    async execute(executable, args, silent = false) {
        const command = `${executable} ${args}`;
        try {
            const { stdout } = await exec(command, { maxBuffer: 1024 * 1024 * 100 });
            if (!silent) {
                this.styledHeader(command);
                this.log(stdout);
            }
            return stdout;
        }
        catch (e) {
            const err = e;
            throw new core_1.SfError(`Failed: ${command}.\n ${err.message}`, 'SMOKE_TEST_FAILURE', [], err);
        }
    }
}
exports.default = SmokeTest;
SmokeTest.summary = messages.getMessage('description');
SmokeTest.description = messages.getMessage('description');
SmokeTest.examples = messages.getMessages('examples');
SmokeTest.flags = {
    cli: sf_plugins_core_1.Flags.custom({
        options: Object.values(types_1.CLI),
    })({
        summary: messages.getMessage('cliFlag'),
        char: 'c',
        required: true,
    }),
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('verboseFlag'),
    }),
};
//# sourceMappingURL=smoke.js.map