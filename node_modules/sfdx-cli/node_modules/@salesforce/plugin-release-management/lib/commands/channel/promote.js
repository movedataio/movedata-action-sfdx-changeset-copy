"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const semver_1 = require("semver");
const shelljs_1 = require("shelljs");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const amazonS3_1 = require("../../amazonS3");
const dependencies_1 = require("../../dependencies");
const types_1 = require("../../types");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-release-management', 'channel.promote');
const TARGETS = ['linux-x64', 'linux-arm', 'win32-x64', 'win32-x86', 'darwin-x64'];
class Promote extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Promote);
        this.flags = flags;
        this.validateFlags();
        // preparing parameters for call to oclif promote commands
        const cli = this.flags.cli;
        const target = (0, ts_types_1.ensureString)(this.flags['promote-to-channel']);
        const indexes = this.flags.indexes ? '--indexes' : '';
        const xz = this.flags.xz ? '--xz' : '--no-xz';
        const { sha, version } = await determineShaAndVersion(cli, this.flags['promote-from-channel'], this.flags.version, this.flags.sha);
        const platforms = this.flags.platform?.map((p) => `--${p}`);
        if (!this.flags.dryrun) {
            const params = [
                '--version',
                version,
                '--sha',
                sha,
                '--channel',
                target,
                '--max-age',
                this.flags['max-age'].toString(),
                ...(platforms ?? []),
                ...(this.flags['architecture-target'] ?? []),
                indexes,
                xz,
            ];
            const results = (0, shelljs_1.exec)(`yarn oclif promote ${params.join(' ')}`);
            this.log(results.stdout);
        }
        else if (!this.flags.json) {
            this.log(messages.getMessage('DryRunMessage', [cli, version, sha, target, this.flags.platform?.join(', ') ?? 'all'].map((s) => (0, chalk_1.bold)(s))));
        }
        return {
            dryRun: !!this.flags.dryrun,
            cli,
            target,
            sha,
            version,
            platforms: this.flags.platform,
        };
    }
    /**
     * validate flag combinations
     *
     * @private
     */
    validateFlags() {
        // cannot promote when channel names are the same
        if (this.flags['promote-from-channel'] && this.flags['promote-from-channel'] === this.flags['promote-to-channel']) {
            throw new core_1.SfError(messages.getMessage('CannotPromoteToSameChannel'));
        }
        // make sure necessary runtime dependencies are present
        const deps = (0, dependencies_1.verifyDependencies)(this.flags, (dep) => dep.name.startsWith('AWS'), (args) => !args.dryrun);
        if (deps.failures > 0) {
            const errType = 'MissingDependencies';
            const missing = deps.results.filter((d) => d.passed === false).map((d) => d.message);
            throw new core_1.SfError(messages.getMessage(errType), errType, missing);
        }
    }
}
exports.default = Promote;
Promote.description = messages.getMessage('description');
Promote.summary = messages.getMessage('summary');
Promote.examples = messages.getMessages('examples');
Promote.flags = {
    dryrun: sf_plugins_core_1.Flags.boolean({
        char: 'd',
        default: false,
        summary: messages.getMessage('dryrun'),
    }),
    'promote-to-channel': sf_plugins_core_1.Flags.string({
        char: 't',
        default: types_1.Channel.STABLE,
        summary: messages.getMessage('target'),
        // options: Object.values(Channel),
        required: true,
        aliases: ['target'],
    }),
    'promote-from-channel': sf_plugins_core_1.Flags.string({
        char: 'C',
        summary: messages.getMessage('candidate'),
        // options: Object.values(Channel),
        exactlyOne: ['sha', 'version', 'promote-from-channel'],
        aliases: ['candidate'],
    }),
    platform: (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'p',
        summary: messages.getMessage('platform'),
        options: ['win', 'macos', 'deb'],
    }),
    cli: sf_plugins_core_1.Flags.custom({
        options: Object.values(types_1.CLI),
    })({
        char: 'c',
        summary: messages.getMessage('cli'),
        required: true,
    }),
    sha: sf_plugins_core_1.Flags.string({
        char: 's',
        summary: messages.getMessage('sha'),
        exactlyOne: ['sha', 'version', 'promote-from-channel'],
        parse: (input) => Promise.resolve(input.slice(0, 7)),
        validate: (input) => {
            if (input.length < 7) {
                return false;
            }
            return true;
        },
    }),
    'max-age': sf_plugins_core_1.Flags.integer({
        char: 'm',
        summary: messages.getMessage('maxage'),
        default: 300,
        aliases: ['maxage'],
    }),
    indexes: sf_plugins_core_1.Flags.boolean({
        char: 'i',
        summary: messages.getMessage('indexes'),
        default: true,
        allowNo: true,
    }),
    xz: sf_plugins_core_1.Flags.boolean({
        char: 'x',
        summary: messages.getMessage('xz'),
        default: true,
        allowNo: true,
    }),
    'architecture-target': (0, sf_plugins_core_1.arrayWithDeprecation)({
        char: 'T',
        summary: messages.getMessage('targets'),
        options: TARGETS,
        aliases: ['targets'],
    }),
    version: sf_plugins_core_1.Flags.string({
        char: 'v',
        summary: messages.getMessage('version'),
        exactlyOne: ['sha', 'version', 'promote-from-channel'],
        parse: (input) => Promise.resolve(input.trim()),
        validate: (input) => (0, semver_1.valid)(input) !== null,
    }),
};
/**
 * find a manifest file in the channel
 *
 * @param cli
 * @param channel
 * @private
 */
const findManifestForCandidate = async (cli, channel) => {
    const amazonS3 = new amazonS3_1.AmazonS3({ cli, channel });
    return amazonS3.getManifestFromChannel(channel);
};
/**
 * find the version that owns the named sha
 *
 * @param cli
 * @param sha
 * @private
 */
const findVersionForSha = async (cli, sha) => {
    const amazonS3 = new amazonS3_1.AmazonS3({ cli });
    const foundVersion = (await Promise.all((await amazonS3.listCommonPrefixes('versions')).map(async (version) => amazonS3.listCommonPrefixes(version.Prefix))))
        .flat()
        .find((s) => s.Prefix.replace(/\/$/, '').endsWith(sha));
    if (foundVersion) {
        // Prefix looks like this "media/salesforce-cli/sf/versions/0.0.10/1d4b10d/",
        // when reversed after split version number should occupy entry 1 of the array
        return foundVersion.Prefix.replace(/\/$/, '').split('/').reverse()[1];
    }
    const error = new core_1.SfError(messages.getMessage('CouldNotLocateVersionForSha', [sha]));
    const logger = core_1.Logger.childFromRoot('Promote.findVersionForSha');
    logger.debug(error);
    throw error;
};
/**
 * Based on which flag was provided, locate the sha and version in S3 that will be used in the promote
 *
 * when candidate channel flag present, find sha a version via the channel for candidate
 * when version flag present, find the sha from version subfolders with the most recent modified date
 * when sha flag is present, find the version that owns the subfolder named as sha value
 *
 * @param cli
 * @private
 */
const determineShaAndVersion = async (cli, candidate, version, sha) => {
    if (candidate) {
        const manifest = await findManifestForCandidate(cli, candidate);
        return { sha: manifest.sha, version: manifest.version };
    }
    else if (version) {
        const shaFromVersion = await findShaForVersion(cli, (0, ts_types_1.ensureString)(version));
        return { sha: shaFromVersion, version: (0, ts_types_1.ensureString)(version) };
    }
    else if (sha) {
        (0, ts_types_1.ensureString)(sha);
        const versionFromSha = await findVersionForSha(cli, sha);
        return { sha, version: versionFromSha };
    }
    throw new core_1.SfError(messages.getMessage('CouldNotDetermineShaAndVersion'));
};
/**
 * find the sha that was uploaded most recently for the named version
 *
 * @param cli
 * @param version
 * @private
 */
const findShaForVersion = async (cli, version) => {
    const logger = core_1.Logger.childFromRoot('Promote.findShaForVersion');
    const amazonS3 = new amazonS3_1.AmazonS3({ cli });
    const versions = await amazonS3.listCommonPrefixes('versions');
    const foundVersion = versions.find((v) => v.Prefix.endsWith(`${version}/`))?.Prefix;
    if (foundVersion) {
        logger.debug(`Looking for version ${version} for cli ${cli}. Found ${foundVersion}`);
        const versionShas = await amazonS3.listCommonPrefixes(foundVersion);
        logger.debug(`Looking for version ${version} for cli ${cli} shas. Found ${versionShas.length} entries`);
        const manifestForMostRecentSha = (await Promise.all(versionShas.map(async (versionSha) => {
            const versionShaContents = (await amazonS3.listKeyContents(versionSha.Prefix));
            return versionShaContents.map((content) => ({
                ...content,
                ...{ LastModifiedDate: new Date(content.LastModified) },
            }));
        }))).flat()
            .filter((content) => content.Key.includes('manifest'))
            .sort((left, right) => right.LastModifiedDate.getMilliseconds() - left.LastModifiedDate.getMilliseconds())
            .find((content) => content);
        if (manifestForMostRecentSha) {
            const manifest = await amazonS3.getObject({
                Key: manifestForMostRecentSha.Key,
                ResponseContentType: 'application/json',
            });
            logger.debug(`Loaded manifest ${manifestForMostRecentSha.Key} contents: ${manifest.toString()}`);
            const json = JSON.parse(manifest.Body.toString());
            return json.sha;
        }
    }
    const error = new core_1.SfError(messages.getMessage('CouldNotLocateShaForVersion', [version]));
    logger.debug(error);
    throw error;
};
//# sourceMappingURL=promote.js.map