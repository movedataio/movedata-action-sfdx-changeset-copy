"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs/promises");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const shelljs_1 = require("shelljs");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const repository_1 = require("../../repository");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.load('@salesforce/plugin-release-management', 'typescript.update', [
    'description',
    'typescriptVersion',
    'esTarget',
    'InvalidTargetVersion',
    'InvalidTypescriptVersion',
]);
class Update extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Update);
        this.flags = flags;
        this.typescriptPkg = retrieveTsPackage();
        this.validateEsTarget();
        this.validateTsVersion();
        this.repo = await repository_1.PackageRepo.create({ ux: new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }) });
        this.packages = this.getPackages();
        this.warn('This is for testing new versions only. To update the version you must go through dev-scripts.');
        this.updateTsVersion();
        for (const pkg of this.packages) {
            // this.packages is singular in a non-lerna world
            // eslint-disable-next-line no-await-in-loop
            await this.updateEsTargetConfig(pkg.location);
        }
        try {
            this.repo.install();
            this.repo.build();
            this.repo.test();
        }
        finally {
            this.log('Reverting unstaged stages');
            this.repo.revertUnstagedChanges();
        }
    }
    getPackages() {
        return [this.repo.package];
    }
    async updateEsTargetConfig(packagePath) {
        const tsConfigPath = path.join(packagePath, 'tsconfig.json');
        const tsConfigString = await fs.readFile(tsConfigPath, 'utf-8');
        // strip out any comments that might be in the tsconfig.json
        const commentRegex = new RegExp(/(\/\/.*)/, 'gi');
        const tsConfig = JSON.parse(tsConfigString.replace(commentRegex, ''));
        (0, kit_1.set)((0, ts_types_1.asObject)(tsConfig), 'compilerOptions.target', this.flags.target);
        this.log(`Updating tsconfig target at ${tsConfigPath} to:`, this.flags.target);
        const fileData = JSON.stringify(tsConfig, null, 2);
        await fs.writeFile(tsConfigPath, fileData, {
            encoding: 'utf8',
            mode: '600',
        });
    }
    updateTsVersion() {
        const newVersion = this.determineNextTsVersion();
        for (const pkg of this.packages) {
            if (pkg.packageJson.devDependencies['typescript']) {
                this.warn(`Updating typescript version to ${newVersion} in path ${pkg.location}`);
                pkg.packageJson.devDependencies['typescript'] = newVersion;
                pkg.packageJson.devDependencies['@typescript-eslint/eslint-plugin'] = 'latest';
                pkg.packageJson.devDependencies['@typescript-eslint/parser'] = 'latest';
            }
            // If the prepare script runs sf-install, the install will fail because the typescript version
            // won't match the expected version. So in that case, we delete the prepare script so that we
            // get a successful install
            if (pkg.packageJson.scripts['prepare'] === 'sf-install') {
                delete pkg.packageJson.scripts['prepare'];
            }
            pkg.writePackageJson(pkg.location);
        }
    }
    determineNextTsVersion() {
        return this.flags.version === 'latest' || !this.flags.version
            ? (0, ts_types_1.getString)(this.typescriptPkg, 'dist-tags.latest')
            : this.flags.version;
    }
    validateEsTarget() {
        if (this.flags.target === 'ESNext')
            return true;
        if (/ES[0-9]{4}/g.test(this.flags.target))
            return true;
        throw new core_1.SfError(messages.getMessage('InvalidTargetVersion', [this.flags.target]), 'InvalidTargetVersion');
    }
    validateTsVersion() {
        const version = this.flags.version;
        if (version === 'latest')
            return true;
        if (version && !this.typescriptPkg.versions.includes(version)) {
            throw new core_1.SfError(messages.getMessage('InvalidTypescriptVersion', [version]), 'InvalidTypescriptVersion');
        }
        return true;
    }
}
exports.default = Update;
Update.summary = messages.getMessage('description');
Update.description = messages.getMessage('description');
Update.flags = {
    version: sf_plugins_core_1.Flags.string({
        char: 'v',
        summary: messages.getMessage('typescriptVersion'),
        default: 'latest',
    }),
    target: sf_plugins_core_1.Flags.string({
        char: 't',
        summary: messages.getMessage('esTarget'),
        default: 'ESNext',
    }),
};
const retrieveTsPackage = () => {
    const result = (0, shelljs_1.exec)('npm view typescript --json', { silent: true });
    if (result.code === 0) {
        return JSON.parse(result.stdout);
    }
    else {
        throw new core_1.SfError('Could not find typescript on the npm registry', 'TypescriptNotFound');
    }
};
//# sourceMappingURL=update.js.map