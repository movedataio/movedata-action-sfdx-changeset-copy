import { Ux } from '@salesforce/sf-plugins-core';
import { ShellString } from 'shelljs';
import { AsyncOptionalCreatable, Env } from '@salesforce/kit';
import { Package, VersionValidation } from './package';
import { Registry } from './registry';
import { SigningResponse } from './codeSigning/SimplifiedSigning';
interface PrepareOpts {
    dryrun?: boolean;
    githubRelease?: boolean;
}
export type Access = 'public' | 'restricted';
interface PublishOpts {
    dryrun?: boolean;
    signatures?: SigningResponse[];
    tag?: string;
    access?: Access;
}
export interface PackageInfo {
    name: string;
    nextVersion: string;
    registryParam: string;
}
type PollFunction = () => boolean;
type RepositoryOptions = {
    ux: Ux;
    useprerelease?: string;
    shouldBePublished?: boolean;
};
declare abstract class Repository extends AsyncOptionalCreatable<RepositoryOptions> {
    protected options: RepositoryOptions;
    protected ux: Ux;
    protected shouldBePublished: boolean;
    protected env: Env;
    protected registry: Registry;
    private stepCounter;
    constructor(options: RepositoryOptions);
    install(silent?: boolean): void;
    build(silent?: boolean): void;
    run(script: string, location?: string, silent?: boolean): void;
    test(): void;
    getBranchName(): string;
    pushChangesToGit(): void;
    stageChanges(): void;
    revertUnstagedChanges(): void;
    revertAllChanges(): void;
    printStage(msg: string): void;
    writeNpmToken(): Promise<void>;
    protected execCommand(cmd: string, silent?: boolean): ShellString;
    protected poll(checkFn: PollFunction): Promise<boolean>;
    /**
     * If the commit type isn't fix (patch bump), feat (minor bump), or breaking (major bump),
     * then standard-version always defaults to a patch bump.
     * See https://github.com/conventional-changelog/standard-version/issues/577
     *
     * We, however, don't want to publish a new version for chore, docs, etc. So we analyze
     * the commits to see if any of them indicate that a new release should be published.
     */
    protected isReleasable(pkg: Package): Promise<boolean>;
    abstract getSuccessMessage(): string;
    abstract validate(): VersionValidation | VersionValidation[];
    abstract prepare(options: PrepareOpts): void;
    abstract getPkgInfo(packageNames?: string[]): PackageInfo | PackageInfo[];
    abstract publish(options: PublishOpts): Promise<void>;
    abstract sign(packageNames?: string[]): Promise<SigningResponse | SigningResponse[]>;
    abstract waitForAvailability(): Promise<boolean>;
    protected abstract init(): Promise<void>;
}
export declare class PackageRepo extends Repository {
    name: string;
    nextVersion: string;
    package: Package;
    shouldBePublished: boolean;
    private logger;
    constructor(options: RepositoryOptions);
    validate(): VersionValidation;
    prepare(opts?: PrepareOpts): void;
    sign(): Promise<SigningResponse>;
    revertChanges(): Promise<void>;
    getPkgInfo(): PackageInfo;
    publish(opts?: PublishOpts): Promise<void>;
    waitForAvailability(): Promise<boolean>;
    getSuccessMessage(): string;
    protected init(): Promise<void>;
    private determineNextVersion;
}
export {};
