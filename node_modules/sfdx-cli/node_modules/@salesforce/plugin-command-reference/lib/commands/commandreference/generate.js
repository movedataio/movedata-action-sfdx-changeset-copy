"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const fs_extra_1 = require("fs-extra");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const chalk = require("chalk");
const ditamap_1 = require("../../ditamap/ditamap");
const docs_1 = require("../../docs");
const utils_1 = require("../../utils");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const uniqBy = require('lodash.uniqby');
// Initialize Messages with the current plugin directory
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-command-reference', 'main');
class CommandReferenceGenerate extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(CommandReferenceGenerate);
        ditamap_1.Ditamap.suffix = flags['ditamap-suffix'];
        let pluginNames;
        if (!flags.plugins && !flags.all) {
            const pJsonPath = path.join(process.cwd(), 'package.json');
            if (await (0, fs_extra_1.pathExists)(pJsonPath)) {
                const packageJson = await (0, fs_extra_1.readJSON)(pJsonPath);
                pluginNames = [(0, ts_types_1.getString)(packageJson, 'name')];
            }
            else {
                throw new core_2.SfError("No plugins provided. Provide the '--plugins' flag or cd into a directory that contains a valid oclif plugin.");
            }
        }
        else if (flags.all) {
            const ignore = [
                /@oclif/,
                /@salesforce\/cli/,
                /@salesforce\/plugin-dev/,
                /@salesforce\/plugin-telemetry/,
                /@salesforce\/plugin-command-reference/,
            ];
            pluginNames = this.config.plugins.map((p) => p.name).filter((p) => !ignore.some((i) => i.test(p)));
        }
        else {
            pluginNames = flags.plugins;
        }
        const plugins = pluginNames
            .map((plugin) => plugin.trim())
            .map((name) => {
            let pluginName = name;
            let plugin = this.getPlugin(pluginName);
            if (!plugin) {
                pluginName = `@salesforce/plugin-${pluginName}`;
                plugin = this.getPlugin(pluginName);
                if (!plugin) {
                    throw new core_2.SfError(`Plugin ${name} or ${pluginName} not found. Is it installed?`);
                }
            }
            return pluginName;
        });
        this.log(`Generating command reference for the following plugins:${plugins
            .map((name) => `${os.EOL}  - ${name}`)
            .join(', ')}`);
        ditamap_1.Ditamap.outputDir = flags.outputdir;
        ditamap_1.Ditamap.cliVersion = this.config.version.replace(/-[0-9a-zA-Z]+$/, '');
        ditamap_1.Ditamap.plugins = this.pluginMap(plugins);
        ditamap_1.Ditamap.pluginVersions = plugins.map((name) => {
            const plugin = this.getPlugin(name);
            const version = plugin && plugin.version;
            if (!version)
                throw new Error(`No version found for plugin ${name}`);
            return { name, version };
        });
        const docs = new docs_1.Docs(ditamap_1.Ditamap.outputDir, ditamap_1.Ditamap.plugins, flags.hidden, await this.loadTopicMetadata(), this.loadCliMeta());
        utils_1.events.on('topic', ({ topic }) => {
            this.log(chalk.green(`Generating topic '${topic}'`));
        });
        const warnings = [];
        utils_1.events.on('warning', (msg) => {
            process.stderr.write(chalk.yellow(`> ${msg}\n`));
            warnings.push(msg);
        });
        await docs.build(await this.loadCommands());
        this.log(`\nWrote generated doc to ${ditamap_1.Ditamap.outputDir}`);
        if (flags.erroronwarnings && warnings.length > 0) {
            throw new core_2.SfError(`Found ${warnings.length} warnings.`);
        }
        return { warnings };
    }
    pluginMap(plugins) {
        const pluginToParentPlugin = {};
        const resolveChildPlugins = (parentPlugin) => {
            for (const childPlugin of parentPlugin.pjson.oclif.plugins || []) {
                pluginToParentPlugin[childPlugin] = parentPlugin.name;
                resolveChildPlugins((0, ts_types_1.ensure)(this.getPlugin(childPlugin)));
            }
        };
        for (const plugin of plugins) {
            const masterPlugin = this.getPlugin(plugin);
            if (!masterPlugin) {
                throw new core_2.SfError(`Plugin ${plugin} not found. Is it installed?`);
            }
            pluginToParentPlugin[masterPlugin.name] = masterPlugin.name;
            resolveChildPlugins(masterPlugin);
        }
        return pluginToParentPlugin;
    }
    getPlugin(pluginName) {
        return this.config.plugins.find((info) => info.name === pluginName);
    }
    async loadTopicMetadata() {
        const plugins = {};
        const topicsMeta = {};
        for (const cmd of this.config.commands) {
            // Only load topics for each plugin once
            if (cmd.pluginName && !plugins[cmd.pluginName]) {
                const commandClass = await this.loadCommand(cmd);
                if (commandClass.plugin && commandClass.plugin.pjson.oclif.topics) {
                    (0, utils_1.mergeDeep)(topicsMeta, commandClass.plugin.pjson.oclif.topics);
                    plugins[commandClass.plugin.name] = true;
                }
            }
        }
        return topicsMeta;
    }
    async loadCommands() {
        const promises = this.config.commands.map(async (cmd) => {
            try {
                let commandClass = await this.loadCommand(cmd);
                let obj = Object.assign({}, cmd, commandClass, {
                    flags: Object.assign({}, cmd.flags, commandClass.flags),
                });
                // Load all properties on all extending classes.
                while (commandClass !== undefined) {
                    commandClass = Object.getPrototypeOf(commandClass) || undefined;
                    obj = Object.assign({}, commandClass, obj, {
                        flags: Object.assign({}, commandClass && commandClass.flags, obj.flags),
                    });
                }
                return obj;
            }
            catch (error) {
                return Object.assign({}, cmd);
            }
        });
        const commands = await Promise.all(promises);
        return uniqBy(commands, 'id');
    }
    async loadCommand(command) {
        return command.load.constructor.name === 'AsyncFunction' ? await command.load() : command.load();
    }
    loadCliMeta() {
        return {
            binary: this.config.pjson.oclif.bin || 'sfdx',
            topicSeparator: this.config.pjson.oclif.topicSeparator,
            state: this.config.pjson.oclif.state,
        };
    }
}
exports.default = CommandReferenceGenerate;
CommandReferenceGenerate.description = messages.getMessage('commandDescription');
CommandReferenceGenerate.flags = {
    outputdir: core_1.Flags.string({
        char: 'd',
        description: messages.getMessage('outputdirFlagDescription'),
        default: './tmp/root',
    }),
    plugins: core_1.Flags.string({
        char: 'p',
        description: messages.getMessage('pluginFlagDescription'),
        multiple: true,
        exclusive: ['all'],
    }),
    all: core_1.Flags.boolean({
        char: 'a',
        description: messages.getMessage('allFlagDescription'),
        exclusive: ['plugins'],
    }),
    'ditamap-suffix': core_1.Flags.string({
        char: 's',
        description: messages.getMessage('ditamapSuffixFlagDescription'),
        default: ditamap_1.Ditamap.SUFFIX,
    }),
    hidden: core_1.Flags.boolean({ description: messages.getMessage('hiddenFlagDescription') }),
    erroronwarnings: core_1.Flags.boolean({ description: messages.getMessage('erroronwarningFlagDescription') }),
};
//# sourceMappingURL=generate.js.map