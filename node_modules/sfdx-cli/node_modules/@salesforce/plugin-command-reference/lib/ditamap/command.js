"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Command = void 0;
const path_1 = require("path");
const ts_types_1 = require("@salesforce/ts-types");
const utils_1 = require("../utils");
const ditamap_1 = require("./ditamap");
const getDefault = async (flag) => {
    if (typeof flag.default !== 'function') {
        return flag.default;
    }
    else if (typeof flag.default === 'function') {
        try {
            const help = await flag.default();
            return help || '';
        }
        catch {
            return '';
        }
    }
    else {
        return '';
    }
};
class Command extends ditamap_1.Ditamap {
    constructor(topic, subtopic, command, commandMeta = {}) {
        const commandWithUnderscores = (0, ts_types_1.ensureString)(command.id).replace(/:/g, '_');
        const filename = ditamap_1.Ditamap.file(`cli_reference_${commandWithUnderscores}`, 'xml');
        super(filename, {});
        this.flags = (0, ts_types_1.ensureObject)(command.flags);
        const summary = (0, utils_1.punctuate)((0, ts_types_1.asString)(command.summary));
        const description = (0, ts_types_1.asString)(command.description);
        // Help are all the lines after the first line in the description. Before oclif, there was a 'help' property so continue to
        // support that.
        const help = this.formatParagraphs(description);
        let trailblazerCommunityUrl;
        let trailblazerCommunityName;
        if (commandMeta.trailblazerCommunityLink) {
            const community = (0, ts_types_1.ensureJsonMap)(commandMeta.trailblazerCommunityLink);
            trailblazerCommunityUrl = community.url;
            trailblazerCommunityName = community.name;
        }
        const commandName = (0, ts_types_1.asString)(command.id).replace(/:/g, (0, ts_types_1.asString)(commandMeta.topicSeparator));
        const examples = (command.examples || []).map((example) => {
            const parts = example.split('\n');
            const desc = parts.length > 1 ? parts[0] : null;
            const commands = parts.length > 1 ? parts.slice(1) : [parts[0]];
            return {
                description: desc,
                commands: commands.map((c) => {
                    return c
                        .replace(/<%= config.bin %>/g, (0, ts_types_1.asString)(commandMeta.binary))
                        .replace(/<%= command.id %>/g, commandName);
                }),
            };
        });
        const state = command.state || commandMeta.state;
        this.data = Object.assign(command, {
            name: commandName,
            binary: commandMeta.binary,
            topicSeparator: commandMeta.topicSeparator,
            commandWithUnderscores,
            examples,
            summary,
            description,
            help,
            isClosedPilotCommand: state === 'closedPilot',
            isOpenPilotCommand: state === 'openPilot',
            isBetaCommand: state === 'beta',
            trailblazerCommunityUrl,
            trailblazerCommunityName,
        });
        this.destination = (0, path_1.join)(ditamap_1.Ditamap.outputDir, topic, filename);
    }
    async getParametersForTemplate(flags) {
        const final = [];
        for (const [flagName, flag] of Object.entries(flags)) {
            if (flag.hidden)
                continue;
            const description = Array.isArray(flag.description) ? flag.description.join('\n') : flag.description || '';
            const entireDescription = flag.summary ? `${flag.summary}\n${description}` : description;
            const updated = Object.assign({}, flag, {
                name: flagName,
                description: this.formatParagraphs(entireDescription),
                optional: !flag.required,
                kind: flag.kind || flag.type,
                hasValue: flag.type !== 'boolean',
                defaultFlagValue: await getDefault(flag),
            });
            final.push(updated);
        }
        return final;
    }
    getTemplateFileName() {
        return 'command.hbs';
    }
    async transformToDitamap() {
        const parameters = await this.getParametersForTemplate(this.flags);
        this.data = Object.assign({}, this.data, { parameters });
        return super.transformToDitamap();
    }
}
exports.Command = Command;
//# sourceMappingURL=command.js.map