"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Docs = void 0;
const mkdirp = require("mkdirp");
const ts_types_1 = require("@salesforce/ts-types");
const chalk = require("chalk");
const base_ditamap_1 = require("./ditamap/base-ditamap");
const cli_reference_1 = require("./ditamap/cli-reference");
const command_1 = require("./ditamap/command");
const topic_commands_1 = require("./ditamap/topic-commands");
const topic_ditamap_1 = require("./ditamap/topic-ditamap");
const utils_1 = require("./utils");
const help_reference_1 = require("./ditamap/help-reference");
function emitNoTopicMetadataWarning(topic) {
    utils_1.events.emit('warning', `No metadata for topic ${chalk.bold(topic)}. That topic owner must add topic metadata in the oclif section in the package.json file within their plugin.`);
}
class Docs {
    constructor(outputDir, plugins, hidden, topicMeta, cliMeta) {
        this.outputDir = outputDir;
        this.plugins = plugins;
        this.hidden = hidden;
        this.topicMeta = topicMeta;
        this.cliMeta = cliMeta;
    }
    async build(commands) {
        // Create if doesn't exist
        await mkdirp(this.outputDir);
        await this.populateTemplate(commands);
    }
    async populateTopic(topic, subtopics) {
        const topicMeta = (0, ts_types_1.ensureJsonMap)(this.topicMeta[topic], `No topic meta for ${topic} - add this topic to the oclif section of the package.json.`);
        let description = (0, ts_types_1.asString)(topicMeta.description);
        if (!description && !topicMeta.external) {
            description = (0, utils_1.punctuate)((0, ts_types_1.asString)(topicMeta.description));
            if (!description) {
                utils_1.events.emit('warning', `No description for topic ${chalk.bold(topic)}. Skipping until topic owner adds topic metadata in the oclif section in the package.json file within their plugin.`);
                return;
            }
        }
        const subTopicNames = [];
        const commandIds = [];
        for (const subtopic of Object.keys(subtopics)) {
            const subtopicOrCommand = (0, ts_types_1.isArray)(subtopics[subtopic])
                ? Object.assign([], subtopics[subtopic])
                : Object.assign({}, subtopics[subtopic]);
            try {
                if (!(0, ts_types_1.isArray)(subtopicOrCommand)) {
                    // If it is not subtopic (array) it is a command in the top-level topic
                    const command = Object.assign({}, subtopicOrCommand);
                    const commandMeta = this.resolveCommandMeta((0, ts_types_1.ensureString)(command.id), command, 1);
                    await this.populateCommand(topic, null, command, commandMeta);
                    commandIds.push(command.id);
                    continue;
                }
                const subTopicsMeta = (0, ts_types_1.ensureJsonMap)(topicMeta.subtopics);
                if (!subTopicsMeta[subtopic]) {
                    emitNoTopicMetadataWarning(`${topic}:${subtopic}`);
                    continue;
                }
                subTopicNames.push(subtopic);
                // Commands within the sub topic
                for (const command of subtopicOrCommand) {
                    const fullTopic = (0, ts_types_1.ensureString)(command.id).replace(/:\w+$/, '');
                    const commandsInFullTopic = subtopicOrCommand.filter((cmd) => (0, ts_types_1.ensureString)(cmd.id).indexOf(fullTopic) === 0);
                    const commandMeta = this.resolveCommandMeta((0, ts_types_1.ensureString)(command.id), command, commandsInFullTopic.length);
                    await this.populateCommand(topic, subtopic, command, commandMeta);
                    commandIds.push(command.id);
                }
            }
            catch (error) {
                if (error.name === 'UnexpectedValueTypeError') {
                    emitNoTopicMetadataWarning(`${topic}:${subtopic}`);
                }
                else {
                    utils_1.events.emit('warning', `Can't create topic for ${topic}:${subtopic}: ${error.message}\n`);
                }
            }
        }
        // The topic ditamap with all of the subtopic links.
        utils_1.events.emit('subtopics', topic, subTopicNames);
        await new topic_commands_1.TopicCommands(topic, topicMeta).write();
        await new topic_ditamap_1.TopicDitamap(topic, commandIds).write();
        return subTopicNames;
    }
    /**
     * Group all commands by the top level topic and then subtopic. e.g. force, analytics, evergreen, etc
     * then org, apex, etc within the force namespace.
     *
     * @param commands - The entire set of command data.
     * @returns The commands grouped by topics/subtopic/commands.
     */
    groupTopicsAndSubtopics(commands) {
        const topLevelTopics = {};
        for (const command of commands) {
            if (command.hidden && !this.hidden) {
                continue;
            }
            const commandParts = (0, ts_types_1.ensureString)(command.id).split(':');
            const topLevelTopic = commandParts[0];
            const plugin = command.plugin;
            if (plugin && this.plugins[plugin.name]) {
                // Also include the namespace on the commands so we don't need to do the split at other times in the code.
                command.topic = topLevelTopic;
                const topics = topLevelTopics[topLevelTopic] || {};
                if (commandParts.length === 1) {
                    // This is a top-level topic that is also a command
                    topics[commandParts[0]] = command;
                }
                else if (commandParts.length === 2) {
                    // This is a command directly under the top-level topic
                    topics[commandParts[1]] = command;
                }
                else {
                    const subtopic = commandParts[1];
                    try {
                        const topicMeta = (0, ts_types_1.ensureJsonMap)(this.topicMeta[topLevelTopic]);
                        const subTopicsMeta = (0, ts_types_1.ensureJsonMap)(topicMeta.subtopics);
                        if (subTopicsMeta.hidden && !this.hidden) {
                            continue;
                        }
                    }
                    catch (e) { } // It means no meta so it isn't hidden, although it should always fail before here with no meta found
                    command.subtopic = subtopic;
                    const existingSubTopics = topics[subtopic];
                    let subtopicCommands = [];
                    if (existingSubTopics) {
                        subtopicCommands = (0, ts_types_1.isArray)(existingSubTopics) ? existingSubTopics : [existingSubTopics];
                    }
                    (0, ts_types_1.ensureArray)(subtopicCommands);
                    subtopicCommands.push(command);
                    topics[subtopic] = subtopicCommands;
                }
                topLevelTopics[topLevelTopic] = topics;
            }
        }
        return topLevelTopics;
    }
    async populateTemplate(commands) {
        const topicsAndSubtopics = this.groupTopicsAndSubtopics(commands);
        await new cli_reference_1.CLIReference().write();
        await new help_reference_1.HelpReference().write();
        const topics = Object.keys(topicsAndSubtopics);
        // Generate one base file with all top-level topics.
        await new base_ditamap_1.BaseDitamap(topics).write();
        for (const topic of topics) {
            utils_1.events.emit('topic', { topic });
            const subtopics = (0, ts_types_1.ensure)(topicsAndSubtopics[topic]);
            await this.populateTopic(topic, subtopics);
        }
    }
    resolveCommandMeta(commandId, command, commandsInTopic) {
        const commandMeta = Object.assign({}, this.cliMeta);
        // Remove top level topic, since the topic meta is already for that topic
        const commandParts = commandId.split(':');
        let part;
        try {
            let currentMeta;
            for (part of commandParts) {
                if (currentMeta) {
                    const subtopics = (0, ts_types_1.ensureJsonMap)(currentMeta.subtopics);
                    currentMeta = (0, ts_types_1.ensureJsonMap)(subtopics[part]);
                }
                else {
                    currentMeta = (0, ts_types_1.ensureJsonMap)(this.topicMeta[part]);
                }
                // Collect all tiers of the meta, so the command will also pick up the topic state (isPilot, etc) if applicable
                Object.assign({}, commandMeta, currentMeta);
            }
        }
        catch (error) {
            if (commandId.endsWith(part)) {
                // This means there wasn't meta information going all the way down to the command, which is ok.
                return commandMeta;
            }
            else {
                if (commandsInTopic !== 1) {
                    utils_1.events.emit('warning', `subtopic "${part}" meta not found for command ${commandId}`);
                }
                else {
                    // Since there is no command meta, just use the command description since that is what oclif does.
                    if (!commandMeta.description) {
                        commandMeta.description = command.description;
                        commandMeta.longDescription = command.longDescription || (0, utils_1.punctuate)(command.description);
                    }
                }
            }
        }
        return commandMeta;
    }
    async populateCommand(topic, subtopic, command, commandMeta) {
        // If it is a hidden command - abort
        if (command.hidden && !this.hidden) {
            return '';
        }
        const commandDitamap = new command_1.Command(topic, subtopic, command, commandMeta);
        await commandDitamap.write();
        return commandDitamap.getFilename();
    }
}
exports.Docs = Docs;
//# sourceMappingURL=docs.js.map