"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPackageVersionCreateRequest = exports.convertPackage = exports.findOrCreatePackage2 = void 0;
const path = require("path");
const os = require("os");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const scratchOrgSettingsGenerator_1 = require("@salesforce/core/lib/org/scratchOrgSettingsGenerator");
const pkgUtils = require("../utils/packageUtils");
const interfaces_1 = require("../interfaces");
const packageUtils_1 = require("../utils/packageUtils");
const packageVersionCreateRequest_1 = require("./packageVersionCreateRequest");
const pvcr = require("./packageVersionCreateRequest");
const packageVersionCreate_1 = require("./packageVersionCreate");
var Package2VersionStatus = interfaces_1.PackagingSObjects.Package2VersionStatus;
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package_version_create');
let logger;
const getLogger = () => {
    if (!logger) {
        logger = core_1.Logger.childFromRoot('packageConvert');
    }
    return logger;
};
async function findOrCreatePackage2(seedPackage, connection) {
    const query = `SELECT Id FROM Package2 WHERE ConvertedFromPackageId = '${seedPackage}'`;
    const queryResult = (await connection.tooling.query(query)).records;
    if (queryResult?.length > 1) {
        const ids = queryResult.map((r) => r.Id);
        throw messages.createError('errorMoreThanOnePackage2WithSeed', [ids.join(', ')]);
    }
    if (queryResult?.length === 1) {
        // return the package2 object
        return queryResult[0].Id;
    }
    // Need to create a new Package2
    const subQuery = `SELECT Name, Description, NamespacePrefix FROM SubscriberPackage WHERE Id = '${seedPackage}'`;
    let subscriberResult;
    try {
        subscriberResult = await connection.singleRecordQuery(subQuery, {
            tooling: true,
        });
    }
    catch (e) {
        throw messages.createError('errorNoSubscriberPackageRecord', [seedPackage]);
    }
    const request = {
        Name: subscriberResult.Name,
        Description: subscriberResult.Description,
        NamespacePrefix: subscriberResult.NamespacePrefix,
        ContainerOptions: 'Managed',
        ConvertedFromPackageId: seedPackage,
    };
    const createResult = await connection.tooling.create('Package2', request);
    if (!createResult.success) {
        throw pkgUtils.combineSaveErrors('Package2', 'create', createResult.errors);
    }
    return createResult.id;
}
exports.findOrCreatePackage2 = findOrCreatePackage2;
async function convertPackage(pkg, connection, options, project) {
    let maxRetries = 0;
    const branch = 'main';
    if (options.wait) {
        maxRetries = (60 / pkgUtils.POLL_INTERVAL_SECONDS) * options.wait.minutes;
    }
    const packageId = await findOrCreatePackage2(pkg, connection);
    const apiVersion = project?.getSfProjectJson()?.get('sourceApiVersion');
    const request = await createPackageVersionCreateRequest({
        installationkey: options.installationKey,
        definitionfile: options.definitionfile,
        buildinstance: options.buildInstance,
        seedmetadata: options.seedMetadata,
    }, packageId, apiVersion);
    // TODO: a lot of this is duplicated from PC, PVC, and PVCR.
    const createResult = await connection.tooling.create('Package2VersionCreateRequest', request);
    if (!createResult.success) {
        const errStr = createResult?.errors.length ? createResult.errors.join(', ') : createResult.errors;
        throw messages.createError('failedToCreatePVCRequest', [
            createResult.id ? ` [${createResult.id}]` : '',
            errStr.toString(),
        ]);
    }
    let results;
    if (options.wait) {
        results = await pollForStatusWithInterval(createResult.id, maxRetries, packageId, branch, project, connection, options.frequency ?? kit_1.Duration.seconds(pkgUtils.POLL_INTERVAL_SECONDS));
    }
    else {
        results = await (0, packageVersionCreateRequest_1.byId)(packageId, connection);
    }
    return Array.isArray(results) ? results[0] : results;
}
exports.convertPackage = convertPackage;
/**
 * Convert the list of command line options to a JSON object that can be used to create an Package2VersionCreateRequest entity.
 *
 * @param context: command context
 * @param packageId: package2 id to create a package version for
 * @returns {{Package2Id: string, Package2VersionMetadata: *, Tag: *, Branch: number}}
 * @private
 */
async function createPackageVersionCreateRequest(context, packageId, apiVersion) {
    const uniqueId = (0, packageUtils_1.uniqid)({ template: `${packageId}-%s` });
    const packageVersTmpRoot = path.join(os.tmpdir(), uniqueId);
    const packageVersMetadataFolder = path.join(packageVersTmpRoot, 'md-files');
    const seedMetadataFolder = path.join(packageVersTmpRoot, 'seed-md-files');
    const packageVersBlobDirectory = path.join(packageVersTmpRoot, 'package-version-info');
    const seedMetadataZipFile = path.join(packageVersBlobDirectory, 'seed-metadata-package.zip');
    const settingsZipFile = path.join(packageVersBlobDirectory, 'settings.zip');
    const metadataZipFile = path.join(packageVersBlobDirectory, 'package.zip');
    const packageVersBlobZipFile = path.join(packageVersTmpRoot, 'package-version-info.zip');
    const packageDescriptorJson = {
        id: packageId,
    };
    const settingsGenerator = new scratchOrgSettingsGenerator_1.default({ asDirectory: true });
    const definitionFile = context.definitionfile;
    let definitionFileJson;
    if (definitionFile) {
        try {
            const definitionFilePayload = await fs.promises.readFile(definitionFile, 'utf8');
            definitionFileJson = JSON.parse(definitionFilePayload);
        }
        catch (err) {
            throw messages.createError('errorReadingDefintionFile', [err]);
        }
        // Load any settings from the definition
        await settingsGenerator.extract(definitionFileJson);
        if (settingsGenerator.hasSettings() && definitionFileJson.orgPreferences) {
            // this is not allowed, exit with an error
            throw messages.createError('signupDuplicateSettingsSpecified');
        }
        ['country', 'edition', 'language', 'features', 'orgPreferences', 'snapshot', 'release', 'sourceOrg'].forEach((prop) => {
            const propValue = definitionFileJson[prop];
            if (propValue) {
                packageDescriptorJson[prop] = propValue;
            }
        });
    }
    await fs.promises.mkdir(packageVersTmpRoot, { recursive: true });
    await fs.promises.mkdir(packageVersBlobDirectory, { recursive: true });
    await fs.promises.mkdir(packageVersMetadataFolder, { recursive: true });
    const hasSeedMetadata = await new packageVersionCreate_1.MetadataResolver().resolveMetadata(context.seedmetadata, seedMetadataFolder, 'seedMDDirectoryDoesNotExist', apiVersion);
    if (hasSeedMetadata) {
        // Zip the seedMetadataFolder folder and put the zip in {packageVersBlobDirectory}/{seedMetadataZipFile}
        getLogger().debug(`Including metadata found in '${context.seedmetadata}'.`);
        await pkgUtils.zipDir(seedMetadataFolder, seedMetadataZipFile);
    }
    await settingsGenerator.createDeploy();
    await settingsGenerator.createDeployPackageContents(apiVersion);
    await pkgUtils.zipDir(`${settingsGenerator.getDestinationPath()}${path.sep}${settingsGenerator.getShapeDirName()}`, settingsZipFile);
    const shapeDirectory = `${settingsGenerator.getDestinationPath()}${path.sep}${settingsGenerator.getShapeDirName()}`;
    const currentPackageXml = await fs.promises.readFile(path.join(shapeDirectory, 'package.xml'), 'utf8');
    await fs.promises.writeFile(path.join(packageVersMetadataFolder, 'package.xml'), currentPackageXml, 'utf-8');
    // Zip the packageVersMetadataFolder folder and put the zip in {packageVersBlobDirectory}/package.zip
    await pkgUtils.zipDir(packageVersMetadataFolder, metadataZipFile);
    await fs.promises.writeFile(path.join(packageVersBlobDirectory, 'package2-descriptor.json'), JSON.stringify(packageDescriptorJson, undefined, 2));
    // Zip the Version Info and package.zip files into another zip
    await pkgUtils.zipDir(packageVersBlobDirectory, packageVersBlobZipFile);
    return createRequestObject(packageId, context, packageVersTmpRoot, packageVersBlobZipFile);
}
exports.createPackageVersionCreateRequest = createPackageVersionCreateRequest;
async function createRequestObject(packageId, options, packageVersTmpRoot, packageVersBlobZipFile) {
    const zipFileBase64 = (await fs.promises.readFile(packageVersBlobZipFile)).toString('base64');
    const requestObject = {
        Package2Id: packageId,
        VersionInfo: zipFileBase64,
        InstallKey: options.installationkey,
        Instance: options.buildinstance,
        IsConversionRequest: true,
    };
    await fs.promises.rm(packageVersTmpRoot, { recursive: true });
    return requestObject;
}
async function pollForStatusWithInterval(id, retries, packageId, branch, project, connection, interval) {
    let remainingRetries = retries;
    const pollingClient = await core_1.PollingClient.create({
        poll: async () => {
            const results = await pvcr.byId(id, connection);
            if (isStatusEqualTo(results, [Package2VersionStatus.success, Package2VersionStatus.error])) {
                // complete
                if (isStatusEqualTo(results, [Package2VersionStatus.success])) {
                    // update sfdx-project.json
                    let projectUpdated = false;
                    if (project && !process.env.SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_VERSION_CREATE) {
                        projectUpdated = true;
                        const query = `SELECT MajorVersion, MinorVersion, PatchVersion, BuildNumber FROM Package2Version WHERE Id = '${results[0].Package2VersionId}'`;
                        const packageVersionVersionString = await connection.tooling
                            .query(query)
                            .then((pkgQueryResult) => {
                            const record = pkgQueryResult.records[0];
                            return `${record.MajorVersion}.${record.MinorVersion}.${record.PatchVersion}-${record.BuildNumber}`;
                        });
                        const [alias, writtenId] = await (0, packageUtils_1.generatePackageAliasEntry)(connection, project, results[0].SubscriberPackageVersionId, packageVersionVersionString, branch, packageId);
                        project.getSfProjectJson().addPackageAlias(alias, writtenId);
                        await project.getSfProjectJson().write();
                    }
                    await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageEvents.convert.success, {
                        id,
                        packageVersionCreateRequestResult: results[0],
                        projectUpdated,
                    });
                    return { completed: true, payload: results[0] };
                }
                else {
                    let status = 'Unknown Error';
                    if (results?.length > 0 && results[0].Error.length > 0) {
                        const errors = [];
                        // for multiple errors, display one per line prefixed with (x)
                        if (results[0].Error.length > 1) {
                            results[0].Error.forEach((error) => {
                                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                                errors.push(`(${errors.length + 1}) ${error}`);
                            });
                            errors.unshift(messages.getMessage('versionCreateFailedWithMultipleErrors'));
                        }
                        status = errors.length !== 0 ? errors.join('\n') : results[0].Error.join('\n');
                    }
                    await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageEvents.convert.error, { id, status });
                    throw new core_1.SfError(status);
                }
            }
            else {
                const remainingTime = kit_1.Duration.seconds(interval.seconds * remainingRetries);
                await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageEvents.convert.progress, {
                    id,
                    packageVersionCreateRequestResult: results[0],
                    message: '',
                    timeRemaining: remainingTime,
                });
                getLogger().info(`Request in progress. Sleeping ${interval.seconds} seconds. Will wait a total of ${remainingTime.seconds} more seconds before timing out. Current Status='${(0, kit_1.camelCaseToTitleCase)(results[0]?.Status)}'`);
                remainingRetries--;
                return { completed: false, payload: results[0] };
            }
        },
        frequency: kit_1.Duration.seconds(interval.seconds),
        timeout: kit_1.Duration.seconds(interval.seconds * retries),
    });
    return pollingClient.subscribe();
}
/**
 * Return true if the queryResult.records[0].Status is equal to one of the values in statuses.
 *
 * @param results to examine
 * @param statuses array of statuses to look for
 * @returns {boolean} if one of the values in status is found.
 */
function isStatusEqualTo(results, statuses) {
    return results?.length <= 0 ? false : statuses?.some((status) => results[0].Status === status);
}
//# sourceMappingURL=packageConvert.js.map