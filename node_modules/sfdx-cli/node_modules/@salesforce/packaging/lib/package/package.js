"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package = exports.Package2Fields = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const packageUtils_1 = require("../utils/packageUtils");
const packageCreate_1 = require("./packageCreate");
const packageConvert_1 = require("./packageConvert");
const packageVersionList_1 = require("./packageVersionList");
const packageDelete_1 = require("./packageDelete");
const packageAncestry_1 = require("./packageAncestry");
const packagePrefixes = {
    PackageId: '0Ho',
    SubscriberPackageVersionId: '04t',
    PackageInstallRequestId: '0Hf',
    PackageUninstallRequestId: '06y',
};
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package');
exports.Package2Fields = [
    'Id',
    'IsDeleted',
    'CreatedDate',
    'CreatedById',
    'LastModifiedDate',
    'LastModifiedById',
    'SystemModstamp',
    'SubscriberPackageId',
    'Name',
    'Description',
    'NamespacePrefix',
    'ContainerOptions',
    'IsDeprecated',
    'IsOrgDependent',
    'ConvertedFromPackageId',
    'PackageErrorUsername',
];
/**
 * Provides the ability to list, create, update, delete, convert, and get version
 * ancestry for a 2nd generation package.
 *
 * **Examples**
 *
 * Create a new instance and get the ID (0Ho):
 *
 * `const id = new Package({connection, project, packageOrAliasId}).getId();`
 *
 * Create a new package in the org:
 *
 * `const myPkg = await Package.create(connection, project, options);`
 *
 * List all packages in the org:
 *
 * `const pkgList = await Package.list(connection);`
 */
class Package {
    constructor(options) {
        this.options = options;
        let packageId = this.options.packageAliasOrId;
        if (!packageId.startsWith(packagePrefixes.PackageId)) {
            packageId =
                this.options.project.getPackageIdFromAlias(this.options.packageAliasOrId) ?? this.options.packageAliasOrId;
            if (packageId === this.options.packageAliasOrId) {
                throw messages.createError('packageAliasNotFound', [this.options.packageAliasOrId]);
            }
        }
        if (packageId.startsWith(packagePrefixes.PackageId)) {
            this.packageId = packageId;
        }
        else {
            throw messages.createError('invalidPackageId', [this.options.packageAliasOrId, packagePrefixes.PackageId]);
        }
    }
    /**
     * Create a new package.
     *
     * @param connection - instance of Connection
     * @param project - instance of SfProject
     * @param options - options for creating a package - see PackageCreateOptions
     * @returns Package
     */
    static async create(connection, project, options) {
        return (0, packageCreate_1.createPackage)(connection, project, options);
    }
    /**
     * Returns all the packages that are available in the org.
     *
     * @param connection
     */
    static async list(connection) {
        return (await connection.tooling.query(`select ${exports.Package2Fields.toString()} from Package2 ORDER BY NamespacePrefix, Name`, {
            autoFetch: true,
            maxFetch: 10000,
        }))?.records;
    }
    /**
     * Returns the package versions in the org.
     * See {@link PackageVersionListOptions} for list options
     *
     * @param connection - connection to the org
     * @param project - instance of SfProject
     * @param options - see {@link PackageVersionListOptions}
     */
    static async listVersions(connection, project, options) {
        // resolve/verify packages
        const packages = options?.packages?.map((pkg) => {
            const id = project.getPackageIdFromAlias(pkg) ?? pkg;
            // validate ID
            if (id.startsWith('0Ho')) {
                (0, packageUtils_1.validateId)(packageUtils_1.BY_LABEL.PACKAGE_ID, id);
                return id;
            }
            else {
                throw messages.createError('invalidPackageId', [id, '0Ho']);
            }
        });
        const opts = options || {};
        opts.packages = packages || [];
        return (await (0, packageVersionList_1.listPackageVersions)({ ...opts, ...{ connection } })).records;
    }
    /**
     * create a PackageAncestry instance
     *
     * @param packageId to get version information for
     * @param project SfProject instance
     * @param connection Hub Org Connection
     */
    static async getAncestry(packageId, project, connection) {
        return packageAncestry_1.PackageAncestry.create({
            packageId,
            project,
            connection,
        });
    }
    /**
     * Convert a 1st generation package to a 2nd generation package.
     * See {@link ConvertPackageOptions} for conversion options.
     *
     * @param pkgId the 1GP package ID (033) of the package to convert
     * @param connection
     * @param options {@link ConvertPackageOptions}
     * @param project
     */
    static async convert(pkgId, connection, options, project) {
        return (0, packageConvert_1.convertPackage)(pkgId, connection, options, project);
    }
    /**
     * Returns the package ID of the package.
     *
     * @returns {string} package ID (0Ho)
     */
    getId() {
        return this.packageId;
    }
    /**
     * Returns the package type of the package.
     *
     * @returns {Promise<PackageType>}
     */
    async getType() {
        return (await this.getPackageData()).ContainerOptions;
    }
    /**
     * Returns the list of package versions for the package.
     * See {@link PackageVersionListOptions} for list options
     *
     * @param options
     * @returns {Promise<PackageVersionListResult[]>}
     */
    async getPackageVersions(options) {
        const packageOptions = {
            packages: [this.packageId],
        };
        return Package.listVersions(this.options.connection, this.options.project, {
            ...packageOptions,
            ...options,
        });
    }
    /**
     * Deletes the package.
     *
     */
    async delete() {
        return (0, packageDelete_1.deletePackage)(this.getId(), this.options.project, this.options.connection, false);
    }
    /**
     * Un-Deletes the package.
     *
     */
    async undelete() {
        return (0, packageDelete_1.deletePackage)(this.getId(), this.options.project, this.options.connection, true);
    }
    /**
     * Updates the package using the values defined in the options.
     * See {@link PackageUpdateOptions} for update options.
     *
     * @param options
     */
    async update(options) {
        try {
            // filter out any undefined values and their keys
            Object.keys(options).forEach((key) => options[key] === undefined && delete options[key]);
            const result = await this.options.connection.tooling.update('Package2', options);
            if (!result.success) {
                throw new core_1.SfError(result.errors.join(', '));
            }
            return result;
        }
        catch (err) {
            throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
        }
    }
    /**
     * Returns the package data for the package.
     *
     * @param force force a refresh of the package data
     */
    async getPackageData(force = false) {
        if (!this.packageData || force) {
            this.packageData = (await this.options.connection.tooling
                .sobject('Package2')
                .retrieve(this.packageId));
        }
        return this.packageData;
    }
}
exports.Package = Package;
//# sourceMappingURL=package.js.map