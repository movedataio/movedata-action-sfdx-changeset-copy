"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageVersion = exports.Package2VersionFields = void 0;
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const interfaces_1 = require("../interfaces");
const packageUtils_1 = require("../utils/packageUtils");
const packageVersionCreate_1 = require("./packageVersionCreate");
const packageVersionReport_1 = require("./packageVersionReport");
const packageVersionCreateRequestReport_1 = require("./packageVersionCreateRequestReport");
const packageVersionCreateRequest_1 = require("./packageVersionCreateRequest");
var Package2VersionStatus = interfaces_1.PackagingSObjects.Package2VersionStatus;
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package_version');
exports.Package2VersionFields = [
    'Id',
    'IsDeleted',
    'CreatedDate',
    'CreatedById',
    'LastModifiedDate',
    'LastModifiedById',
    'SystemModstamp',
    'Package2Id',
    'SubscriberPackageVersionId',
    'Tag',
    'Branch',
    'AncestorId',
    'ValidationSkipped',
    'Name',
    'Description',
    'MajorVersion',
    'MinorVersion',
    'PatchVersion',
    'BuildNumber',
    'IsDeprecated',
    'IsPasswordProtected',
    'CodeCoverage',
    'CodeCoveragePercentages',
    'HasPassedCodeCoverageCheck',
    'InstallKey',
    'IsReleased',
    'ConvertedFromVersionId',
    'ReleaseVersion',
    'BuildDurationInSeconds',
    'HasMetadataRemoved',
];
/**
 * Provides the ability to create, update, delete, and promote 2nd
 * generation package versions.
 *
 * **Examples**
 *
 * Create a new instance and get the ID (05i):
 *
 * `const id = new PackageVersion({connection, project, idOrAlias}).getId();`
 *
 * Create a new package version in the org:
 *
 * `const myPkgVersion = await PackageVersion.create(options, pollingOptions);`
 *
 * Promote a package version:
 *
 * `new PackageVersion({connection, project, idOrAlias}).promote();`
 */
class PackageVersion {
    constructor(options) {
        this.options = options;
        this.connection = this.options.connection;
        this.project = this.options.project;
        this.data = {};
        const id = this.resolveId();
        // validate ID
        if (id.startsWith('04t')) {
            (0, packageUtils_1.validateId)(packageUtils_1.BY_LABEL.SUBSCRIBER_PACKAGE_VERSION_ID, id);
            this.data.SubscriberPackageVersionId = id;
        }
        else if (id.startsWith('05i')) {
            (0, packageUtils_1.validateId)(packageUtils_1.BY_LABEL.PACKAGE_VERSION_ID, id);
            this.data.Id = id;
        }
        else {
            throw messages.createError('errorInvalidPackageVersionId', [this.options.idOrAlias]);
        }
    }
    /**
     * Sends a request to create a new package version and optionally polls for
     * the status of the request until the package version is created or the
     * polling timeout is reached.
     *
     * @param options PackageVersionCreateOptions
     * @param polling frequency and timeout Durations to be used in polling
     * @returns PackageVersionCreateRequestResult
     */
    static async create(options, polling = {
        frequency: kit_1.Duration.seconds(0),
        timeout: kit_1.Duration.seconds(0),
    }) {
        const pvc = new packageVersionCreate_1.PackageVersionCreate({ ...options });
        const createResult = await pvc.createPackageVersion();
        return PackageVersion.pollCreateStatus(createResult.Id, options.connection, options.project, polling).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
        });
    }
    /**
     * Gets current state of a package version create request.
     *
     * @param createPackageRequestId
     * @param connection
     */
    static async getCreateStatus(createPackageRequestId, connection) {
        return (0, packageVersionCreateRequestReport_1.getCreatePackageVersionCreateRequestReport)({
            createPackageVersionRequestId: createPackageRequestId,
            connection,
        }).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
        });
    }
    /**
     * Fetch a list of package version create requests based on the given options.
     *
     * @param connection connection to an org
     * @param options PackageVersionCreateRequestQueryOptions
     * @returns the list of package version create requests.
     */
    static async getPackageVersionCreateRequests(connection, options) {
        return (0, packageVersionCreateRequest_1.list)({ ...options, connection });
    }
    /**
     * Convenience function that will wait for a package version to be created.
     *
     * This function emits LifeCycle events, "enqueued", "in-progress", "success", "error" and "timed-out" to
     * progress and current status. Events also carry a payload of type PackageVersionCreateRequestResult.
     *
     * @param createPackageVersionRequestId
     * @param connection Connection to the org
     * @param project SfProject to read/write aliases from
     * @param polling frequency and timeout Durations to be used in polling
     * */
    static async pollCreateStatus(createPackageVersionRequestId, connection, project, polling) {
        if (polling.timeout?.milliseconds <= 0) {
            return this.getCreateStatus(createPackageVersionRequestId, connection);
        }
        let remainingWaitTime = polling.timeout;
        let report;
        const pollingClient = await core_1.PollingClient.create({
            poll: async () => {
                report = await this.getCreateStatus(createPackageVersionRequestId, connection);
                switch (report.Status) {
                    case Package2VersionStatus.queued:
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.enqueued, { ...report, remainingWaitTime });
                        remainingWaitTime = kit_1.Duration.seconds(remainingWaitTime.seconds - polling.frequency.seconds);
                        return {
                            completed: false,
                            payload: report,
                        };
                    case Package2VersionStatus.inProgress:
                    case Package2VersionStatus.initializing:
                    case Package2VersionStatus.verifyingFeaturesAndSettings:
                    case Package2VersionStatus.verifyingDependencies:
                    case Package2VersionStatus.verifyingMetadata:
                    case Package2VersionStatus.finalizingPackageVersion:
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.progress, {
                            ...report,
                            remainingWaitTime,
                        });
                        remainingWaitTime = kit_1.Duration.seconds(remainingWaitTime.seconds - polling.frequency.seconds);
                        return {
                            completed: false,
                            payload: report,
                        };
                    case Package2VersionStatus.success: {
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.success, report);
                        const packageVersion = new PackageVersion({
                            connection,
                            project,
                            idOrAlias: report.Package2VersionId,
                        });
                        await packageVersion.updateProjectWithPackageVersion(report);
                        return { completed: true, payload: report };
                    }
                    case Package2VersionStatus.error:
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.error, report);
                        return { completed: true, payload: report };
                }
            },
            frequency: polling.frequency,
            timeout: polling.timeout,
        });
        try {
            return await pollingClient.subscribe();
        }
        catch (err) {
            await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create['timed-out'], report);
            throw (0, packageUtils_1.applyErrorAction)(err);
        }
    }
    /**
     * Gets current state of a package version create request.
     *
     * @param createPackageRequestId
     * @param connection
     */
    static async getCreateVersionReport(createPackageRequestId, connection) {
        return (0, packageVersionCreateRequestReport_1.getCreatePackageVersionCreateRequestReport)({
            createPackageVersionRequestId: createPackageRequestId,
            connection,
        }).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
        });
    }
    /**
     * Convenience function that will wait for a package version to be created.
     *
     * This function emits LifeCycle events, "enqueued", "in-progress", "success", "error" and "timed-out" to
     * progress and current status. Events also carry a payload of type PackageVersionCreateRequestResult.
     *
     * @param createPackageVersionRequestId
     * @param project
     * @param connection
     * @param polling frequency and timeout Durations to be used in polling
     * */
    static async waitForCreateVersion(createPackageVersionRequestId, project, connection, polling) {
        if (polling.timeout?.milliseconds <= 0) {
            return PackageVersion.getCreateVersionReport(createPackageVersionRequestId, connection);
        }
        let remainingWaitTime = polling.timeout;
        let report;
        const pollingClient = await core_1.PollingClient.create({
            poll: async () => {
                report = await this.getCreateVersionReport(createPackageVersionRequestId, connection);
                switch (report.Status) {
                    case Package2VersionStatus.queued:
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.enqueued, { ...report, remainingWaitTime });
                        remainingWaitTime = kit_1.Duration.seconds(remainingWaitTime.seconds - polling.frequency.seconds);
                        return {
                            completed: false,
                            payload: report,
                        };
                    case Package2VersionStatus.inProgress:
                    case Package2VersionStatus.initializing:
                    case Package2VersionStatus.verifyingFeaturesAndSettings:
                    case Package2VersionStatus.verifyingDependencies:
                    case Package2VersionStatus.verifyingMetadata:
                    case Package2VersionStatus.finalizingPackageVersion:
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.progress, {
                            ...report,
                            remainingWaitTime,
                        });
                        remainingWaitTime = kit_1.Duration.seconds(remainingWaitTime.seconds - polling.frequency.seconds);
                        return {
                            completed: false,
                            payload: report,
                        };
                    case Package2VersionStatus.success:
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.success, report);
                        await new PackageVersion({
                            idOrAlias: report.SubscriberPackageVersionId,
                            project,
                            connection,
                        }).updateProjectWithPackageVersion(report);
                        return { completed: true, payload: report };
                    case Package2VersionStatus.error:
                        await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create.error, report);
                        return { completed: true, payload: report };
                }
            },
            frequency: polling.frequency,
            timeout: polling.timeout,
        });
        try {
            return await pollingClient.subscribe();
        }
        catch (err) {
            await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageVersionEvents.create['timed-out'], report);
            throw (0, packageUtils_1.applyErrorAction)(err);
        }
    }
    /**
     * Get the package version ID for this PackageVersion.
     *
     * @returns The PackageVersionId (05i).
     */
    async getId() {
        if (!this.data.Id) {
            await this.getData();
        }
        return this.data.Id;
    }
    /**
     * Get the subscriber package version ID for this PackageVersion.
     *
     * @returns The SubscriberPackageVersionId (04t).
     */
    async getSubscriberId() {
        if (!this.data.SubscriberPackageVersionId) {
            await this.getData();
        }
        return this.data.SubscriberPackageVersionId;
    }
    /**
     * Get the package Id for this PackageVersion.
     *
     * @returns The PackageId (0Ho).
     */
    async getPackageId() {
        if (!this.data.Package2Id) {
            await this.getData();
        }
        return this.data.Package2Id;
    }
    /**
     * Get the package type for this PackageVersion.
     *
     * @returns The PackageType (Managed, Unlocked).
     */
    async getPackageType() {
        if (!this.packageType) {
            this.packageType = (await this.connection.singleRecordQuery(`select ContainerOptions from Package2 where Id = '${await this.getPackageId()}' limit 1`, { tooling: true })).ContainerOptions;
        }
        return this.packageType;
    }
    /**
     * Get the Package2Version SObject data for this PackageVersion.
     *
     * @param force force a refresh of the package version data.
     * @returns Package2Version
     */
    async getData(force = false) {
        if (!this.data.Name || force) {
            let queryConfig;
            if (this.data.Id) {
                queryConfig = {
                    id: this.data.Id,
                    clause: `Id = '${this.data.Id}'`,
                    label1: packageUtils_1.BY_LABEL.PACKAGE_VERSION_ID.label,
                    label2: packageUtils_1.BY_LABEL.SUBSCRIBER_PACKAGE_VERSION_ID.label,
                };
            }
            else {
                queryConfig = {
                    id: this.data.SubscriberPackageVersionId,
                    clause: `SubscriberPackageVersionId = '${this.data.SubscriberPackageVersionId}'`,
                    label1: packageUtils_1.BY_LABEL.SUBSCRIBER_PACKAGE_VERSION_ID.label,
                    label2: packageUtils_1.BY_LABEL.PACKAGE_VERSION_ID.label,
                };
            }
            const allFields = exports.Package2VersionFields.toString();
            const query = `SELECT ${allFields} FROM Package2Version WHERE ${queryConfig.clause} LIMIT 1`;
            try {
                this.data = await this.connection.singleRecordQuery(query, { tooling: true });
            }
            catch (err) {
                throw messages.createError('errorInvalidIdNoMatchingVersionId', [queryConfig.label1, queryConfig.id, queryConfig.label2], undefined, err);
            }
        }
        return this.data;
    }
    /**
     * Deletes this PackageVersion.
     */
    async delete() {
        return this.updateDeprecation(true);
    }
    /**
     * Undeletes this PackageVersion.
     */
    async undelete() {
        return this.updateDeprecation(false);
    }
    /**
     * Reports details about this PackageVersion.
     *
     * @param verbose Whether to get a detailed version of the report, at the expense of performance.
     */
    async report(verbose = false) {
        const packageVersionId = await this.getId();
        const results = await (0, packageVersionReport_1.getPackageVersionReport)({
            packageVersionId,
            connection: this.connection,
            project: this.project,
            verbose,
        }).catch((err) => {
            // TODO
            // until package2 is GA, wrap perm-based errors w/ 'contact sfdc' action (REMOVE once package2 is GA'd)
            throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
        });
        return results[0];
    }
    /**
     * Promotes this PackageVersion to released state.
     */
    async promote() {
        const id = await this.getId();
        return this.options.connection.tooling.update('Package2Version', { IsReleased: true, Id: id });
    }
    async update(options) {
        const id = await this.getId();
        const request = {
            Id: id,
            InstallKey: options.InstallKey,
            Name: options.VersionName,
            Description: options.VersionDescription,
            Branch: options.Branch,
            Tag: options.Tag,
        };
        // filter out any undefined values and their keys
        Object.keys(request).forEach((key) => request[key] === undefined && delete request[key]);
        const result = await this.connection.tooling.update('Package2Version', request);
        if (!result.success) {
            throw new Error(result.errors.join(', '));
        }
        // Use the 04t ID for the success message
        result.id = await this.getSubscriberId();
        return result;
    }
    async updateDeprecation(isDeprecated) {
        const id = await this.getId();
        // setup the request
        const request = {
            Id: id,
            IsDeprecated: isDeprecated,
        };
        const updateResult = await this.connection.tooling.update('Package2Version', request);
        if (!updateResult.success) {
            throw (0, packageUtils_1.combineSaveErrors)('Package2', 'update', updateResult.errors);
        }
        updateResult.id = await this.getSubscriberId();
        return updateResult;
    }
    async updateProjectWithPackageVersion(results) {
        if (!process.env.SFDX_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_VERSION_CREATE) {
            // get the newly created package version from the server
            const versionResult = (await this.connection.tooling.query(`SELECT Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber FROM Package2Version WHERE SubscriberPackageVersionId='${results.SubscriberPackageVersionId}'`)).records[0];
            const aliases = this.project.getAliasesFromPackageId(results.Package2Id);
            if (aliases.length === 0) {
                throw messages.createError('packageAliasNotFound', [results.Package2Id]);
            }
            const version = `${aliases[0]}@${versionResult.MajorVersion ?? 0}.${versionResult.MinorVersion ?? 0}.${versionResult.PatchVersion ?? 0}`;
            const build = versionResult.BuildNumber ? `-${versionResult.BuildNumber}` : '';
            const branch = versionResult.Branch ? `-${versionResult.Branch}` : '';
            // set packageAliases entry '<package>@<major>.<minor>.<patch>-<build>-<branch>: <result.subscriberPackageVersionId>'
            this.project.getSfProjectJson().getContents().packageAliases[`${version}${build}${branch}`] =
                results.SubscriberPackageVersionId;
            await this.project.getSfProjectJson().write();
        }
    }
    resolveId() {
        return this.project.getPackageIdFromAlias(this.options.idOrAlias) ?? this.options.idOrAlias;
    }
}
exports.PackageVersion = PackageVersion;
//# sourceMappingURL=packageVersion.js.map