"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StagedProgress = exports.StateConstants = exports.boldPurple = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const chalk = require("chalk");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const compareStages = ([, aValue], [, bValue]) => aValue.index - bValue.index;
exports.boldPurple = chalk.rgb(157, 129, 221).bold;
exports.StateConstants = {
    inProgress: { color: exports.boldPurple, char: '…', visited: false, state: 'inProgress' },
    completed: { color: sf_plugins_core_1.StandardColors.success, char: '✓', visited: false, state: 'completed' },
    failed: { color: chalk.bold.red, char: '✖', visited: false, state: 'failed' },
    unknown: { color: chalk.dim, char: '…', visited: false, state: 'unknown' },
};
class StagedProgress {
    constructor(stages) {
        this.theStages = stages
            .map((stage, index) => ({
            [stage]: { ...exports.StateConstants['unknown'], index: (index + 1) * 10 },
        }))
            .reduce((m, b) => Object.assign(m, b), {});
    }
    get statusData() {
        return this.dataForTheStatus;
    }
    set statusData(statusData) {
        this.dataForTheStatus = statusData;
    }
    formatStages() {
        return Object.entries(this.theStages)
            .sort(compareStages)
            .map(([stage, stageState]) => stageState.color(`${stageState.char} - ${stage}`))
            .join(os.EOL);
    }
    transitionStages(currentStage, newState) {
        currentStage = this.mapCurrentStage(currentStage);
        if (this.previousStage && this.previousStage !== currentStage) {
            this.updateStages(this.previousStage, 'completed');
        }
        // mark all previous stages as visited and completed
        this.markPreviousStagesAsCompleted(currentStage);
        this.previousStage = currentStage;
        this.currentStage = currentStage;
        this.updateStages(currentStage, newState);
    }
    markPreviousStagesAsCompleted(currentStage) {
        if (currentStage) {
            currentStage = this.mapCurrentStage(currentStage);
        }
        Object.entries(this.theStages).forEach(([stage, stageState]) => {
            if (!currentStage || stageState.index < (this.theStages[currentStage]?.index ?? 0)) {
                this.updateStages(stage, 'completed');
            }
        });
    }
    updateCurrentStage(newState) {
        if (!this.currentStage) {
            throw new core_1.SfError('transitionStages must be called before updateCurrentStage');
        }
        this.updateStages(this.currentStage, newState);
    }
    updateStages(currentStage, newState) {
        currentStage = this.mapCurrentStage(currentStage);
        if (!this.theStages[currentStage]) {
            const sortedEntries = Object.entries(this.theStages).sort(compareStages);
            const visitedEntries = sortedEntries.filter(([, stageState]) => stageState.visited);
            const [, lastState] = visitedEntries.length
                ? visitedEntries[visitedEntries.length - 1]
                : ['', { state: exports.StateConstants.unknown.state, index: 0, visited: true }];
            const newEntry = {
                [currentStage]: { state: exports.StateConstants.unknown.state, visited: true, index: lastState.index + 1 },
            };
            this.theStages = Object.assign(this.theStages, newEntry);
        }
        this.theStages[currentStage].visited = true;
        this.theStages[currentStage].state = newState ?? 'inProgress';
        this.theStages[currentStage].char = exports.StateConstants[this.theStages[currentStage].state].char;
        if (newState) {
            this.theStages[currentStage].color = exports.StateConstants[newState.toString()].color;
        }
    }
    getStages() {
        return this.theStages;
    }
    // eslint-disable-next-line class-methods-use-this
    mapCurrentStage(currentStage) {
        return currentStage;
    }
}
exports.StagedProgress = StagedProgress;
//# sourceMappingURL=stagedProgress.js.map