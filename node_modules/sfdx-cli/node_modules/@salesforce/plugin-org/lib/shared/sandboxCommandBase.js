"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxCommandBase = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const sandboxProgress_1 = require("./sandboxProgress");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'sandboxbase');
class SandboxCommandBase extends sf_plugins_core_1.SfCommand {
    constructor(argv, config) {
        super(argv, config);
        this.pollingTimeOut = false;
        this.sandboxProgress = new sandboxProgress_1.SandboxProgress();
    }
    async getSandboxRequestConfig() {
        if (!this.sandboxRequestConfig) {
            this.sandboxRequestConfig = await core_1.SandboxRequestCache.create();
        }
        return this.sandboxRequestConfig;
    }
    async calculateTrackingSetting(tracking = true) {
        // sandbox types that don't support tracking
        if (this.sandboxRequestData?.sandboxRequest.LicenseType &&
            ['Partial', 'Full'].includes(this.sandboxRequestData.sandboxRequest.LicenseType)) {
            return false;
        }
        // returns false for a sandbox type that supports it but user has opted out
        if (tracking === false) {
            return false;
        }
        // on a resume, we might not have a prod org...it's optional?
        if (this.prodOrg) {
            // if user hasn't opted out of tracking, and sandbox type supports it, verify that prod org supports tracking-enabled sandboxes
            const sourceTrackingSettings = await this.prodOrg
                .getConnection()
                .metadata.read('SourceTrackingSettings', 'SourceTrackingSettings');
            if (sourceTrackingSettings.enableSourceTrackingSandboxes !== true) {
                return false;
            }
        }
        // default for Dev/DevPro when prod org has feature enabled for sandboxes
        return true;
    }
    registerLifecycleListeners(lifecycle, options) {
        lifecycle.on('POLLING_TIME_OUT', async () => {
            this.pollingTimeOut = true;
            return Promise.resolve(this.updateSandboxRequestData());
        });
        lifecycle.on(core_1.SandboxEvents.EVENT_RESUME, async (results) => {
            this.latestSandboxProgressObj = results;
            this.sandboxProgress.markPreviousStagesAsCompleted(results.Status !== 'Completed' ? results.Status : 'Authenticating');
            return Promise.resolve(this.updateSandboxRequestData());
        });
        lifecycle.on(core_1.SandboxEvents.EVENT_ASYNC_RESULT, async (results) => {
            this.latestSandboxProgressObj = results ?? this.latestSandboxProgressObj;
            this.updateSandboxRequestData();
            if (!options.isAsync) {
                this.spinner.stop();
            }
            // things that require data on latestSandboxProgressObj
            if (this.latestSandboxProgressObj) {
                const progress = this.sandboxProgress.getSandboxProgress({
                    sandboxProcessObj: this.latestSandboxProgressObj,
                    sandboxRes: undefined,
                });
                const currentStage = progress.status;
                this.sandboxProgress.markPreviousStagesAsCompleted(currentStage);
                this.updateStage(currentStage, 'inProgress');
                this.updateProgress({ sandboxProcessObj: this.latestSandboxProgressObj, sandboxRes: undefined }, options.isAsync);
            }
            if (this.pollingTimeOut) {
                this.warn(messages.getMessage('warning.ClientTimeoutWaitingForSandboxCreate'));
            }
            this.log(this.sandboxProgress.formatProgressStatus(false));
            return Promise.resolve(this.info(messages.getMessage('checkSandboxStatus', this.getCheckSandboxStatusParams())));
        });
        lifecycle.on(core_1.SandboxEvents.EVENT_STATUS, async (results) => {
            this.latestSandboxProgressObj = results.sandboxProcessObj;
            this.updateSandboxRequestData();
            const progress = this.sandboxProgress.getSandboxProgress(results);
            const currentStage = progress.status;
            this.updateStage(currentStage, 'inProgress');
            return Promise.resolve(this.updateProgress(results, options.isAsync));
        });
        lifecycle.on(core_1.SandboxEvents.EVENT_AUTH, async (results) => {
            this.sandboxAuth = results;
            return Promise.resolve();
        });
        lifecycle.on(core_1.SandboxEvents.EVENT_RESULT, async (results) => {
            this.latestSandboxProgressObj = results.sandboxProcessObj;
            this.updateSandboxRequestData();
            this.sandboxProgress.markPreviousStagesAsCompleted();
            this.updateProgress(results, options.isAsync);
            if (!options.isAsync) {
                this.progress.stop();
            }
            if (results.sandboxRes?.authUserName) {
                const authInfo = await core_1.AuthInfo.create({ username: results.sandboxRes?.authUserName });
                await authInfo.handleAliasAndDefaultSettings({
                    alias: options.alias,
                    setDefault: options.setDefault,
                    setDefaultDevHub: false,
                    setTracksSource: await this.calculateTrackingSetting(options.tracksSource),
                });
            }
            this.removeSandboxProgressConfig();
            this.updateProgress(results, options.isAsync);
            this.reportResults(results);
        });
    }
    reportResults(results) {
        this.log();
        this.styledHeader('Sandbox Org Creation Status');
        this.log(this.sandboxProgress.formatProgressStatus(false));
        this.logSuccess([
            messages.getMessage('sandboxSuccess'),
            messages.getMessages('sandboxSuccess.actions', [
                results.sandboxRes?.authUserName,
                this.config.bin,
                results.sandboxRes?.authUserName,
            ]),
        ].join(os.EOL));
    }
    updateProgress(event, isAsync) {
        const sandboxProgress = this.sandboxProgress.getSandboxProgress(event);
        const sandboxData = {
            sandboxUsername: event.sandboxRes?.authUserName,
            sandboxProgress,
            sandboxProcessObj: event.sandboxProcessObj,
        };
        this.sandboxProgress.statusData = sandboxData;
        if (!isAsync) {
            this.spinner.status = this.sandboxProgress.formatProgressStatus();
        }
    }
    updateStage(stage, state) {
        if (stage) {
            this.sandboxProgress.transitionStages(stage, state);
        }
    }
    updateSandboxRequestData() {
        if (this.sandboxRequestData && this.latestSandboxProgressObj) {
            this.sandboxRequestData.sandboxProcessObject = this.latestSandboxProgressObj;
        }
        this.saveSandboxProgressConfig();
    }
    saveSandboxProgressConfig() {
        if (this.sandboxRequestData?.sandboxProcessObject.SandboxName && this.sandboxRequestData) {
            this.sandboxRequestConfig.set(this.sandboxRequestData.sandboxProcessObject.SandboxName, this.sandboxRequestData);
            this.sandboxRequestConfig.writeSync();
        }
    }
    removeSandboxProgressConfig() {
        if (this.latestSandboxProgressObj?.SandboxName) {
            this.sandboxRequestConfig.unset(this.latestSandboxProgressObj.SandboxName);
            this.sandboxRequestConfig.writeSync();
        }
    }
}
exports.SandboxCommandBase = SandboxCommandBase;
//# sourceMappingURL=sandboxCommandBase.js.map