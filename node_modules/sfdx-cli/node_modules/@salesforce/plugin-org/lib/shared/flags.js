"use strict";
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.orgThatMightBeDeleted = void 0;
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/plugin-org', 'delete');
const resolveUsername = async (usernameOrAlias) => {
    const stateAggregator = await core_2.StateAggregator.getInstance();
    // we have a value, but don't know if it's a username or an alias
    if (usernameOrAlias)
        return stateAggregator.aliases.resolveUsername(usernameOrAlias);
    // we didn't get a value, so let's see if the config has a default target org
    const configAggregator = await core_2.ConfigAggregator.create();
    const defaultUsernameOrAlias = configAggregator.getPropertyValue('target-org');
    if (defaultUsernameOrAlias)
        return stateAggregator.aliases.resolveUsername(defaultUsernameOrAlias);
    throw new core_2.SfError(messages.getMessage('missingUsername'), 'MissingUsernameError');
};
/**
 * Almost like the use case for the normal optional org flag,
 * but delete commands need to handle the situation where connecting to the org fails because it's expired.
 *
 * Returns the username so you can construct your own org.
 */
exports.orgThatMightBeDeleted = core_1.Flags.custom({
    char: 'o',
    required: true,
    deprecateAliases: true,
    aliases: ['targetusername', 'u'],
    parse: async (input) => resolveUsername(input),
    default: async () => resolveUsername(),
    defaultHelp: async () => resolveUsername(),
});
//# sourceMappingURL=flags.js.map