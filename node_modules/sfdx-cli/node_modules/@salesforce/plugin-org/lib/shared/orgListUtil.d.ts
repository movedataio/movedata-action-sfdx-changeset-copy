import { AuthInfo, Logger } from '@salesforce/core';
import { Dictionary } from '@salesforce/ts-types';
import { Record } from 'jsforce';
import { ScratchOrgInfoSObject, ExtendedAuthFields, ExtendedAuthFieldsScratch, FullyPopulatedScratchOrgFields } from './orgTypes';
type OrgGroups = {
    nonScratchOrgs: ExtendedAuthFields[];
    scratchOrgs: ExtendedAuthFieldsScratch[];
};
type OrgGroupsFullyPopulated = {
    nonScratchOrgs: ExtendedAuthFields[];
    scratchOrgs: FullyPopulatedScratchOrgFields[];
};
type ExtendedScratchOrgInfo = Record & ScratchOrgInfoSObject & {
    devHubOrgId: string;
};
export declare class OrgListUtil {
    private static logger;
    static retrieveLogger(): Promise<Logger>;
    /**
     * This method takes all locally configured orgs and organizes them into the following buckets:
     * { nonScratchOrgs: [{}], scratchOrgs: [{}] }
     * the scratchOrgInfo query.
     *
     * @param {string[]|null} userFilenames- an array of strings that are validated against the server.
     * @param {object} flags - the result of this.flags on an sfdx command
     */
    static readLocallyValidatedMetaConfigsGroupedByOrgType(userFilenames: string[], flags: Dictionary<string | boolean>): Promise<OrgGroupsFullyPopulated>;
    /**
     * Organizes the scratchOrgs by DevHub to optimize calls to retrieveScratchOrgInfoFromDevHub(), then calls reduceScratchOrgInfo()
     *
     * @param {ExtendedAuthFields[]} scratchOrgs- an array of strings that are validated against the server.
     * @returns the same scratch org list, but with updated information from the server.
     */
    static processScratchOrgs(scratchOrgs: ExtendedAuthFieldsScratch[]): Promise<FullyPopulatedScratchOrgFields[]>;
    /**
     * Used to retrieve authInfo of the auth files
     *
     * @param fileNames All the filenames in the global hidden folder
     */
    static readAuthFiles(fileNames: string[]): Promise<AuthInfo[]>;
    /**
     * Helper to group orgs by {scratchOrg, nonScratchOrgs}
     * Also identifies which are default orgs from config
     *
     * @param {object} contents -The authinfo retrieved from the auth files
     * @param {string[]} excludeProperties - properties to exclude from the grouped configs ex. ['refreshToken', 'clientSecret']
     * @private
     */
    static groupOrgs(authInfos: AuthInfo[]): Promise<OrgGroups>;
    static retrieveScratchOrgInfoFromDevHub(devHubUsername: string, orgIdsToQuery: string[]): Promise<ExtendedScratchOrgInfo[]>;
    static reduceScratchOrgInfo(updatedContents: Array<Partial<Record> & ExtendedScratchOrgInfo>, orgs: ExtendedAuthFieldsScratch[]): Promise<FullyPopulatedScratchOrgFields[]>;
    /**
     * Asks the org if it's a devHub.  Because the dev hub setting can't be deactivated, only ask orgs that aren't already stored as hubs.
     * This has a number of side effects, including updating the AuthInfo files and
     *
     * @param username org to check for devHub status
     * @returns {Promise.<boolean>}
     */
    static checkNonScratchOrgIsDevHub(username: string): Promise<boolean>;
    /**
     * retrieves the connection info of an nonscratch org
     *
     * @param username The username used when the org was authenticated
     * @returns {Promise.<string>}
     */
    static determineConnectedStatusForNonScratchOrg(username: string): Promise<string | undefined>;
}
export declare const identifyActiveOrgByStatus: (org: FullyPopulatedScratchOrgFields) => boolean;
export {};
