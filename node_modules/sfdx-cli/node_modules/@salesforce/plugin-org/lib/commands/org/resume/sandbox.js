"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const sandboxCommandBase_1 = require("../../../shared/sandboxCommandBase");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'resume.sandbox');
class ResumeSandbox extends sandboxCommandBase_1.SandboxCommandBase {
    async run() {
        this.sandboxRequestConfig = await this.getSandboxRequestConfig();
        this.flags = (await this.parse(ResumeSandbox)).flags;
        this.debug('Resume started with args %s ', this.flags);
        return this.resumeSandbox();
    }
    getCheckSandboxStatusParams() {
        return [
            this.config.bin,
            ...(this.latestSandboxProgressObj ? [this.latestSandboxProgressObj.Id] : []),
            ...(this.flags['target-org']?.getUsername() ? [this.flags['target-org'].getUsername()] : []),
        ];
    }
    createResumeSandboxRequest() {
        if (this.flags['use-most-recent'] && this.sandboxRequestConfig) {
            const latestEntry = this.sandboxRequestConfig.getLatestEntry();
            if (latestEntry) {
                const [, sandboxRequestData] = latestEntry;
                if (sandboxRequestData) {
                    return { SandboxName: sandboxRequestData.sandboxProcessObject?.SandboxName };
                }
            }
        }
        // build resume sandbox request from data provided
        return {
            ...Object.assign({}, this.flags.name ? { SandboxName: this.flags.name } : {}),
            ...Object.assign({}, this.flags['job-id'] ? { SandboxProcessObjId: this.flags['job-id'] } : {}),
        };
    }
    async resumeSandbox() {
        this.sandboxRequestData = this.buildSandboxRequestCacheEntry();
        const prodOrgUsername = this.sandboxRequestData.prodOrgUsername;
        if (!this.sandboxRequestData.sandboxProcessObject.SandboxName) {
            if (!this.flags['name'] && !this.flags['job-id']) {
                throw messages.createError('error.NoSandboxNameOrJobId');
            }
        }
        this.prodOrg = await core_1.Org.create({ aliasOrUsername: prodOrgUsername });
        this.flags['target-org'] = this.prodOrg;
        const lifecycle = core_1.Lifecycle.getInstance();
        this.registerLifecycleListeners(lifecycle, {
            isAsync: false,
            alias: this.sandboxRequestData.alias,
            setDefault: this.sandboxRequestData.setDefault,
            prodOrg: this.prodOrg,
            tracksSource: this.sandboxRequestData.tracksSource,
        });
        if (this.latestSandboxProgressObj &&
            (await this.verifyIfAuthExists({
                prodOrg: this.prodOrg,
                sandboxName: this.sandboxRequestData.sandboxProcessObject.SandboxName,
                jobId: this.flags['job-id'],
                lifecycle,
            }))) {
            return this.latestSandboxProgressObj;
        }
        const sandboxReq = this.createResumeSandboxRequest();
        if (this.flags.wait?.seconds && this.flags.wait.seconds > 0) {
            this.spinner.start('Resume Create');
        }
        this.debug('Calling create with ResumeSandboxRequest: %s ', sandboxReq);
        try {
            return await this.prodOrg.resumeSandbox(sandboxReq, {
                wait: this.flags.wait ?? kit_1.Duration.seconds(0),
                interval: kit_1.Duration.seconds(30),
            });
        }
        catch (err) {
            this.spinner.stop();
            if (this.latestSandboxProgressObj && this.pollingTimeOut) {
                void lifecycle.emit(core_1.SandboxEvents.EVENT_ASYNC_RESULT, undefined);
                process.exitCode = 68;
                return this.latestSandboxProgressObj;
            }
            else if (this.latestSandboxProgressObj &&
                err instanceof core_1.SfError &&
                err.name === 'SandboxCreateNotCompleteError') {
                process.exitCode = 68;
                return this.latestSandboxProgressObj;
            }
            throw err;
        }
    }
    buildSandboxRequestCacheEntry() {
        let sandboxRequestCacheEntry;
        if (this.sandboxRequestConfig && this.flags['use-most-recent']) {
            const latest = this.sandboxRequestConfig.getLatestEntry();
            const [name, entry] = latest ?? [undefined, undefined];
            if (!name) {
                throw messages.createError('error.LatestSandboxRequestNotFound');
            }
            sandboxRequestCacheEntry = entry;
        }
        else if (this.sandboxRequestConfig && this.flags.name) {
            sandboxRequestCacheEntry = this.sandboxRequestConfig.get(this.flags.name) || sandboxRequestCacheEntry;
        }
        else if (this.flags['job-id'] && this.sandboxRequestConfig) {
            const entries = this.sandboxRequestConfig.entries();
            const sce = entries.find(([, e]) => e?.sandboxProcessObject?.Id === this.flags['job-id'])?.[1];
            sandboxRequestCacheEntry = sce;
        }
        return {
            ...(sandboxRequestCacheEntry ?? {
                sandboxProcessObject: { SandboxName: this.flags.name },
                sandboxRequest: {},
                setDefault: false,
            }),
            prodOrgUsername: sandboxRequestCacheEntry?.prodOrgUsername ?? this.flags['target-org']?.getUsername(),
        };
    }
    async verifyIfAuthExists({ prodOrg, sandboxName, jobId, lifecycle, }) {
        const sandboxProcessObject = await getSandboxProcessObject(prodOrg, sandboxName, jobId);
        const sandboxUsername = `${prodOrg.getUsername()}.${sandboxProcessObject.SandboxName}`;
        const exists = await (await core_1.StateAggregator.getInstance()).orgs.exists(sandboxUsername);
        if (exists) {
            this.latestSandboxProgressObj = sandboxProcessObject;
            const resultEvent = {
                sandboxProcessObj: this.latestSandboxProgressObj,
                sandboxRes: { authUserName: sandboxUsername },
            };
            await lifecycle.emit(core_1.SandboxEvents.EVENT_RESULT, resultEvent);
            return true;
        }
        return false;
    }
}
exports.default = ResumeSandbox;
ResumeSandbox.summary = messages.getMessage('summary');
ResumeSandbox.description = messages.getMessage('description');
ResumeSandbox.examples = messages.getMessages('examples');
ResumeSandbox.aliases = ['env:resume:sandbox'];
ResumeSandbox.deprecateAliases = true;
ResumeSandbox.flags = {
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
        min: 0,
        unit: 'minutes',
        helpValue: '<minutes>',
        defaultValue: 0,
    }),
    name: sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.name.summary'),
        parse: (name) => {
            if (name.length > 10) {
                throw messages.createError('error.SandboxNameLength', [name]);
            }
            return Promise.resolve(name);
        },
        exclusive: ['job-id'],
    }),
    'job-id': sf_plugins_core_1.Flags.salesforceId({
        startsWith: '0GR',
        char: 'i',
        summary: messages.getMessage('flags.id.summary'),
        description: messages.getMessage('flags.id.description'),
        exclusive: ['name'],
    }),
    'use-most-recent': sf_plugins_core_1.Flags.boolean({
        char: 'l',
        summary: messages.getMessage('flags.use-most-recent.summary'),
    }),
    'target-org': sf_plugins_core_1.Flags.optionalOrg({
        char: 'o',
        summary: messages.getMessage('flags.targetOrg.summary'),
        description: messages.getMessage('flags.targetOrg.description'),
    }),
};
const getSandboxProcessObject = async (prodOrg, sandboxName, jobId) => {
    const where = sandboxName ? `SandboxName='${sandboxName}'` : `Id='${jobId}'`;
    const queryStr = `SELECT Id, Status, SandboxName, SandboxInfoId, LicenseType, CreatedDate, CopyProgress, SandboxOrganization, SourceId, Description, EndDate FROM SandboxProcess WHERE ${where} AND Status != 'D'`;
    try {
        return await prodOrg.getConnection().singleRecordQuery(queryStr, {
            tooling: true,
        });
    }
    catch (err) {
        throw messages.createError('error.NoSandboxRequestFound');
    }
};
//# sourceMappingURL=sandbox.js.map