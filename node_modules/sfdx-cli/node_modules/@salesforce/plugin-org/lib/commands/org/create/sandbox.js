"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxLicenseType = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const sandboxRequest_1 = require("../../../shared/sandboxRequest");
const sandboxCommandBase_1 = require("../../../shared/sandboxCommandBase");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'create.sandbox');
var SandboxLicenseType;
(function (SandboxLicenseType) {
    SandboxLicenseType["developer"] = "Developer";
    SandboxLicenseType["developerPro"] = "Developer_Pro";
    SandboxLicenseType["partial"] = "Partial";
    SandboxLicenseType["full"] = "Full";
})(SandboxLicenseType = exports.SandboxLicenseType || (exports.SandboxLicenseType = {}));
const getLicenseTypes = () => Object.values(SandboxLicenseType);
class CreateSandbox extends sandboxCommandBase_1.SandboxCommandBase {
    async run() {
        this.sandboxRequestConfig = await this.getSandboxRequestConfig();
        this.flags = (await this.parse(CreateSandbox)).flags;
        this.debug('Create started with args %s ', this.flags);
        this.validateFlags();
        return this.createSandbox();
    }
    getCheckSandboxStatusParams() {
        return [
            this.config.bin,
            ...(this.latestSandboxProgressObj ? [this.latestSandboxProgressObj.Id] : []),
            this.flags['target-org'].getUsername(),
        ];
    }
    async createSandboxRequest() {
        // reuse the existing sandbox request generator, with this command's flags as the varargs
        const requestOptions = {
            ...(this.flags.name ? { SandboxName: this.flags.name } : {}),
            ...(this.flags.clone ? { SourceSandboxName: this.flags.clone } : {}),
            ...(!this.flags.clone && this.flags['license-type'] ? { LicenseType: this.flags['license-type'] } : {}),
        };
        const { sandboxReq } = !this.flags.clone
            ? await (0, sandboxRequest_1.createSandboxRequest)(false, this.flags['definition-file'], undefined, requestOptions)
            : await (0, sandboxRequest_1.createSandboxRequest)(true, this.flags['definition-file'], undefined, requestOptions);
        return {
            ...sandboxReq,
            ...(this.flags.clone ? { SourceId: await this.getSourceId() } : {}),
        };
    }
    async createSandbox() {
        const lifecycle = core_1.Lifecycle.getInstance();
        this.registerLifecycleListeners(lifecycle, {
            isAsync: this.flags.async,
            setDefault: this.flags['set-default'],
            alias: this.flags.alias,
            prodOrg: this.flags['target-org'],
            tracksSource: this.flags['no-track-source'] === true ? false : undefined,
        });
        const sandboxReq = await this.createSandboxRequest();
        await this.confirmSandboxReq({ ...sandboxReq, ...(this.flags.clone ? { CloneSource: this.flags.clone } : {}) });
        this.initSandboxProcessData(sandboxReq);
        if (!this.flags.async) {
            this.spinner.start('Sandbox Create');
        }
        this.debug('Calling create with SandboxRequest: %s ', sandboxReq);
        try {
            const sandboxProcessObject = await this.flags['target-org'].createSandbox(sandboxReq, {
                wait: this.flags.wait,
                interval: this.flags['poll-interval'],
                async: this.flags.async,
            });
            this.latestSandboxProgressObj = sandboxProcessObject;
            this.saveSandboxProgressConfig();
            if (this.flags.async) {
                process.exitCode = 68;
            }
            return sandboxProcessObject;
        }
        catch (err) {
            this.spinner.stop();
            if (this.pollingTimeOut && this.latestSandboxProgressObj) {
                void lifecycle.emit(core_1.SandboxEvents.EVENT_ASYNC_RESULT, undefined);
                process.exitCode = 68;
                return this.latestSandboxProgressObj;
            }
            else if (err instanceof core_1.SfError &&
                err.name === 'SandboxCreateNotCompleteError' &&
                this.latestSandboxProgressObj) {
                void lifecycle.emit(core_1.SandboxEvents.EVENT_ASYNC_RESULT, undefined);
                process.exitCode = 68;
                return this.latestSandboxProgressObj;
            }
            throw err;
        }
    }
    initSandboxProcessData(sandboxReq) {
        this.sandboxRequestData = {
            ...this.sandboxRequestData,
            alias: this.flags.alias,
            setDefault: this.flags['set-default'],
            prodOrgUsername: this.flags['target-org'].getUsername(),
            sandboxProcessObject: {
                SandboxName: sandboxReq.SandboxName,
            },
            sandboxRequest: sandboxReq,
            tracksSource: this.flags['no-track-source'] === true ? false : undefined,
        };
        this.saveSandboxProgressConfig();
    }
    async confirmSandboxReq(sandboxReq) {
        if (this.flags['no-prompt'] || this.jsonEnabled())
            return;
        const columns = {
            key: { header: 'Field' },
            value: { header: 'Value' },
        };
        const data = Object.entries(sandboxReq).map(([key, value]) => ({ key, value }));
        this.styledHeader('Config Sandbox Request');
        this.table(data, columns, {});
        const configurationCorrect = await this.timedPrompt([
            {
                name: 'continue',
                type: 'confirm',
                message: messages.getMessage('isConfigurationOk'),
            },
        ], 10000);
        if (!configurationCorrect.continue) {
            throw messages.createError('error.UserNotSatisfiedWithSandboxConfig');
        }
    }
    validateFlags() {
        if (!this.flags['poll-interval'] || !this.flags.wait) {
            return;
        }
        if (this.flags['poll-interval'].seconds > this.flags.wait.seconds) {
            throw messages.createError('error.pollIntervalGreaterThanWait', [
                this.flags['poll-interval'].seconds,
                this.flags.wait.seconds,
            ]);
        }
    }
    async getSourceId() {
        if (!this.flags.clone) {
            return undefined;
        }
        try {
            const sourceOrg = await this.flags['target-org'].querySandboxProcessBySandboxName(this.flags.clone);
            return sourceOrg.SandboxInfoId;
        }
        catch (err) {
            throw messages.createError('error.noCloneSource', [this.flags.clone], [], err);
        }
    }
}
exports.default = CreateSandbox;
CreateSandbox.summary = messages.getMessage('summary');
CreateSandbox.description = messages.getMessage('description');
CreateSandbox.examples = messages.getMessages('examples');
CreateSandbox.aliases = ['env:create:sandbox'];
CreateSandbox.deprecateAliases = true;
CreateSandbox.flags = {
    // needs to change when new flags are available
    'definition-file': sf_plugins_core_1.Flags.file({
        exists: true,
        char: 'f',
        summary: messages.getMessage('flags.definitionFile.summary'),
        description: messages.getMessage('flags.definitionFile.description'),
        exclusive: ['name', 'license-type'],
    }),
    'set-default': sf_plugins_core_1.Flags.boolean({
        char: 's',
        summary: messages.getMessage('flags.setDefault.summary'),
    }),
    alias: sf_plugins_core_1.Flags.string({
        char: 'a',
        summary: messages.getMessage('flags.alias.summary'),
        description: messages.getMessage('flags.alias.description'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
        min: 1,
        unit: 'minutes',
        defaultValue: 30,
        helpValue: '<minutes>',
        exclusive: ['async'],
    }),
    'poll-interval': sf_plugins_core_1.Flags.duration({
        char: 'i',
        summary: messages.getMessage('flags.poll-interval.summary'),
        min: 15,
        unit: 'seconds',
        defaultValue: 30,
        helpValue: '<seconds>',
        exclusive: ['async'],
    }),
    async: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.async.summary'),
        description: messages.getMessage('flags.async.description'),
        exclusive: ['wait', 'poll-interval'],
    }),
    name: sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.name.summary'),
        description: messages.getMessage('flags.name.description'),
        exclusive: ['definition-file'],
        parse: (name) => {
            if (name.length > 10) {
                throw messages.createError('error.SandboxNameLength', [name]);
            }
            return Promise.resolve(name);
        },
    }),
    clone: sf_plugins_core_1.Flags.string({
        char: 'c',
        summary: messages.getMessage('flags.clone.summary'),
        description: messages.getMessage('flags.clone.description'),
        exclusive: ['license-type'],
    }),
    'license-type': sf_plugins_core_1.Flags.custom({
        options: getLicenseTypes(),
    })({
        char: 'l',
        summary: messages.getMessage('flags.licenseType.summary'),
        exclusive: ['definition-file', 'clone'],
        default: SandboxLicenseType.developer,
    }),
    'target-org': sf_plugins_core_1.Flags.requiredOrg({
        char: 'o',
        summary: messages.getMessage('flags.targetOrg.summary'),
        description: messages.getMessage('flags.targetOrg.description'),
        required: true,
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.noPrompt.summary'),
    }),
    'no-track-source': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.no-track-source.summary'),
        description: messages.getMessage('flags.no-track-source.description'),
        allowNo: false,
    }),
};
//# sourceMappingURL=sandbox.js.map