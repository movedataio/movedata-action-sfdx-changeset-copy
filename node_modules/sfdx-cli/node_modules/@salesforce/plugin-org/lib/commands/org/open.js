"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgOpenCommand = void 0;
const path = require("path");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const open = require("open");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const utils_1 = require("../../shared/utils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'open');
const sharedMessages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'messages');
class OrgOpenCommand extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(OrgOpenCommand);
        this.org = flags['target-org'];
        this.conn = this.org.getConnection(flags['api-version']);
        let url = await this.buildFrontdoorUrl();
        if (flags['source-file']) {
            url += `&retURL=${await this.generateFileUrl(flags['source-file'])}`;
        }
        else if (flags.path) {
            url += `&retURL=${flags.path}`;
        }
        const orgId = this.org.getOrgId();
        // TODO: better typings in sfdx-core for orgs read from auth files
        const username = this.org.getUsername();
        const output = { orgId, url, username };
        const containerMode = new kit_1.Env().getBoolean('SFDX_CONTAINER_MODE');
        // security warning only for --json OR --url-only OR containerMode
        if (flags['url-only'] || flags.json || containerMode) {
            this.warn(sharedMessages.getMessage('SecurityWarning'));
            this.log('');
        }
        if (containerMode) {
            // instruct the user that they need to paste the URL into the browser
            this.styledHeader('Action Required!');
            this.log(messages.getMessage('containerAction', [orgId, url]));
            return output;
        }
        if (flags['url-only']) {
            // this includes the URL
            this.logSuccess(messages.getMessage('humanSuccess', [orgId, username, url]));
            return output;
        }
        this.logSuccess(messages.getMessage('humanSuccessNoUrl', [orgId, username]));
        // we actually need to open the org
        try {
            this.spinner.start(messages.getMessage('domainWaiting'));
            const sfdcUrl = new core_1.SfdcUrl(url);
            await sfdcUrl.checkLightningDomain();
            this.spinner.stop();
        }
        catch (err) {
            if (err instanceof Error) {
                if (err.message.includes('timeout')) {
                    const domain = `https://${/https?:\/\/([^.]*)/.exec(url)?.[1]}.lightning.force.com`;
                    const timeout = new kit_1.Duration(new kit_1.Env().getNumber('SFDX_DOMAIN_RETRY', 240), kit_1.Duration.Unit.SECONDS);
                    const logger = await core_1.Logger.child(this.constructor.name);
                    logger.debug(`Did not find IP for ${domain} after ${timeout.seconds} seconds`);
                    throw new core_1.SfError(messages.getMessage('domainTimeoutError'), 'domainTimeoutError');
                }
                throw core_1.SfError.wrap(err);
            }
            throw err;
        }
        const openOptions = flags.browser
            ? // assertion can be removed once oclif option flag typings are fixed
                { app: { name: open.apps[flags.browser] } }
            : {};
        await (0, utils_1.openUrl)(url, openOptions);
        return output;
    }
    async buildFrontdoorUrl() {
        await this.org.refreshAuth(); // we need a live accessToken for the frontdoor url
        const accessToken = this.conn.accessToken;
        const instanceUrl = this.org.getField(core_1.Org.Fields.INSTANCE_URL);
        const instanceUrlClean = instanceUrl.replace(/\/$/, '');
        return `${instanceUrlClean}/secur/frontdoor.jsp?sid=${accessToken}`;
    }
    async generateFileUrl(file) {
        try {
            const metadataResolver = new source_deploy_retrieve_1.MetadataResolver();
            const components = metadataResolver.getComponentsFromPath(file);
            const typeName = components[0]?.type?.name;
            if (typeName === 'FlexiPage') {
                const flexipage = await this.conn.singleRecordQuery(`SELECT id FROM flexipage WHERE DeveloperName='${path.basename(file, '.flexipage-meta.xml')}'`, { tooling: true });
                return `/visualEditor/appBuilder.app?pageId=${flexipage.Id}`;
            }
            else if (typeName === 'ApexPage') {
                return `/apex/${path.basename(file).replace('.page-meta.xml', '').replace('.page', '')}`;
            }
            else {
                return 'lightning/setup/FlexiPageList/home';
            }
        }
        catch (error) {
            return 'lightning/setup/FlexiPageList/home';
        }
    }
}
exports.OrgOpenCommand = OrgOpenCommand;
OrgOpenCommand.summary = messages.getMessage('summary');
OrgOpenCommand.description = messages.getMessage('description');
OrgOpenCommand.examples = messages.getMessages('examples');
OrgOpenCommand.aliases = ['force:org:open', 'force:source:open'];
OrgOpenCommand.deprecateAliases = true;
OrgOpenCommand.flags = {
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    browser: sf_plugins_core_1.Flags.string({
        char: 'b',
        summary: messages.getMessage('flags.browser.summary'),
        options: ['chrome', 'edge', 'firefox'],
        exclusive: ['url-only'],
    }),
    path: sf_plugins_core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.path.summary'),
        env: 'FORCE_OPEN_URL',
        exclusive: ['source-file'],
        parse: (input) => Promise.resolve(encodeURIComponent(decodeURIComponent(input))),
    }),
    'url-only': sf_plugins_core_1.Flags.boolean({
        char: 'r',
        summary: messages.getMessage('flags.url-only.summary'),
        aliases: ['urlonly'],
        deprecateAliases: true,
    }),
    loglevel: sf_plugins_core_1.loglevel,
    'source-file': sf_plugins_core_1.Flags.file({
        char: 'f',
        aliases: ['sourcefile'],
        exclusive: ['path'],
        deprecateAliases: true,
        summary: messages.getMessage('flags.source-file.summary'),
    }),
};
//# sourceMappingURL=open.js.map