"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgListCommand = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const orgListUtil_1 = require("../../shared/orgListUtil");
const orgHighlighter_1 = require("../../shared/orgHighlighter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'list');
class OrgListCommand extends sf_plugins_core_1.SfCommand {
    async run() {
        const [{ flags }, fileNames] = await Promise.all([this.parse(OrgListCommand), getAuthFileNames()]);
        this.flags = flags;
        const metaConfigs = await orgListUtil_1.OrgListUtil.readLocallyValidatedMetaConfigsGroupedByOrgType(fileNames, flags);
        const groupedSortedOrgs = {
            nonScratchOrgs: metaConfigs.nonScratchOrgs.map(decorateWithDefaultStatus).sort(comparator),
            scratchOrgs: metaConfigs.scratchOrgs.map(decorateWithDefaultStatus).sort(comparator),
            expiredScratchOrgs: metaConfigs.scratchOrgs.filter((org) => !(0, orgListUtil_1.identifyActiveOrgByStatus)(org)),
        };
        if (flags.clean && groupedSortedOrgs.expiredScratchOrgs.length > 0) {
            await this.cleanScratchOrgs(groupedSortedOrgs.expiredScratchOrgs, !flags['no-prompt']);
        }
        if (groupedSortedOrgs.expiredScratchOrgs.length > 10 && !flags.clean) {
            this.warn(messages.getMessage('deleteOrgs', [groupedSortedOrgs.expiredScratchOrgs.length]));
        }
        const result = {
            nonScratchOrgs: groupedSortedOrgs.nonScratchOrgs,
            scratchOrgs: flags.all
                ? groupedSortedOrgs.scratchOrgs
                : groupedSortedOrgs.scratchOrgs.filter(orgListUtil_1.identifyActiveOrgByStatus),
        };
        this.printOrgTable(result.nonScratchOrgs, flags['skip-connection-status']);
        this.printScratchOrgTable(result.scratchOrgs);
        return result;
    }
    async cleanScratchOrgs(scratchOrgs, prompt) {
        if (prompt && (await this.confirm(messages.getMessage('prompt', [scratchOrgs.length]))) === false) {
            return;
        }
        await Promise.all(scratchOrgs.map(async (fields) => {
            try {
                const authInfo = await core_1.AuthInfo.create({ username: fields.username });
                const connection = await core_1.Connection.create({
                    authInfo,
                    configAggregator: {
                        // Force an api version to prevent connection check with the server for expired orgs.
                        getInfo: () => ({ value: '47.0' }),
                    },
                });
                const org = await core_1.Org.create({ aliasOrUsername: fields.username, connection });
                await org.remove();
            }
            catch (e) {
                const err = e;
                const logger = await core_1.Logger.child('org:list');
                logger.debug(`Error cleaning org ${fields.username}: ${err.message}`);
                this.warn(messages.getMessage('cleanWarning', [fields.username, fields.username]));
            }
        }));
    }
    printOrgTable(nonScratchOrgs, skipconnectionstatus) {
        if (!nonScratchOrgs.length) {
            this.log(messages.getMessage('noResultsFound'));
        }
        else {
            const rows = nonScratchOrgs
                .map((row) => (0, orgHighlighter_1.getStyledObject)(row))
                .map((org) => Object.fromEntries(Object.entries(org).filter(([key]) => ['defaultMarker', 'alias', 'username', 'orgId', 'connectedStatus'].includes(key))));
            this.table(rows, {
                defaultMarker: {
                    header: '',
                    get: (data) => data.defaultMarker ?? '',
                },
                alias: {
                    header: 'ALIAS',
                    get: (data) => data.alias ?? '',
                },
                username: { header: 'USERNAME' },
                orgId: { header: 'ORG ID' },
                ...(!skipconnectionstatus ? { connectedStatus: { header: 'CONNECTED STATUS' } } : {}),
            }, {
                title: 'Non-scratch orgs',
            });
        }
    }
    printScratchOrgTable(scratchOrgs) {
        if (scratchOrgs.length === 0) {
            this.log(messages.getMessage('noActiveScratchOrgs'));
        }
        else {
            // One or more rows are available.
            // we only need a few of the props for our table.  Oclif table doesn't like extra props non-string props.
            const rows = scratchOrgs
                .map(orgHighlighter_1.getStyledObject)
                .map((org) => Object.fromEntries(Object.entries(org).filter(([key]) => [
                'defaultMarker',
                'alias',
                'username',
                'orgId',
                'status',
                'expirationDate',
                'devHubOrgId',
                'createdDate',
                'instanceUrl',
            ].includes(key))));
            this.table(rows, {
                defaultMarker: {
                    header: '',
                    get: (data) => data.defaultMarker ?? '',
                },
                alias: {
                    header: 'ALIAS',
                    get: (data) => data.alias ?? '',
                },
                username: { header: 'USERNAME' },
                orgId: { header: 'ORG ID' },
                ...(this.flags.all || this.flags.verbose ? { status: { header: 'STATUS' } } : {}),
                ...(this.flags.verbose
                    ? {
                        devHubOrgId: { header: 'DEV HUB' },
                        createdDate: { header: 'CREATED DATE' },
                        instanceUrl: { header: 'INSTANCE URL' },
                    }
                    : {}),
                expirationDate: { header: 'EXPIRATION DATE' },
            }, {
                title: 'Scratch orgs',
            });
        }
    }
}
exports.OrgListCommand = OrgListCommand;
OrgListCommand.summary = messages.getMessage('summary');
OrgListCommand.examples = messages.getMessages('examples');
OrgListCommand.aliases = ['force:org:list'];
OrgListCommand.deprecateAliases = true;
OrgListCommand.flags = {
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
    all: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.all.summary'),
    }),
    clean: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.clean.summary'),
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        char: 'p',
        summary: messages.getMessage('flags.noPrompt.summary'),
        dependsOn: ['clean'],
        aliases: ['noprompt'],
        deprecateAliases: true,
    }),
    'skip-connection-status': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.skipConnectionStatus.summary'),
        aliases: ['skipconnectionstatus'],
        deprecateAliases: true,
    }),
    loglevel: sf_plugins_core_1.loglevel,
};
const decorateWithDefaultStatus = (val) => ({
    ...val,
    ...(val.isDefaultDevHubUsername ? { defaultMarker: '(D)' } : {}),
    ...(val.isDefaultUsername ? { defaultMarker: '(U)' } : {}),
});
// sort by alias then username
const comparator = (a, b) => {
    const aliasCompareResult = (a.alias ?? '').localeCompare(b.alias ?? '');
    return aliasCompareResult !== 0 ? aliasCompareResult : (a.username ?? '').localeCompare(b.username);
};
const getAuthFileNames = async () => {
    try {
        return ((await core_1.AuthInfo.listAllAuthorizations()) ?? []).map((auth) => auth.username);
    }
    catch (err) {
        const error = err;
        if (error.name === 'NoAuthInfoFound') {
            throw new core_1.SfError(messages.getMessage('noOrgsFound'), 'noOrgsFound', [messages.getMessage('noOrgsFoundAction')]);
        }
        else {
            throw error;
        }
    }
};
//# sourceMappingURL=list.js.map