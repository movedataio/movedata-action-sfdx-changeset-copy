"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgStatusCommand = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const sandboxReporter_1 = require("../../../shared/sandboxReporter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'status');
class OrgStatusCommand extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(OrgStatusCommand);
        flags['target-org'].getConnection(flags['api-version']);
        const logger = await core_1.Logger.child(this.constructor.name);
        logger.debug('Status started with args %s ', flags);
        const lifecycle = core_1.Lifecycle.getInstance();
        lifecycle.on(core_1.SandboxEvents.EVENT_STATUS, async (results) => Promise.resolve(this.log(sandboxReporter_1.SandboxReporter.sandboxProgress(results))));
        lifecycle.on(core_1.SandboxEvents.EVENT_RESULT, async (results) => {
            const resultMsg = `Sandbox ${results.sandboxProcessObj.SandboxName}(${results.sandboxProcessObj.Id}) is ready for use.`;
            this.log(resultMsg);
            const { data } = sandboxReporter_1.SandboxReporter.logSandboxProcessResult(results);
            this.styledHeader('Sandbox Org Status');
            this.table(data, {
                key: { header: 'Name' },
                value: { header: 'Value' },
            });
            if (results.sandboxRes?.authUserName) {
                if (flags.setalias) {
                    const stateAggregator = await core_1.StateAggregator.getInstance();
                    stateAggregator.aliases.set(flags.setalias, results.sandboxRes.authUserName);
                    await stateAggregator.aliases.write();
                    logger.debug('Set Alias: %s result: %s', flags.setalias, results.sandboxRes.authUserName);
                }
                if (flags.setdefaultusername) {
                    const globalConfig = this.configAggregator.getGlobalConfig();
                    globalConfig.set(core_1.OrgConfigProperties.TARGET_ORG, results.sandboxRes.authUserName);
                    const result = await globalConfig.write();
                    logger.debug('Set defaultUsername: %s result: %s', flags.setdefaultusername, result);
                }
            }
        });
        logger.debug('Calling auth for SandboxName args: %s ', flags.sandboxname);
        const results = await flags['target-org'].sandboxStatus(flags.sandboxname, {
            wait: flags.wait,
        });
        logger.debug('Results for auth call: %s ', results);
        if (!results) {
            this.styledHeader('Sandbox Org Creation Status');
            this.log('No SandboxProcess Result Found');
        }
        return results;
    }
}
exports.OrgStatusCommand = OrgStatusCommand;
OrgStatusCommand.summary = messages.getMessage('summary');
OrgStatusCommand.description = messages.getMessage('description');
OrgStatusCommand.examples = messages.getMessages('examples');
OrgStatusCommand.state = 'deprecated';
OrgStatusCommand.deprecationOptions = {
    to: 'org:resume:sandbox',
    version: '60.0',
};
OrgStatusCommand.flags = {
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    sandboxname: sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.sandboxname'),
        required: true,
    }),
    setdefaultusername: sf_plugins_core_1.Flags.boolean({
        char: 's',
        summary: messages.getMessage('flags.setdefaultusername'),
    }),
    setalias: sf_plugins_core_1.Flags.string({
        char: 'a',
        summary: messages.getMessage('flags.setalias'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        summary: messages.getMessage('flags.wait'),
        min: 2,
        defaultValue: 6,
    }),
    loglevel: sf_plugins_core_1.loglevel,
};
//# sourceMappingURL=status.js.map