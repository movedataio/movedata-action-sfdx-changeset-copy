"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateUserCommand = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-user', 'create');
const permsetsStringToArray = (fieldsPermsets) => {
    if (!fieldsPermsets)
        return [];
    return (0, ts_types_1.isArray)(fieldsPermsets)
        ? fieldsPermsets
        : fieldsPermsets.split(',').map((item) => item.replace("'", '').trim());
};
class CreateUserCommand extends sf_plugins_core_1.SfCommand {
    constructor() {
        super(...arguments);
        this.successes = [];
        this.failures = [];
    }
    /**
     * removes fields that cause errors in salesforce APIs within sfdx-core's createUser method
     *
     * @param fields a list of combined fields from varargs and the config file
     * @private
     */
    static stripInvalidAPIFields(fields) {
        return (0, kit_1.omit)(fields, ['permsets', 'generatepassword', 'generatePassword', 'profileName']);
    }
    async run() {
        const { flags, argv } = await this.parse(CreateUserCommand);
        this.varargs = (0, sf_plugins_core_1.parseVarArgs)({}, argv);
        this.flags = flags;
        this.logger = await core_1.Logger.child(this.constructor.name);
        const defaultUserFields = await core_1.DefaultUserFields.create({
            templateUser: this.flags['target-org'].getUsername() ?? '',
        });
        this.targetOrgUser = await core_1.User.create({ org: this.flags['target-org'] });
        // merge defaults with provided values with cli > file > defaults
        const fields = await this.aggregateFields(defaultUserFields.getFields());
        try {
            this.newUserAuthInfo = await this.targetOrgUser.createUser(CreateUserCommand.stripInvalidAPIFields(fields));
        }
        catch (e) {
            if (!(e instanceof Error)) {
                throw e;
            }
            await this.catchCreateUser(e, fields);
        }
        if (fields.profileName)
            await this.newUserAuthInfo.save({ userProfileName: fields.profileName });
        // Assign permission sets to the created user
        if (fields.permsets) {
            try {
                // permsets can be passed from cli args or file we need to create an array of permset names either way it's passed
                // it will either be a comma separated string, or an array, force it into an array
                const permsetArray = permsetsStringToArray(fields.permsets);
                await this.targetOrgUser.assignPermissionSets((0, ts_types_1.ensureString)(this.newUserAuthInfo.getFields().userId), permsetArray);
                this.successes.push({
                    name: 'Permission Set Assignment',
                    value: permsetArray.join(','),
                });
            }
            catch (error) {
                const err = error;
                this.failures.push({
                    name: 'Permission Set Assignment',
                    message: err.message,
                });
            }
        }
        // Generate and set a password if specified
        if (fields.generatePassword) {
            try {
                const password = core_1.User.generatePasswordUtf8();
                await this.targetOrgUser.assignPassword(this.newUserAuthInfo, password);
                password.value((pass) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.newUserAuthInfo.save({ password: pass.toString('utf-8') });
                    this.successes.push({
                        name: 'Password Assignment',
                        value: pass.toString(),
                    });
                });
            }
            catch (error) {
                const err = error;
                this.failures.push({
                    name: 'Password Assignment',
                    message: err.message,
                });
            }
        }
        // Set the alias if specified
        if (this.flags['set-alias']) {
            const stateAggregator = await core_1.StateAggregator.getInstance();
            stateAggregator.aliases.set(this.flags['set-alias'], fields.username);
            await stateAggregator.aliases.write();
        }
        fields.id = (0, ts_types_1.ensureString)(this.newUserAuthInfo.getFields().userId);
        this.print(fields);
        this.setExitCode();
        const { permsets, ...fieldsWithoutPermsets } = fields;
        return {
            orgId: this.flags['target-org'].getOrgId(),
            permissionSetAssignments: permsetsStringToArray(permsets),
            fields: { ...(0, kit_1.mapKeys)(fieldsWithoutPermsets, (value, key) => key.toLowerCase()) },
        };
    }
    async catchCreateUser(respBody, fields) {
        // For Gacks, the error message is on response.body[0].message but for handled errors
        // the error message is on response.body.Errors[0].description.
        const errMessage = (0, ts_types_1.getString)(respBody, 'message') ?? 'Unknown Error';
        const conn = this.flags['target-org'].getConnection(this.flags['api-version']);
        // Provide a more user friendly error message for certain server errors.
        if (errMessage.includes('LICENSE_LIMIT_EXCEEDED')) {
            const profile = await conn.singleRecordQuery(`SELECT name FROM profile WHERE id='${fields.profileId}'`);
            throw new core_1.SfError(messages.getMessage('licenseLimitExceeded', [profile.Name]), 'licenseLimitExceeded');
        }
        else if (errMessage.includes('DUPLICATE_USERNAME')) {
            throw new core_1.SfError(messages.getMessage('duplicateUsername', [fields.username]), 'duplicateUsername');
        }
        else {
            throw core_1.SfError.wrap(errMessage);
        }
    }
    async aggregateFields(defaultFields) {
        // username can be overridden both in the file or varargs, save it to check if it was changed somewhere
        const defaultUsername = defaultFields.username;
        // start with the default fields, then add the fields from the file, then (possibly overwriting) add the fields from the cli varargs param
        if (this.flags['definition-file']) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call
            const content = (0, kit_1.parseJson)(await fs.promises.readFile(this.flags['definition-file'], 'utf-8'));
            Object.keys(content).forEach((key) => {
                // cast entries to lowercase to standardize
                defaultFields[lowerFirstLetter(key)] = content[key];
            });
        }
        if (this.varargs) {
            Object.keys(this.varargs).forEach((key) => {
                if (key.toLowerCase() === 'generatepassword') {
                    // standardize generatePassword casing
                    defaultFields['generatePassword'] = (0, kit_1.toBoolean)(this.varargs[key]);
                }
                else if (key.toLowerCase() === 'profilename') {
                    // standardize profileName casing
                    defaultFields['profileName'] = this.varargs[key];
                }
                else {
                    // all other varargs are left "as is"
                    defaultFields[lowerFirstLetter(key)] = this.varargs[key];
                }
            });
        }
        // check if "username" was passed along with "set-unique-username" flag, if so append org id
        if (this.flags['set-unique-username'] && defaultFields.username !== defaultUsername) {
            defaultFields.username = `${defaultFields.username}.${this.flags['target-org'].getOrgId().toLowerCase()}`;
        }
        // check if "profileName" was passed, this needs to become a profileId before calling User.create
        if (defaultFields['profileName']) {
            const name = (defaultFields['profileName'] ?? 'Standard User');
            this.logger.debug(`Querying org for profile name [${name}]`);
            const profile = await this.flags['target-org']
                .getConnection(this.flags['api-version'])
                .singleRecordQuery(`SELECT id FROM profile WHERE name='${name}'`);
            defaultFields.profileId = profile.Id;
        }
        return defaultFields;
    }
    print(fields) {
        const userCreatedSuccessMsg = messages.getMessage('success', [
            fields.username,
            fields.id,
            this.flags['target-org'].getOrgId(),
            os.EOL,
            this.config.bin,
            fields.username,
        ]);
        // we initialize to be an empty array to be able to push onto it
        // so we need to check that the size is greater than 0 to know we had a failure
        if (this.failures.length > 0) {
            this.styledHeader('Partial Success');
            this.log(userCreatedSuccessMsg);
            this.log('');
            this.styledHeader('Failures');
            this.table(this.failures, { name: { header: 'Action' }, message: { header: 'Error Message' } });
        }
        else {
            this.log(userCreatedSuccessMsg);
        }
    }
    setExitCode() {
        if (this.failures.length && this.successes.length) {
            process.exitCode = 68;
        }
        else if (this.failures.length) {
            process.exitCode = 1;
        }
        else if (this.successes.length) {
            process.exitCode = 0;
        }
    }
}
exports.CreateUserCommand = CreateUserCommand;
CreateUserCommand.strict = false;
CreateUserCommand.deprecateAliases = true;
CreateUserCommand.aliases = ['force:user:create'];
CreateUserCommand.summary = messages.getMessage('summary');
CreateUserCommand.description = messages.getMessage('description');
CreateUserCommand.examples = messages.getMessages('examples');
CreateUserCommand.flags = {
    'set-alias': sf_plugins_core_1.Flags.string({
        char: 'a',
        summary: messages.getMessage('flags.alias.summary'),
        aliases: ['setalias'],
        deprecateAliases: true,
    }),
    'definition-file': sf_plugins_core_1.Flags.string({
        char: 'f',
        summary: messages.getMessage('flags.definitionfile.summary'),
        description: messages.getMessage('flags.definitionfile.description'),
        aliases: ['definitionfile'],
        deprecateAliases: true,
    }),
    'set-unique-username': sf_plugins_core_1.Flags.boolean({
        char: 's',
        summary: messages.getMessage('flags.setuniqueusername.summary'),
        description: messages.getMessage('flags.setuniqueusername.description'),
        aliases: ['setuniqueusername'],
        deprecateAliases: true,
    }),
    'target-dev-hub': {
        ...sf_plugins_core_1.optionalHubFlagWithDeprecations,
        hidden: true,
        deprecated: {
            message: messages.getMessage('flags.target-hub.deprecation'),
        },
    },
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
};
exports.default = CreateUserCommand;
const lowerFirstLetter = (word) => word[0].toLowerCase() + word.substr(1);
//# sourceMappingURL=user.js.map