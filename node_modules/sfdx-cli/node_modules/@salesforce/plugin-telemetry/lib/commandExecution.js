"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandExecution = void 0;
const path_1 = require("path");
const fs = require("fs");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const debugger_1 = require("./debugger");
class CommandExecution extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.specifiedFlags = [];
        this.specifiedFlagFullNames = [];
        this.command = options.command;
        this.argv = options.argv;
        this.config = options.config;
    }
    /**
     * Determines whether the SFDX project is using GIT for version control or some other VCS.
     * Returns a token indicating the VCS for usage stats, or an empty string if the command
     * was executed outside of an SFDX project.
     */
    static async resolveVCSInfo() {
        let possibleVcsPath;
        try {
            possibleVcsPath = await core_2.SfProject.resolveProjectPath();
        }
        catch (err) {
            (0, debugger_1.debug)('Not in a sfdx project, using current working directory');
            possibleVcsPath = process.cwd();
        }
        const gitPath = (0, path_1.join)(possibleVcsPath, '.git');
        try {
            await fs.promises.access(gitPath, fs.constants.R_OK);
            return 'git';
        }
        catch (err) {
            return 'other';
        }
    }
    toJson() {
        const pluginInfo = this.getPluginInfo();
        let oclifPerf = {};
        try {
            oclifPerf = {
                'oclif.runMs': core_1.Performance.highlights.runTime,
                // The amount of time (ms) required for oclif to get to the point where it can start running the command.
                'oclif.initMs': core_1.Performance.highlights.initTime,
                // The amount of time (ms) required for oclif to load the Config.
                'oclif.configLoadMs': core_1.Performance.highlights.configLoadTime,
                // The amount of time (ms) required for oclif to load the command.
                'oclif.commandLoadMs': core_1.Performance.highlights.commandLoadTime,
                // The amount of time (ms) required for oclif to load core (i.e. bundled) plugins.
                'oclif.corePluginsLoadMs': core_1.Performance.highlights.corePluginsLoadTime,
                // The amount of time (ms) required for oclif to load user plugins.
                'oclif.userPluginsLoadMs': core_1.Performance.highlights.userPluginsLoadTime,
                // The amount of time (ms) required for oclif to load linked plugins.
                'oclif.linkedPluginsLoadMs': core_1.Performance.highlights.linkedPluginsLoadTime,
                // The amount of time (ms) required for oclif to run all the init hooks
                'oclif.initHookMs': core_1.Performance.highlights.hookRunTimes.init?.total,
                // The amount of time (ms) required for oclif to run all the prerun hooks
                'oclif.prerunHookMs': core_1.Performance.highlights.hookRunTimes.prerun?.total,
                // The amount of time (ms) required for oclif to run all the postrun hooks
                'oclif.postrunHookMs': core_1.Performance.highlights.hookRunTimes.postrun?.total,
            };
        }
        catch (err) {
            (0, debugger_1.debug)('Unable to get oclif performance metrics', err);
        }
        return {
            eventName: 'COMMAND_EXECUTION',
            // System information
            platform: this.config.platform,
            shell: this.config.shell,
            arch: this.config.arch,
            vcs: this.vcs,
            nodeEnv: process.env.NODE_ENV,
            nodeVersion: process.version,
            processUptime: process.uptime() * 1000,
            // CLI information
            version: this.config.version,
            channel: this.config.channel,
            executable: this.config.bin,
            origin: this.config.userAgent,
            plugin: pluginInfo.name,
            // eslint-disable-next-line camelcase
            plugin_version: pluginInfo.version,
            command: this.command.id,
            // As the user specified, including short names
            specifiedFlags: this.specifiedFlags.join(' '),
            // Flags the user specified, only the full names
            specifiedFlagFullNames: this.specifiedFlagFullNames.join(' '),
            sfdxEnv: process.env.SFDX_ENV,
            s3HostOverride: process.env.SFDX_S3_HOST,
            npmRegistryOverride: process.env.SFDX_NPM_REGISTRY,
            tool: process.env.SFDX_TOOL,
            interceptorMode: process.env.INTERCEPTOR_MODE,
            // Execution information
            date: new Date().toUTCString(),
            // Don't log status or timestamp as a number, otherwise vscode will think it is a metric
            status: (0, ts_types_1.isNumber)(this.status) ? this.status.toString() : undefined,
            timestamp: String(Date.now()),
            // Oclif Performance Metrics
            ...oclifPerf,
            // Salesforce Information
            // Set the usernames so the uploader can resolve it to orgIds.
            // Since resolving org ids can make API calls, we want to do that in the
            // uploader process so we don't slow down the CLI.
            devHubUsername: this.devHubOrgUsername,
            orgUsername: this.orgUsername,
        };
    }
    getPluginInfo() {
        return {
            name: this.command.plugin?.name,
            version: this.command.plugin?.version,
        };
    }
    getCommandName() {
        return this.command.id;
    }
    async init() {
        const argv = this.argv;
        const flagDefinitions = this.command.flags ?? {};
        let flags = {};
        try {
            flags = (await core_1.Parser.parse(argv, {
                flags: flagDefinitions,
                args: this.command.args,
                // @ts-expect-error because varargs is not on SfCommand but is on SfdxCommand
                strict: this.command.strict ?? !this.command.varargs,
            })).flags;
        }
        catch (error) {
            (0, debugger_1.debug)('Error parsing flags');
        }
        this.orgUsername = flags['targetusername'];
        this.devHubOrgUsername = flags['targetdevhubusername'];
        this.determineSpecifiedFlags(argv, flags, flagDefinitions);
        this.vcs = await CommandExecution.resolveVCSInfo();
    }
    determineSpecifiedFlags(argv, flags, flagDefinitions) {
        // Help won't be in the parsed flags
        const shortHelp = argv.find((arg) => /^-h$/.test(arg));
        const fullHelp = argv.find((arg) => /^--help$/.test(arg));
        if (shortHelp || fullHelp) {
            if (shortHelp) {
                this.specifiedFlags.push('h');
            }
            else {
                this.specifiedFlags.push('help');
            }
            this.specifiedFlagFullNames.push('help');
            // All other flags don't matter if help is specified, so end here.
        }
        else {
            Object.keys(flags).forEach((flagName) => {
                const shortCode = flagDefinitions[flagName] && flagDefinitions[flagName].char;
                // Oclif will include the flag if there is a default, but we only want to add it if the
                // user specified it, so confirm in the argv list.
                if (shortCode && argv.find((arg) => new RegExp(`^-${shortCode}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(shortCode);
                    this.specifiedFlagFullNames.push(flagName);
                }
                else if (argv.find((arg) => new RegExp(`^--${flagName}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(flagName);
                    this.specifiedFlagFullNames.push(flagName);
                }
            });
        }
    }
}
exports.CommandExecution = CommandExecution;
//# sourceMappingURL=commandExecution.js.map