"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrieveColumns = exports.DataSoqlQueryCommand = void 0;
const fs = require("fs");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const flags_1 = require("../../flags");
const dataSoqlQueryTypes_1 = require("../../dataSoqlQueryTypes");
const queryUtils_1 = require("../../queryUtils");
const bulkDataRequestCache_1 = require("../../bulkDataRequestCache");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'soql.query');
class DataSoqlQueryCommand extends sf_plugins_core_1.SfCommand {
    // will init from run
    /**
     * Command run implementation
     *
     * Returns either a DataSoqlQueryResult or a SfdxResult.
     * When the user is using global '--json' flag an instance of SfdxResult is returned.
     * This is necessary since '--json' flag reports results in the form of SfdxResult
     * and bypasses the definition of start result. The goal is to have the output
     * from '--json' and '--resulformat json' be the same.
     *
     * The DataSoqlQueryResult is necessary to communicate user selections to the reporters.
     * The 'this' object available during display() function does not include user input to
     * the command, which are necessary for reporter selection.
     *
     */
    async run() {
        this.logger = await core_1.Logger.child('data:soql:query');
        const flags = (await this.parse(DataSoqlQueryCommand)).flags;
        try {
            // soqlqueryfile will be present if flags.query isn't. Oclif exactlyOne isn't quite that clever
            const queryString = flags.query ?? fs.readFileSync(flags.file, 'utf8');
            const conn = flags['target-org'].getConnection(flags['api-version']);
            if (flags['result-format'] !== 'json')
                this.spinner.start(messages.getMessage('queryRunningMessage'));
            const queryResult = flags.bulk
                ? await this.runBulkSoqlQuery(conn, queryString, flags.async ? kit_1.Duration.minutes(0) : flags.wait ?? kit_1.Duration.minutes(0))
                : await this.runSoqlQuery(flags['use-tooling-api'] ? conn.tooling : conn, queryString, this.logger, this.configAggregator.getInfo('org-max-query-limit').value);
            if (!this.jsonEnabled()) {
                (0, queryUtils_1.displayResults)({ ...queryResult }, flags['result-format']);
            }
            return queryResult.result;
        }
        finally {
            if (flags['result-format'] !== 'json')
                this.spinner.stop();
        }
    }
    /**
     * Executes a SOQL query using the bulk 2.0 API
     *
     * @param connection
     * @param query
     * @param timeout
     */
    async runBulkSoqlQuery(connection, query, timeout) {
        connection.bulk2.pollTimeout = timeout.milliseconds ?? kit_1.Duration.minutes(5).milliseconds;
        let res;
        try {
            res = (await connection.bulk2.query(query)) ?? [];
            return (0, queryUtils_1.transformBulkResults)(res, query);
        }
        catch (e) {
            const err = e;
            if (timeout.minutes === 0 && err.message.includes('Polling time out')) {
                // async query, so we can't throw an error, suggest data:query:resume --queryid <id>
                const cache = await bulkDataRequestCache_1.BulkQueryRequestCache.create();
                await cache.createCacheEntryForRequest(err.jobId, connection.getUsername(), connection.getApiVersion());
                this.log(messages.getMessage('bulkQueryTimeout', [err.jobId, err.jobId, connection.getUsername()]));
                return { columns: [], result: { done: false, records: [], totalSize: 0, id: err.jobId }, query };
            }
            else {
                throw core_1.SfError.wrap(err);
            }
        }
    }
    async runSoqlQuery(connection, query, logger, maxFetch) {
        logger.debug('running query');
        const options = {
            autoFetch: true,
            maxFetch: maxFetch ?? 50000,
        };
        const result = await connection.query(query, options);
        if (result.records.length && result.totalSize > result.records.length) {
            this.warn(`The query result is missing ${result.totalSize - result.records.length} records due to a ${maxFetch} record limit. Increase the number of records returned by setting the config value "org-max-query-limit" or the environment variable "SF_ORG_MAX_QUERY_LIMIT" to ${result.totalSize} or greater than ${maxFetch}.`);
        }
        logger.debug(`Query complete with ${result.totalSize} records returned`);
        const columns = result.totalSize ? await (0, exports.retrieveColumns)(connection, query, logger) : [];
        return {
            query,
            columns,
            result,
        };
    }
}
exports.DataSoqlQueryCommand = DataSoqlQueryCommand;
DataSoqlQueryCommand.summary = messages.getMessage('summary');
DataSoqlQueryCommand.description = messages.getMessage('description');
DataSoqlQueryCommand.examples = messages.getMessages('examples');
DataSoqlQueryCommand.aliases = ['force:data:soql:query'];
DataSoqlQueryCommand.deprecateAliases = true;
DataSoqlQueryCommand.flags = {
    ...flags_1.orgFlags,
    query: sf_plugins_core_1.Flags.string({
        char: 'q',
        summary: messages.getMessage('flags.queryToExecute'),
        exactlyOne: ['query', 'file'],
    }),
    file: sf_plugins_core_1.Flags.file({
        char: 'f',
        exists: true,
        summary: messages.getMessage('flags.file'),
        exactlyOne: ['query', 'file'],
        aliases: ['soqlqueryfile'],
        deprecateAliases: true,
    }),
    'use-tooling-api': sf_plugins_core_1.Flags.boolean({
        char: 't',
        summary: messages.getMessage('flags.useToolingApi'),
        aliases: ['usetoolingapi'],
        deprecateAliases: true,
    }),
    bulk: sf_plugins_core_1.Flags.boolean({
        char: 'b',
        default: false,
        summary: messages.getMessage('flags.bulk'),
        exclusive: ['use-tooling-api'],
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        summary: messages.getMessage('flags.wait'),
        dependsOn: ['bulk'],
        exclusive: ['async'],
    }),
    async: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.async'),
        dependsOn: ['bulk'],
        exclusive: ['wait'],
    }),
    'result-format': flags_1.resultFormatFlag,
    perflog: flags_1.perflogFlag,
};
const searchSubColumnsRecursively = (parent) => {
    const column = (0, ts_types_1.ensureJsonMap)(parent);
    const name = (0, ts_types_1.ensureString)(column.columnName);
    const child = (0, ts_types_1.getArray)(parent, 'joinColumns');
    return child.length ? child.map((c) => `${name}.${searchSubColumnsRecursively(c).join('.')}`) : [name];
};
/**
 * Utility to fetch the columns involved in a soql query.
 *
 * Columns are then transformed into one of three types, Field, SubqueryField and FunctionField. List of
 * fields is returned as the product.
 *
 * @param connection
 * @param query
 * @param logger
 */
const retrieveColumns = async (connection, query, logger) => {
    logger?.debug('fetching columns for query');
    // eslint-disable-next-line no-underscore-dangle
    const columnUrl = `${connection._baseUrl()}/query?q=${encodeURIComponent(query)}&columns=true`;
    const results = (0, ts_types_1.toJsonMap)(await connection.request(columnUrl));
    return recursivelyFindColumns((0, ts_types_1.ensureJsonArray)(results.columnMetadata));
};
exports.retrieveColumns = retrieveColumns;
const recursivelyFindColumns = (data) => {
    const columns = [];
    for (let column of data) {
        column = (0, ts_types_1.ensureJsonMap)(column);
        const name = (0, ts_types_1.ensureString)(column.columnName);
        if ((0, ts_types_1.isJsonArray)(column.joinColumns) && column.joinColumns.length > 0) {
            if (column.aggregate) {
                const field = {
                    fieldType: dataSoqlQueryTypes_1.FieldType.subqueryField,
                    name,
                    fields: [],
                };
                for (let subcolumn of column.joinColumns) {
                    subcolumn = (0, ts_types_1.ensureJsonMap)(subcolumn);
                    if ((0, ts_types_1.isJsonArray)(column.joinColumns) && column.joinColumns.length > 0) {
                        if (field.fields)
                            field.fields.push(...recursivelyFindColumns([subcolumn]));
                    }
                    else {
                        const f = {
                            fieldType: dataSoqlQueryTypes_1.FieldType.field,
                            name: (0, ts_types_1.ensureString)((0, ts_types_1.ensureJsonMap)(subcolumn).columnName),
                        };
                        if (field.fields)
                            field.fields.push(f);
                    }
                }
                columns.push(field);
            }
            else {
                for (const subcolumn of column.joinColumns) {
                    const allSubFieldNames = searchSubColumnsRecursively(subcolumn);
                    for (const subFields of allSubFieldNames) {
                        columns.push({
                            fieldType: dataSoqlQueryTypes_1.FieldType.field,
                            name: `${name}.${subFields}`,
                        });
                    }
                }
            }
        }
        else if (column.aggregate) {
            const field = {
                fieldType: dataSoqlQueryTypes_1.FieldType.functionField,
                name: (0, ts_types_1.ensureString)(column.displayName),
            };
            // If it isn't an alias, skip so the display name is used when messaging rows
            if (!/expr[0-9]+/.test(name)) {
                field.alias = name;
            }
            columns.push(field);
        }
        else {
            columns.push({ fieldType: dataSoqlQueryTypes_1.FieldType.field, name });
        }
    }
    return columns;
};
//# sourceMappingURL=query.js.map