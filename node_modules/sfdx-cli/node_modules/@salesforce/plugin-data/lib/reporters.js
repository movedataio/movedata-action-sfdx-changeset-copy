"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResultMessage = exports.getFailedBatchesForDisplay = exports.getBulk2JobTotals = exports.getBatchTotals = exports.BatchInfoColumns = exports.escape = exports.JsonReporter = exports.CsvReporter = exports.HumanReporter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os_1 = require("os");
const core_1 = require("@salesforce/core");
const core_2 = require("@oclif/core");
const chalk = require("chalk");
const ts_types_1 = require("@salesforce/ts-types");
const change_case_1 = require("change-case");
const dataSoqlQueryTypes_1 = require("./dataSoqlQueryTypes");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'soql.query');
const reporterMessages = core_1.Messages.loadMessages('@salesforce/plugin-data', 'reporter');
class Reporter {
    constructor() {
        this.logger = core_1.Logger.childFromRoot('reporter');
    }
}
class QueryReporter extends Reporter {
    constructor(data, columns) {
        super();
        this.columns = [];
        this.columns = columns;
        this.data = data;
    }
}
class HumanReporter extends QueryReporter {
    constructor(data, columns) {
        super(data, columns);
    }
    display() {
        const { attributeNames, children, aggregates } = this.parseFields();
        // in case of count() there are no records, but there is a totalSize
        const totalCount = this.data.result.records.length ? this.data.result.records.length : this.data.result.totalSize;
        this.soqlQuery(attributeNames, this.massageRows(this.data.result.records, children, aggregates), totalCount);
    }
    parseFields() {
        const fields = this.columns;
        // Field names
        const attributeNames = [];
        // For subqueries. Display the children under the parents
        const children = [];
        // For function fields, like avg(total).
        const aggregates = [];
        if (fields) {
            this.logger.info(`Found fields ${JSON.stringify(fields.map((field) => `${typeof field}.${field.name}`))}`);
            fields.forEach((field) => {
                if (field.fieldType === dataSoqlQueryTypes_1.FieldType.subqueryField) {
                    children.push(field.name);
                    (field.fields ?? []).forEach((subfield) => attributeNames.push(`${field.name}.${subfield.name}`));
                }
                else if (field.fieldType === dataSoqlQueryTypes_1.FieldType.functionField) {
                    if (field.alias) {
                        attributeNames.push(field.alias);
                    }
                    else {
                        attributeNames.push(field.name);
                    }
                    aggregates.push(field);
                }
                else {
                    attributeNames.push(field.name);
                }
            });
        }
        else {
            this.logger.info(`No fields found for query "${this.data.query}"`);
        }
        return { attributeNames, children, aggregates };
    }
    soqlQuery(columns, records, totalCount) {
        this.prepNullValues(records);
        core_2.ux.table(records, prepColumns(columns));
        core_2.ux.log(chalk.bold(messages.getMessage('displayQueryRecordsRetrieved', [totalCount])));
    }
    prepNullValues(records) {
        records
            .filter((record) => record)
            .forEach((record) => {
            if (record) {
                const recordAsObject = record;
                Reflect.ownKeys(recordAsObject).forEach((propertyKey) => {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    const value = Reflect.get(recordAsObject, propertyKey);
                    if (value === null) {
                        Reflect.set(recordAsObject, propertyKey, chalk.bold('null'));
                    }
                    else if (typeof value === 'object') {
                        this.prepNullValues([value]);
                    }
                });
            }
        });
    }
    //  public massageRows(queryResults: BasicRecord[], children: string[], aggregates: Field[]): BasicRecord[] {
    massageRows(queryResults, children, aggregates) {
        // some fields will return a JSON object that isn't accessible via the query (SELECT Metadata FROM RemoteProxy)
        // some will return a JSON that IS accessible via the query (SELECT owner.Profile.Name FROM Lead)
        // querying (SELECT Metadata.isActive FROM RemoteProxy) throws a SOQL validation error, so we have to display the entire Metadata object
        queryResults.forEach((qr) => {
            const result = qr;
            this.data.columns.forEach((col) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const entry = Reflect.get(result, col.name);
                if (typeof entry === 'object' && col.fieldType === dataSoqlQueryTypes_1.FieldType.field) {
                    Reflect.set(result, col.name, JSON.stringify(entry, null, 2));
                }
                else if (typeof entry === 'object' && col.fields?.length && entry) {
                    col.fields.forEach((field) => {
                        Reflect.set(result, `${col.name}.${field.name}`, (0, ts_types_1.get)(result, `${col.name}.records[0].${field.name}`));
                    });
                }
            });
        });
        // There are subqueries or aggregates. Massage the data.
        if (children.length > 0 || aggregates.length > 0) {
            const qr = queryResults.reduce((newResults, result) => {
                // Aggregates are soql functions that aggregate data, like "SELECT avg(total)" and
                // are returned in the data as exprX. Aggregates can have aliases, like "avg(total) totalAverage"
                // and are returned in the data as the alias.
                if (aggregates.length > 0) {
                    for (let i = 0; i < aggregates.length; i++) {
                        const aggregate = aggregates[i];
                        if (!aggregate.alias) {
                            Reflect.set(result, aggregate.name, Reflect.get(result, `expr${i}`));
                        }
                    }
                }
                const subResults = [];
                if (children.length > 0) {
                    const childrenRows = {};
                    children.forEach((child) => {
                        const aChild = (0, ts_types_1.get)(result, child);
                        Reflect.set(childrenRows, child, aChild);
                        Reflect.deleteProperty(result, child);
                    });
                    Reflect.ownKeys(childrenRows).forEach((child) => {
                        const childO = (0, ts_types_1.get)(childrenRows, child);
                        if (childO) {
                            const childRecords = (0, ts_types_1.getArray)(childO, 'records', []);
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            childRecords.forEach((record, index) => {
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                const newResult = {};
                                Object.entries(record).forEach(([key, value]) => {
                                    if (!index) {
                                        Reflect.defineProperty(result, `${child.toString()}.${key}`, {
                                            value: value ?? chalk.bold('null'),
                                        });
                                    }
                                    else {
                                        Reflect.defineProperty(newResult, `${child.toString()}.${key}`, {
                                            value: value ?? chalk.bold('null'),
                                        });
                                    }
                                });
                                if (index) {
                                    subResults.push(newResult);
                                }
                            });
                        }
                    });
                }
                newResults.push(result, ...subResults);
                return newResults;
            }, []);
            return qr;
        }
        return queryResults;
    }
}
exports.HumanReporter = HumanReporter;
const SEPARATOR = ',';
const DOUBLE_QUOTE = '"';
const SHOULD_QUOTE_REGEXP = new RegExp(`[${SEPARATOR}${DOUBLE_QUOTE}${os_1.EOL}]`);
class CsvReporter extends QueryReporter {
    constructor(data, columns) {
        super(data, columns);
    }
    display() {
        const attributeNames = this.massageRows();
        // begin output
        core_2.ux.log(attributeNames.map((name) => (0, exports.escape)(name)).join(SEPARATOR));
        // explained why we need this below - foreach does not allow types
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.data.result.records.forEach((row) => {
            const values = attributeNames.map((name) => {
                // try get(row, name) first, then if it fails, default to row[name]. The default will happen in bulk cases.
                // the standard case returns {field:{nested: 'value'}}, while the bulk will return {field.nested: 'value'}
                const value = (0, ts_types_1.get)(row, name, row[name]);
                if ((0, ts_types_1.isString)(value)) {
                    return (0, exports.escape)(value);
                    // if value is null, then typeof value === 'object' so check before typeof to avoid illegal csv
                }
                else if (value === null) {
                    return;
                }
                else if (typeof value === 'object') {
                    return (0, exports.escape)(JSON.stringify(value));
                }
                return value;
            });
            core_2.ux.log(values.join(SEPARATOR));
        });
    }
    massageRows() {
        const fields = this.columns;
        const hasSubqueries = fields.some((field) => field.fieldType === dataSoqlQueryTypes_1.FieldType.subqueryField);
        const hasFunctions = fields.some((field) => field.fieldType === dataSoqlQueryTypes_1.FieldType.functionField);
        const attributeNames = [];
        if (fields) {
            this.logger.info(`Found fields ${JSON.stringify(fields.map((field) => `${typeof field}.${field.name}`))}`);
        }
        else {
            this.logger.info(`No fields found for query "${this.data.query}"`);
        }
        if (hasSubqueries || hasFunctions) {
            // If there are subqueries, we need to get the max child length for each subquery.
            const typeLengths = new Map();
            // For function fields, like avg(total).
            const aggregates = [];
            fields.forEach((field) => {
                if (field.fieldType === dataSoqlQueryTypes_1.FieldType.subqueryField) {
                    typeLengths.set(field.name, 0);
                }
                if (field.fieldType === dataSoqlQueryTypes_1.FieldType.functionField) {
                    aggregates.push(field);
                }
            });
            // Get max lengths by iterating over the records once
            this.data.result.records.forEach((result) => {
                [...typeLengths.keys()].forEach((key) => {
                    const record = (0, ts_types_1.get)(result, key);
                    const totalSize = (0, ts_types_1.getNumber)(record, 'totalSize');
                    if (!!totalSize && totalSize > (typeLengths.get(key) ?? 0)) {
                        typeLengths.set(key, totalSize);
                    }
                });
                // Aggregates are soql functions that aggregate data, like "SELECT avg(total)" and
                // are returned in the data as exprX. Aggregates can have aliases, like "avg(total) totalAverage"
                // and are returned in the data as the alias.
                if (aggregates.length > 0) {
                    for (let i = 0; i < aggregates.length; i++) {
                        const aggregate = aggregates[i];
                        if (!aggregate.alias) {
                            Reflect.set(result, aggregate.name, Reflect.get(result, `expr${i}`));
                        }
                    }
                }
            });
            fields.forEach((field) => {
                if (typeLengths.get(field.name)) {
                    for (let i = 0; i < (typeLengths.get(field.name) ?? 0); i++) {
                        attributeNames.push(`${field.name}.totalSize`);
                        (field.fields ?? []).forEach((subfield) => {
                            attributeNames.push(`${field.name}.records.${i}.${subfield.name}`);
                        });
                    }
                }
                else if (field.fieldType === dataSoqlQueryTypes_1.FieldType.functionField) {
                    if (field.alias) {
                        attributeNames.push(field.alias);
                    }
                    else {
                        attributeNames.push(field.name);
                    }
                }
                else {
                    attributeNames.push(field.name);
                }
            });
        }
        else {
            attributeNames.push(...fields.map((field) => field.name));
        }
        return attributeNames;
    }
}
exports.CsvReporter = CsvReporter;
class JsonReporter extends QueryReporter {
    constructor(data, columns) {
        super(data, columns);
    }
    // eslint-disable-next-line class-methods-use-this
    log() {
        return;
    }
    display() {
        core_2.ux.styledJSON({ status: 0, result: this.data.result });
    }
}
exports.JsonReporter = JsonReporter;
const prepColumns = (columns) => {
    const formattedColumns = {};
    columns
        .map((field) => field)
        .filter(ts_types_1.isString)
        .map((field) => (formattedColumns[field] = {
        header: field.toUpperCase(),
        get: (row) => {
            // first test if key exists, if so, return value
            if (Reflect.has(row, field)) {
                return Reflect.get(row, field) ?? '';
            }
            else {
                // if not, try to find it query
                return (0, ts_types_1.get)(row, field) ?? '';
            }
        },
    }));
    return formattedColumns;
};
/**
 * Escape a value to be placed in a CSV row. We follow rfc 4180
 * https://tools.ietf.org/html/rfc4180#section-2 and will not surround the
 * value in quotes if it doesn't contain the separator, double quote, or EOL.
 *
 * @param value The escaped value
 */
const escape = (value) => {
    if (value && SHOULD_QUOTE_REGEXP.test(value)) {
        return `"${value.replace(/"/gi, '""')}"`;
    }
    return value;
};
exports.escape = escape;
exports.BatchInfoColumns = {
    id: { header: 'Batch Id' },
    state: { header: 'State' },
    failed: { header: 'Failed' },
    stateMessage: { header: 'Message' },
};
const getBatchTotals = (batches) => batches.reduce((acc, batch) => {
    acc.total += parseInt(batch.numberRecordsProcessed, 10);
    acc.failed += parseInt(batch.numberRecordsFailed, 10);
    acc.success = acc.total - acc.failed;
    return acc;
}, { total: 0, failed: 0, success: 0 });
exports.getBatchTotals = getBatchTotals;
function getBulk2JobTotals(results) {
    const ttls = { total: 0, failed: 0, success: 0, unprocessed: 0 };
    ttls.total =
        Object.keys(results.successfulResults).length +
            Object.keys(results.failedResults).length +
            Object.keys(results.unprocessedRecords).length;
    ttls.failed = Object.keys(results.failedResults).length;
    ttls.success = Object.keys(results.successfulResults).length;
    ttls.unprocessed = Object.keys(results.unprocessedRecords).length;
    return ttls;
}
exports.getBulk2JobTotals = getBulk2JobTotals;
const getFailedBatchesForDisplay = (batches) => {
    const failedBatches = batches.filter((batch) => parseInt(batch.numberRecordsFailed, 10) > 0);
    const batchesForTable = failedBatches.map((batch) => ({
        id: batch.id,
        state: batch.state,
        failed: `${batch.numberRecordsFailed.toString().padStart(5, ' ')}/${batch.numberRecordsProcessed
            .toString()
            .padStart(5, ' ')}`,
        stateMessage: batch.stateMessage,
    }));
    return batchesForTable;
};
exports.getFailedBatchesForDisplay = getFailedBatchesForDisplay;
const getResultMessage = (jobInfo) => reporterMessages.getMessage('bulkV2Result', [
    jobInfo.id,
    (0, change_case_1.capitalCase)(jobInfo.state),
    jobInfo.numberRecordsProcessed,
    jobInfo.numberRecordsFailed,
]);
exports.getResultMessage = getResultMessage;
//# sourceMappingURL=reporters.js.map