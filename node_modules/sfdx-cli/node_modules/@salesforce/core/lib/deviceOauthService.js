"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/* eslint-disable camelcase */
/* eslint-disable @typescript-eslint/ban-types */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceOauthService = void 0;
const transport_1 = require("jsforce/lib/transport");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const FormData = require("form-data");
const logger_1 = require("./logger");
const org_1 = require("./org");
const sfError_1 = require("./sfError");
const messages_1 = require("./messages");
const messages = new messages_1.Messages('@salesforce/core', 'auth', new Map([["targetOrgNotSet", "A default user is not set."], ["targetOrgNotSet.actions", ["Run the \"sfdx auth\" commands with --setdefaultusername to connect to an org and set it as your default org.", "Run \"force:org:create\" with --setdefaultusername to create a scratch org and set it as your default org.", "Run \"sfdx config:set defaultusername=<username>\" to set your default username."]], ["portInUse", "Cannot start the OAuth redirect server on port %s."], ["portInUse.actions", ["Kill the process running on port %s or use a custom connected app and update OauthLocalPort in the sfdx-project.json file."]], ["invalidRequestMethod", "Invalid request method: %s"], ["invalidRequestUri", "Invalid request uri: %s"], ["pollingTimeout", "The device authorization request timed out. After executing force:auth:device:login, you must approve access to the device within 10 minutes. This can happen if the URL wasn\u2019t copied into the browser, login was not attempted, or the 2FA process was not completed within 10 minutes. Request authorization again."], ["serverErrorHTMLResponse", "<h1>%s</h1><br />This is most likely <b>not</b> an error with the Salesforce CLI. Please ensure all information is accurate and try again."], ["missingAuthCode", "No authentication code found on login response."]]));
async function wait(ms = 1000) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
async function makeRequest(options) {
    const rawResponse = await new transport_1.default().httpRequest(options);
    const response = (0, kit_1.parseJsonMap)(rawResponse.body);
    if (response.error) {
        const errorDescription = typeof response.error_description === 'string' ? response.error_description : '';
        const error = typeof response.error === 'string' ? response.error : 'Unknown';
        const err = new sfError_1.SfError(`Request Failed: ${error} ${errorDescription}`);
        err.data = Object.assign(response, { status: rawResponse.statusCode });
        throw err;
    }
    else {
        return response;
    }
}
/**
 * Handles device based login flows
 *
 * Usage:
 * ```
 * const oauthConfig = {
 *   loginUrl: this.flags.instanceurl,
 *   clientId: this.flags.clientid,
 * };
 * const deviceOauthService = await DeviceOauthService.create(oauthConfig);
 * const loginData = await deviceOauthService.requestDeviceLogin();
 * console.log(loginData);
 * const approval = await deviceOauthService.awaitDeviceApproval(loginData);
 * const authInfo = await deviceOauthService.authorizeAndSave(approval);
 * ```
 */
class DeviceOauthService extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.pollingCount = 0;
        this.options = options;
        if (!this.options.clientId)
            this.options.clientId = org_1.DEFAULT_CONNECTED_APP_INFO.clientId;
        if (!this.options.loginUrl)
            this.options.loginUrl = org_1.AuthInfo.getDefaultInstanceUrl();
    }
    /**
     * Begin the authorization flow by requesting the login
     *
     * @returns {Promise<DeviceCodeResponse>}
     */
    async requestDeviceLogin() {
        const deviceFlowRequestUrl = this.getDeviceFlowRequestUrl();
        const loginOptions = this.getLoginOptions(deviceFlowRequestUrl);
        return makeRequest(loginOptions);
    }
    /**
     * Polls the server until successful response OR max attempts have been made
     *
     * @returns {Promise<Nullable<DeviceCodePollingResponse>>}
     */
    async awaitDeviceApproval(loginData) {
        const deviceFlowRequestUrl = this.getDeviceFlowRequestUrl();
        const pollingOptions = this.getPollingOptions(deviceFlowRequestUrl, loginData.device_code);
        const interval = kit_1.Duration.seconds(loginData.interval).milliseconds;
        return this.pollForDeviceApproval(pollingOptions, interval);
    }
    /**
     * Creates and saves new AuthInfo
     *
     * @returns {Promise<AuthInfo>}
     */
    async authorizeAndSave(approval) {
        const authInfo = await org_1.AuthInfo.create({
            oauth2Options: {
                loginUrl: approval.instance_url,
                refreshToken: approval.refresh_token,
                clientSecret: this.options.clientSecret,
                clientId: this.options.clientId,
            },
        });
        await authInfo.save();
        return authInfo;
    }
    async init() {
        this.logger = await logger_1.Logger.child(this.constructor.name);
        this.logger.debug(`this.options.clientId: ${this.options.clientId}`);
        this.logger.debug(`this.options.loginUrl: ${this.options.loginUrl}`);
    }
    getLoginOptions(url) {
        const form = new FormData();
        form.append('client_id', (0, ts_types_1.ensureString)(this.options.clientId));
        form.append('response_type', DeviceOauthService.RESPONSE_TYPE);
        form.append('scope', DeviceOauthService.SCOPE);
        return {
            url,
            headers: { ...org_1.SFDX_HTTP_HEADERS, ...form.getHeaders() },
            method: 'POST',
            body: form.getBuffer(),
        };
    }
    getPollingOptions(url, code) {
        const form = new FormData();
        form.append('client_id', (0, ts_types_1.ensureString)(this.options.clientId));
        form.append('grant_type', DeviceOauthService.GRANT_TYPE);
        form.append('code', code);
        return {
            url,
            headers: { ...org_1.SFDX_HTTP_HEADERS, ...form.getHeaders() },
            method: 'POST',
            body: form.getBuffer(),
        };
    }
    getDeviceFlowRequestUrl() {
        return `${(0, ts_types_1.ensureString)(this.options.loginUrl)}/services/oauth2/token`;
    }
    async poll(httpRequest) {
        this.logger.debug(`polling for device approval (attempt ${this.pollingCount} of ${DeviceOauthService.POLLING_COUNT_MAX})`);
        try {
            return await makeRequest(httpRequest);
        }
        catch (e) {
            /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions */
            const err = e.data;
            if (err.error && err.status === 400 && err.error === 'authorization_pending') {
                // do nothing because we're still waiting
            }
            else {
                if (err.error && err.error_description) {
                    this.logger.error(`Polling error: ${err.error}: ${err.error_description}`);
                }
                else {
                    this.logger.error('Unknown Polling Error:');
                    this.logger.error(err);
                }
                throw err;
            }
            /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions */
        }
    }
    shouldContinuePolling() {
        return this.pollingCount < DeviceOauthService.POLLING_COUNT_MAX;
    }
    async pollForDeviceApproval(httpRequest, interval) {
        this.logger.debug('BEGIN POLLING FOR DEVICE APPROVAL');
        let result;
        while (this.shouldContinuePolling()) {
            // eslint-disable-next-line no-await-in-loop
            result = await this.poll(httpRequest);
            if (result) {
                this.logger.debug('POLLING FOR DEVICE APPROVAL SUCCESS');
                break;
            }
            else {
                this.logger.debug(`waiting ${interval} ms...`);
                // eslint-disable-next-line no-await-in-loop
                await wait(interval);
                this.pollingCount += 1;
            }
        }
        if (this.pollingCount >= DeviceOauthService.POLLING_COUNT_MAX) {
            // stop polling, the user has likely abandoned the command...
            this.logger.error(`Polling timed out because max polling was hit: ${this.pollingCount}`);
            throw messages.createError('pollingTimeout');
        }
        return result;
    }
}
exports.DeviceOauthService = DeviceOauthService;
DeviceOauthService.RESPONSE_TYPE = 'device_code';
DeviceOauthService.GRANT_TYPE = 'device';
DeviceOauthService.SCOPE = 'refresh_token web api';
DeviceOauthService.POLLING_COUNT_MAX = 100;
//# sourceMappingURL=deviceOauthService.js.map