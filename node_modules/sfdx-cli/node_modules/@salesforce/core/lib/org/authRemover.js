"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthRemover = void 0;
const kit_1 = require("@salesforce/kit");
const configAggregator_1 = require("../config/configAggregator");
const logger_1 = require("../logger");
const messages_1 = require("../messages");
const stateAggregator_1 = require("../stateAggregator");
const orgConfigProperties_1 = require("./orgConfigProperties");
const messages = new messages_1.Messages('@salesforce/core', 'auth', new Map([["targetOrgNotSet", "A default user is not set."], ["targetOrgNotSet.actions", ["Run the \"sfdx auth\" commands with --setdefaultusername to connect to an org and set it as your default org.", "Run \"force:org:create\" with --setdefaultusername to create a scratch org and set it as your default org.", "Run \"sfdx config:set defaultusername=<username>\" to set your default username."]], ["portInUse", "Cannot start the OAuth redirect server on port %s."], ["portInUse.actions", ["Kill the process running on port %s or use a custom connected app and update OauthLocalPort in the sfdx-project.json file."]], ["invalidRequestMethod", "Invalid request method: %s"], ["invalidRequestUri", "Invalid request uri: %s"], ["pollingTimeout", "The device authorization request timed out. After executing force:auth:device:login, you must approve access to the device within 10 minutes. This can happen if the URL wasn\u2019t copied into the browser, login was not attempted, or the 2FA process was not completed within 10 minutes. Request authorization again."], ["serverErrorHTMLResponse", "<h1>%s</h1><br />This is most likely <b>not</b> an error with the Salesforce CLI. Please ensure all information is accurate and try again."], ["missingAuthCode", "No authentication code found on login response."]]));
/**
 * Handles  the removing of authorizations, which includes deleting the auth file
 * in the global .sfdx folder, deleting any configs that are associated with the username/alias,
 * and deleting any aliases associated with the username
 *
 * ```
 * const remover = await AuthRemover.create();
 * await remover.removeAuth('example@mycompany.com');
 * ```
 *
 * ```
 * const remover = await AuthRemover.create();
 * await remover.removeAllAuths();
 * ```
 *
 * ```
 * const remover = await AuthRemover.create();
 * const auth = await remover.findAuth(
 *  example@mycompany.com
 * );
 * await remover.removeAuth(auth.username);
 * ```
 */
class AuthRemover extends kit_1.AsyncOptionalCreatable {
    /**
     * Removes the authentication and any configs or aliases associated with it
     *
     * @param usernameOrAlias the username or alias that you want to remove
     */
    async removeAuth(usernameOrAlias) {
        const username = await this.resolveUsername(usernameOrAlias);
        this.logger.debug(`Removing authorization for user ${username}`);
        await this.unsetConfigValues(username);
        await this.unsetAliases(username);
        await this.unsetTokens(username);
        await this.stateAggregator.orgs.remove(username);
    }
    /**
     * Removes all authentication files and any configs or aliases associated with them
     */
    async removeAllAuths() {
        const auths = this.findAllAuths();
        const usernames = Object.keys(auths);
        for (const username of usernames) {
            // prevent ConfigFile collision bug
            // eslint-disable-next-line no-await-in-loop
            await this.removeAuth(username);
        }
    }
    /**
     * Finds authorization files for username/alias in the global .sfdx folder
     * **Throws** *{@link SfError}{ name: 'TargetOrgNotSetError' }* if no target-org
     * **Throws** *{@link SfError}{ name: 'NamedOrgNotFoundError' }* if specified user is not found
     *
     * @param usernameOrAlias username or alias of the auth you want to find, defaults to the configured target-org
     * @returns {Promise<SfOrg>}
     */
    async findAuth(usernameOrAlias) {
        const username = await this.resolveUsername(usernameOrAlias ?? this.getTargetOrg());
        return this.stateAggregator.orgs.get(username, false, true);
    }
    /**
     * Finds all org authorizations in the global info file (.sf/sf.json)
     *
     * @returns {Record<string, AuthFields>}
     */
    findAllAuths() {
        const orgs = this.stateAggregator.orgs.getAll();
        return orgs.reduce((x, y) => 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        ({ ...x, [y.username]: y }), {});
    }
    async init() {
        this.logger = await logger_1.Logger.child(this.constructor.name);
        this.config = await configAggregator_1.ConfigAggregator.create();
        this.stateAggregator = await stateAggregator_1.StateAggregator.getInstance();
        await this.stateAggregator.orgs.readAll();
    }
    /**
     * Returns the username for a given alias if the alias exists.
     *
     * @param usernameOrAlias username or alias
     * @returns {Promise<string>}
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async resolveUsername(usernameOrAlias) {
        return this.stateAggregator.aliases.resolveUsername(usernameOrAlias);
    }
    /**
     * @returns {string}
     */
    getTargetOrg() {
        const targetOrg = this.config.getInfo(orgConfigProperties_1.OrgConfigProperties.TARGET_ORG).value;
        if (!targetOrg) {
            throw messages.createError('targetOrgNotSet');
        }
        return targetOrg;
    }
    /**
     * Returns aliases for provided username
     *
     * @param username username that's been aliased
     * @returns {Promise<string[]>}
     */
    getAliases(username) {
        return this.stateAggregator.aliases.getAll(username);
    }
    /**
     * Unsets any configured values (both global and local) for provided username
     *
     * @param username username that you want to remove from config files
     */
    async unsetConfigValues(username) {
        const aliases = this.getAliases(username);
        this.logger.debug(`Clearing config keys for username ${username} and aliases: ${aliases.join(',')}`);
        const configs = [this.config.getGlobalConfig(), this.config.getLocalConfig()];
        for (const config of configs) {
            if (config) {
                const keysWithUsername = config.getKeysByValue(username) || [];
                const keysWithAlias = aliases
                    .map((alias) => config.getKeysByValue(alias))
                    .filter((k) => !!k)
                    .reduce((x, y) => x.concat(y), []);
                const allKeys = keysWithUsername.concat(keysWithAlias);
                this.logger.debug(`Found these config keys to remove: ${allKeys.join(',')}`);
                allKeys.forEach((key) => {
                    try {
                        config.unset(key);
                    }
                    catch {
                        this.logger.debug(`Failed to remove ${key}`);
                    }
                });
                // prevent ConfigFile collision bug
                // eslint-disable-next-line no-await-in-loop
                await config.write();
            }
        }
    }
    /**
     * Unsets any aliases for provided username
     *
     * @param username username that you want to remove from aliases
     */
    async unsetAliases(username) {
        this.logger.debug(`Clearing aliases for username: ${username}`);
        const existingAliases = this.stateAggregator.aliases.getAll(username);
        if (existingAliases.length === 0)
            return;
        this.logger.debug(`Found these aliases to remove: ${existingAliases.join(',')}`);
        existingAliases.forEach((alias) => this.stateAggregator.aliases.unset(alias));
        await this.stateAggregator.aliases.write();
    }
    async unsetTokens(username) {
        this.logger.debug(`Clearing tokens for username: ${username}`);
        const tokens = this.stateAggregator.tokens.getAll();
        for (const [key, token] of Object.entries(tokens)) {
            if (token.user === username) {
                this.stateAggregator.tokens.unset(key);
            }
        }
        await this.stateAggregator.tokens.write();
    }
}
exports.AuthRemover = AuthRemover;
//# sourceMappingURL=authRemover.js.map