"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SfCommand = exports.StandardColors = void 0;
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const chalk = require("chalk");
const ux_1 = require("./ux");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/sf-plugins-core', 'messages');
exports.StandardColors = {
    error: chalk.bold.red,
    warning: chalk.bold.yellow,
    info: chalk.dim,
    success: chalk.bold.green,
};
/**
 * A base command that provided common functionality for all sf commands.
 * Functionality includes:
 *  - JSON support
 *  - progress bars
 *  - spinners
 *  - prompts
 *  - stylized output (JSON, url, objects, headers)
 *  - lifecycle events
 *  - configuration variables help section
 *  - environment variables help section
 *  - error codes help section
 *
 * All implementations of this class need to implement the run() method.
 *
 * Additionally, all implementations of this class need to provide a generic type that describes the JSON output.
 *
 * See {@link https://github.com/salesforcecli/plugin-template-sf/blob/main/src/commands/hello/world.ts example implementation}.
 *
 * @example
 *
 * ```
 * import { SfCommand } from '@salesforce/sf-plugins-core';
 * export type MyJsonOutput = { success: boolean };
 * export default class MyCommand extends SfCommand<MyJsonOutput> {
 *   public async run(): Promise<MyJsonOutput> {
 *    return { success: true };
 *  }
 * }
 * ```
 */
class SfCommand extends core_1.Command {
    constructor(argv, config) {
        super(argv, config);
        this.warnings = [];
        this.ux = new ux_1.Ux({ jsonEnabled: this.jsonEnabled() });
        this.progress = new ux_1.Progress(this.ux.outputEnabled && core_2.envVars.getBoolean(core_2.EnvironmentVariable.SF_USE_PROGRESS_BAR, true));
        this.spinner = this.ux.spinner;
        this.prompter = this.ux.prompter;
        this.lifecycle = core_2.Lifecycle.getInstance();
    }
    get statics() {
        return this.constructor;
    }
    /**
     * Log a success message that has the standard success message color applied.
     *
     * @param message The message to log.
     */
    logSuccess(message) {
        this.log(exports.StandardColors.success(message));
    }
    /**
     * Log warning to users. If --json is enabled, then the warning will be added to the json output under the warnings property.
     *
     * @param input {@link SfCommand.Warning} The message to log.
     */
    warn(input) {
        const colorizedArgs = [];
        this.warnings.push(input);
        const message = typeof input === 'string' ? input : input.message;
        colorizedArgs.push(`${exports.StandardColors.warning(messages.getMessage('warning.prefix'))} ${message}`);
        colorizedArgs.push(...this.formatActions(typeof input === 'string' ? [] : input.actions ?? [], { actionColor: exports.StandardColors.info }));
        this.logToStderr(colorizedArgs.join(os.EOL));
        return input;
    }
    /**
     * Log info message to users.
     *
     * @param input {@link SfCommand.Info} The message to log.
     */
    info(input) {
        const colorizedArgs = [];
        const message = typeof input === 'string' ? input : input.message;
        colorizedArgs.push(`${exports.StandardColors.info(message)}`);
        colorizedArgs.push(...this.formatActions(typeof input === 'string' ? [] : input.actions ?? [], { actionColor: exports.StandardColors.info }));
        this.log(colorizedArgs.join(os.EOL));
    }
    /**
     * Warn user about sensitive information (access tokens, etc...) before logging to the console.
     *
     * @param msg The message to log.
     */
    logSensitive(msg) {
        this.warn(messages.getMessage('warning.security'));
        this.log(msg);
    }
    /**
     * Display a table on the console. Will automatically be suppressed when --json flag is present.
     */
    table(data, columns, options) {
        this.ux.table(data, columns, options);
    }
    /**
     * Log a stylized url to the console. Will automatically be suppressed when --json flag is present.
     *
     * @param text The text to display for the url.
     * @param uri The url to display.
     */
    url(text, uri, params = {}) {
        this.ux.url(text, uri, params);
    }
    /**
     * Log stylized JSON to the console. Will automatically be suppressed when --json flag is present.
     *
     * @param obj The JSON to log.
     */
    styledJSON(obj) {
        this.ux.styledJSON(obj);
    }
    /**
     * Log stylized object to the console. Will automatically be suppressed when --json flag is present.
     *
     * @param obj The object to log.
     */
    styledObject(obj) {
        this.ux.styledObject(obj);
    }
    /**
     * Log stylized header to the console. Will automatically be suppressed when --json flag is present.
     *
     * @param text the text to display as a header.
     */
    styledHeader(text) {
        this.ux.styledHeader(text);
    }
    // eslint-disable-next-line class-methods-use-this
    logJson(json) {
        // If `--json` is enabled, then the ux instance on the class will disable output, which
        // means that the logJson method will not output anything. So, we need to create a new
        // instance of the ux class that does not have output disabled in order to log the json.
        new ux_1.Ux().styledJSON(json);
    }
    /**
     * Prompt user for information. See https://www.npmjs.com/package/inquirer for more.
     *
     * This will NOT be automatically suppressed when the --json flag is present since we assume
     * that any command that prompts the user for required information will not also support the --json flag.
     *
     * If you need to conditionally suppress prompts to support json output, then do the following:
     *
     * @example
     * if (!this.jsonEnabled()) {
     *   await this.prompt();
     * }
     */
    async prompt(questions, initialAnswers) {
        return this.prompter.prompt(questions, initialAnswers);
    }
    /**
     * Simplified prompt for single-question confirmation. Times out and throws after 10s
     *
     * @param message text to display.  Do not include a question mark.
     * @param ms milliseconds to wait for user input.  Defaults to 10s.
     * @param defaultAnswer boolean to set the default answer to.  Defaults to true.
     * @return true if the user confirms, false if they do not.
     */
    async confirm(message, ms = 10000, defaultAnswer = true) {
        return this.prompter.confirm(message, ms, defaultAnswer);
    }
    /**
     * Prompt user for information with a timeout (in milliseconds). See https://www.npmjs.com/package/inquirer for more.
     */
    async timedPrompt(questions, ms = 10000, initialAnswers) {
        return this.prompter.timedPrompt(questions, ms, initialAnswers);
    }
    async _run() {
        this.configAggregator =
            this.config.bin === 'sfdx' ??
                kit_1.env.getBoolean('SF_USE_DEPRECATED_CONFIG_VARS') ??
                kit_1.env.getBoolean('SFDX_USE_DEPRECATED_CONFIG_VARS')
                ? await core_2.SfdxConfigAggregator.create()
                : await core_2.ConfigAggregator.create();
        if (this.statics.requiresProject) {
            this.project = await this.assignProject();
        }
        if (this.statics.state === 'beta') {
            this.warn(messages.getMessage('warning.CommandInBeta'));
        }
        this.lifecycle.onWarning(async (warning) => {
            this.warn(warning);
        });
        const options = {
            Command: this.ctor,
            argv: this.argv,
            commandId: this.id,
        };
        // what hooks are there in the plugins?  Subscribe to matching lifecycle events
        this.config.plugins
            // omit oclif and telemetry (which subscribes itself to events already)
            .filter((plugin) => !plugin.name.startsWith('@oclif/') && plugin.name !== '@salesforce/plugin-telemetry')
            .flatMap((p) => Object.entries(p.hooks))
            .map(([eventName, hooksForEvent]) => {
            hooksForEvent.map(() => {
                this.lifecycle.on(eventName, async (result) => {
                    await this.config.runHook(eventName, Object.assign(options, { result }));
                });
            });
        });
        return super._run();
    }
    /**
     * Wrap the command result into the standardized JSON structure.
     */
    toSuccessJson(result) {
        return {
            status: process.exitCode ?? 0,
            result,
            warnings: this.warnings,
        };
    }
    /**
     * Wrap the command error into the standardized JSON structure.
     */
    toErrorJson(error) {
        return {
            ...error,
            warnings: this.warnings,
        };
    }
    // eslint-disable-next-line class-methods-use-this
    async assignProject() {
        try {
            return await core_2.SfProject.resolve();
        }
        catch (err) {
            if (err instanceof Error && err.name === 'InvalidProjectWorkspaceError') {
                throw messages.createError('errors.RequiresProject');
            }
            throw err;
        }
    }
    async catch(error) {
        // transform an unknown error into one that conforms to the interface
        // @ts-expect-error because exitCode is not on Error
        const codeFromError = error.exitCode ?? 1;
        process.exitCode ?? (process.exitCode = codeFromError);
        const sfErrorProperties = removeEmpty({
            // @ts-expect-error because data is not on Error
            data: error.data ?? null,
            // @ts-expect-error because actions is not on Error
            actions: error.actions ?? null,
            code: codeFromError,
            // @ts-expect-error because context is not on Error
            context: error.context ?? null,
        });
        // Create printable error object
        const sfCommandError = {
            ...sfErrorProperties,
            ...{
                message: error.message,
                name: error.name ?? 'Error',
                status: process.exitCode,
                stack: error.stack,
                exitCode: process.exitCode,
            },
        };
        if (this.jsonEnabled()) {
            this.logJson(this.toErrorJson(sfCommandError));
        }
        else {
            this.logToStderr(this.formatError(sfCommandError));
        }
        // Create SfError that can be thrown
        const err = new core_2.SfError(error.message, error.name ?? 'Error', 
        // @ts-expect-error because actions is not on Error
        error.actions ?? [], process.exitCode);
        err.context = sfCommandError.context;
        err.stack = sfCommandError.stack;
        // @ts-expect-error because code is not on SfError
        err.code = codeFromError;
        // @ts-expect-error because status is not on SfError
        err.status = sfCommandError.status;
        // @ts-expect-error because skipOclifErrorHandling is not on SfError
        err.skipOclifErrorHandling = true;
        throw err;
    }
    /**
     * Format errors and actions for human consumption. Adds 'Error (<ErrorCode>):',
     * When there are actions, we add 'Try this:' in blue
     * followed by each action in red on its own line.
     * If Error.code is present it is output last in parentheses
     *
     * @returns {string} Returns decorated messages.
     */
    formatError(error) {
        const colorizedArgs = [];
        const errorCode = error.code ? ` (${error.code})` : '';
        const errorPrefix = `${exports.StandardColors.error(messages.getMessage('error.prefix', [errorCode]))}`;
        colorizedArgs.push(`${errorPrefix} ${error.message}`);
        colorizedArgs.push(...this.formatActions(error.actions ?? []));
        if (error.stack && core_2.envVars.getString(SfCommand.SF_ENV) === core_2.Mode.DEVELOPMENT) {
            colorizedArgs.push(exports.StandardColors.info(`\n*** Internal Diagnostic ***\n\n${error.stack}\n******\n`));
        }
        return colorizedArgs.join('\n');
    }
    /**
     * Utility function to format actions lines
     *
     * @param actions
     * @param options
     * @private
     */
    // eslint-disable-next-line class-methods-use-this
    formatActions(actions, options = { actionColor: exports.StandardColors.info }) {
        const colorizedArgs = [];
        // Format any actions.
        if (actions?.length) {
            colorizedArgs.push(`\n${exports.StandardColors.info(messages.getMessage('actions.tryThis'))}\n`);
            actions.forEach((action) => {
                colorizedArgs.push(`${options.actionColor(action)}`);
            });
        }
        return colorizedArgs;
    }
}
exports.SfCommand = SfCommand;
SfCommand.SF_ENV = 'SF_ENV';
SfCommand.enableJsonFlag = true;
/**
 * Flags that you can use for manipulating tables.
 *
 * @example
 * ```
 * import { SfCommand } from '@salesforce/sf-plugins-core';
 * export default class MyCommand extends SfCommand {
 *   public static flags = {
 *    ...SfCommand.tableFags,
 *    'my-flags: flags.string({ char: 'm', description: 'my flag' }),
 *   }
 * }
 * ```
 */
SfCommand.tableFlags = core_1.ux.table.flags;
function removeEmpty(obj) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
}
//# sourceMappingURL=sfCommand.js.map