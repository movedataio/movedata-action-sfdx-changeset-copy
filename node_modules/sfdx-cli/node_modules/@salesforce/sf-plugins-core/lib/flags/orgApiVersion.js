"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orgApiVersionFlag = exports.maxDeprecatedUrl = exports.maxDeprecated = exports.minValidApiVersion = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@oclif/core");
const core_2 = require("@salesforce/core");
core_2.Messages.importMessagesDirectory(__dirname);
const messages = core_2.Messages.loadMessages('@salesforce/sf-plugins-core', 'messages');
// versions below this are retired
exports.minValidApiVersion = 21;
// this and all un-retired versions below it are deprecated
exports.maxDeprecated = 30;
exports.maxDeprecatedUrl = 'https://help.salesforce.com/s/articleView?id=000354473&type=1;';
/**
 * apiVersion for a salesforce org's rest api.
 * Will validate format and that the api version is still supported.
 * Will default to the version specified in Config, if it exists (and will provide an override warning)
 *
 * CAVEAT: unlike the apiversion flag on sfdxCommand, this does not set the version on the org/connection
 * We leave this up to the plugins to implement
 *
 * @example
 *
 * ```
 * import { Flags } from '@salesforce/sf-plugins-core';
 * public static flags = {
 *    'api-version': Flags.orgApiVersion({
 *       char: 'a',
 *       description: 'api version for the org'
 *    }),
 * }
 * ```
 */
exports.orgApiVersionFlag = core_1.Flags.custom({
    parse: async (input) => validate(input),
    default: async () => getDefaultFromConfig(),
    description: messages.getMessage('flags.apiVersion.description'),
});
const getDefaultFromConfig = async () => {
    // (perf) only import ConfigAggregator if necessary
    const { ConfigAggregator } = await Promise.resolve().then(() => require('@salesforce/core'));
    const config = await ConfigAggregator.create();
    const apiVersionFromConfig = config.getInfo(core_2.OrgConfigProperties.ORG_API_VERSION)?.value;
    if (apiVersionFromConfig) {
        await core_2.Lifecycle.getInstance().emitWarning(messages.getMessage('flags.apiVersion.overrideWarning', [apiVersionFromConfig]));
        return validate(apiVersionFromConfig);
    }
};
const validate = async (input) => {
    // basic format check
    if (!core_2.sfdc.validateApiVersion(input)) {
        throw messages.createError('errors.InvalidApiVersion', [input]);
    }
    const requestedVersion = parseInt(input, 10);
    if (requestedVersion < exports.minValidApiVersion) {
        throw messages.createError('errors.RetiredApiVersion', [exports.minValidApiVersion]);
    }
    if (requestedVersion <= exports.maxDeprecated) {
        await core_2.Lifecycle.getInstance().emitWarning(messages.getMessage('flags.apiVersion.warning.deprecated', [exports.maxDeprecated, exports.maxDeprecatedUrl]));
    }
    return input;
};
//# sourceMappingURL=orgApiVersion.js.map