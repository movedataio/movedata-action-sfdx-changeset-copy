"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFieldNames = exports.appendDirectorySuffix = exports.getFieldPrimitiveType = exports.createRecord = exports.getFieldDataType = exports.getFileData = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const fast_xml_parser_1 = require("fast-xml-parser");
const ts_types_1 = require("@salesforce/ts-types");
const templates_1 = require("../templates/templates");
const fieldTypeMap = new Map([
    ['Checkbox', 'boolean'],
    ['Date', 'date'],
    ['DateTime', 'dateTime'],
    ['Email', 'string'],
    ['Phone', 'string'],
    ['Picklist', 'string'],
    ['Text', 'string'],
    ['TextArea', 'string'],
    ['LongTextArea', 'string'],
    ['Url', 'string'],
]);
// NOTE: the template string indentation is important to output well-formatted XML. Altering that whitespace will change the whitespace of the output.
/**
 * Number and Percent types will be int or double depending on their respective scale values.
 * If the scale === 0, it is an int, otherwise it is a double
 */
/**
 *
 * @param fieldDirPath path to a /fields folder that contains all the fields to read
 * @param fileNames filenames in that folder that should be read
 * @returns CustomField[]
 */
const getFileData = async (fieldDirPath, fileNames) => {
    const parser = new fast_xml_parser_1.XMLParser();
    return Promise.all(fileNames
        .map((file) => path.join(fieldDirPath, file))
        .map(async (filePath) => {
        const fileData = await fs.promises.readFile(filePath, 'utf8');
        return parser.parse(fileData).CustomField;
    }));
};
exports.getFileData = getFileData;
/**
 * Get the field type from the custom metadata type that has a matching field name.
 *
 * @param  fileData Array of objects based on metadata type xml
 * @param  fieldName Name of the field
 * @return {string} Data Type of the field.
 */
const getFieldDataType = (fileData = [], fieldName = '') => fileData.find((file) => file.fullName === fieldName)?.type;
exports.getFieldDataType = getFieldDataType;
/**
 * Creates the Custom Metadata Record
 *
 * @param  createConfig Properties include typename, recname, label, protection, varargs, and fileData
 * @return void
 */
const createRecord = async (createConfig) => {
    const outputFilePath = path.join(createConfig.outputdir, `${createConfig.typename}.${createConfig.recordname}.md-meta.xml`);
    const newRecordContent = getRecordTemplate(createConfig.label, createConfig.protected, buildCustomFieldXml(createConfig.fileData, createConfig.varargs, createConfig.ignorefields));
    return fs.promises.writeFile(outputFilePath, newRecordContent);
};
exports.createRecord = createRecord;
/**
 * Get the field primitive type from the custom metadata type that has a matching field name.
 *
 * @param  fileData Array of objects based on metadata type xml
 * @param  fieldName Name of the field
 * @return {string} Type used by a custom metadata record
 */
const getFieldPrimitiveType = (fileData = [], fieldName) => {
    const matchingFile = fileData.find((file) => file.fullName === fieldName);
    if (matchingFile && typeof matchingFile.type === 'string' && ['Number', 'Percent'].includes(matchingFile.type)) {
        return getNumberType(matchingFile.type, matchingFile.scale);
    }
    if (matchingFile && typeof matchingFile.type === 'string') {
        return fieldTypeMap.get(matchingFile.type) ?? 'string';
    }
    return 'string';
};
exports.getFieldPrimitiveType = getFieldPrimitiveType;
/**
 * Filenames should have the suffix of '__mdt'. This will append that suffix if it does not exist.
 *
 * @param  typename Name of file
 */
const appendDirectorySuffix = (typename) => typename.endsWith('__mdt') ? typename : `${typename}__mdt`;
exports.appendDirectorySuffix = appendDirectorySuffix;
/**
 * Goes through the file data that has been genreated and gets all of the field names and adds the
 * name of the field that is used as the label for metadata record
 *
 * @param  fileData Array of objects based on metadata type xml
 * @param  nameField name of the column that is going to be used for the name of the metadata record
 * @return [] Array of field names
 */
const getFieldNames = (fileData, nameField) => [
    ...fileData.map((file) => file.fullName).filter(ts_types_1.isString),
    nameField,
];
exports.getFieldNames = getFieldNames;
/**
 * Takes JSON representation of CLI varargs and converts them to xml with help
 * from helper.getFieldTemplate
 *
 * @param  cliParams Object that holds key:value pairs from CLI input
 * @param  fileData Array of objects that contain field data
 * @return {string} String representation of XML
 */
const buildCustomFieldXml = (fileData = [], cliParams = {}, ignoreFields = false) => {
    let ret = '';
    for (const fieldName of Object.keys(cliParams)) {
        const type = (0, exports.getFieldPrimitiveType)(fileData, fieldName);
        const dataType = (0, exports.getFieldDataType)(fileData, fieldName);
        // Added functionality to handle the igonre fields scenario.
        if ((0, templates_1.canConvert)(dataType) || !ignoreFields) {
            ret += getFieldTemplate(fieldName, cliParams[fieldName], type);
        }
    }
    return ret;
};
/**
 * Get the number type based on the scale.
 * If the scale === 0, it is an int, otherwise it is a double.
 *
 * @param  type Number or Percent
 * @param  scale 0 or another number
 * @return {string} int or double
 */
const getNumberType = (type, scale) => ['Number', 'Percent'].includes(type) && scale === 0 ? 'int' : 'double';
/**
 * Template for a single customMetadata record value. This is used by helper.getRecordTemplate.
 *
 * @param  fieldName Field API Name (i.e, Foo__c)
 * @param  val Value of the field
 * @param  type Field type (i.e. boolean, dateTime, date, string, double)
 * @return {string} String representation of XML
 */
const getFieldTemplate = (fieldName, val, type) => {
    const cleanValue = String(val).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    const value = val === null || val === '' ? '<value xsi:nil="true"/>' : `<value xsi:type="xsd:${type}">${cleanValue}</value>`;
    return `
    <values>
        <field>${fieldName}</field>
        ${value}
    </values>`;
};
/**
 * Template to compile entire customMetadata record
 *
 * @param  label Name of the record
 * @param  protection Is the record protected?
 * @param  values Template string representation of values
 * @return {string} String representation of XML
 */
const getRecordTemplate = (label, protection = false, values) => `
<?xml version="1.0" encoding="UTF-8"?>
<CustomMetadata xmlns="http://soap.sforce.com/2006/04/metadata" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <label>${label}</label>
    <protected>${protection}</protected>${values}
</CustomMetadata>`.trim();
//# sourceMappingURL=createUtil.js.map