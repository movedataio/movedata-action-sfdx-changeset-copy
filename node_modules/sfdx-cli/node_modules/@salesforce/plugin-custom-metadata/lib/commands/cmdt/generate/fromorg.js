"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const createUtil_1 = require("../../../shared/helpers/createUtil");
const fileWriter_1 = require("../../../shared/helpers/fileWriter");
const metadataUtil_1 = require("../../../shared/helpers/metadataUtil");
const validationUtil_1 = require("../../../shared/helpers/validationUtil");
const templates_1 = require("../../../shared/templates/templates");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-custom-metadata', 'fromorg');
class Generate extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Generate);
        const conn = flags['target-org'].getConnection(flags['api-version']);
        // use default target org connection to get object describe if no source is provided.
        const describeObj = await conn.metadata.read('CustomObject', flags.sobject);
        // throw error if the object doesnot exist(empty json as response from the describe call.)
        if ((0, kit_1.isEmpty)(describeObj.fields)) {
            const errMsg = messages.getMessage('sobjectnameNoResultError', [flags.sobject]);
            throw new core_1.SfError(errMsg, 'sobjectnameNoResultError');
        }
        // check for custom setting
        if (describeObj.customSettingsType) {
            // if custom setting check for type and visibility
            if (!(0, metadataUtil_1.validCustomSettingType)(describeObj)) {
                const errMsg = messages.getMessage('customSettingTypeError', [flags.sobject]);
                throw new core_1.SfError(errMsg, 'customSettingTypeError');
            }
        }
        const label = flags.label ?? flags['dev-name'];
        const pluralLabel = flags['plural-label'] ?? label;
        const { 'type-output-directory': outputDir, 'records-output-dir': recordsOutputDir } = flags;
        try {
            this.spinner.start('creating the CMDT object');
            // create custom metadata type
            const objectXML = (0, templates_1.createObjectXML)({ label, pluralLabel }, flags.visibility);
            await (0, fileWriter_1.writeTypeFile)(fs, outputDir, flags['dev-name'], objectXML);
            this.spinner.status = 'creating the CMDT fields';
            // get all the field details before creating field metadata
            const fields = (0, metadataUtil_1.describeObjFields)(describeObj)
                // added type check here to skip the creation of un supported fields
                .filter((f) => !flags['ignore-unsupported'] || (0, templates_1.canConvert)(f['type']))
                .flatMap((f) => 
            // check for Geo Location fields before hand and create two different fields for longitude and latitude.
            f.type !== 'Location' ? [f] : convertLocationFieldToText(f));
            // create custom metdata fields
            await Promise.all(fields.map((f) => (0, fileWriter_1.writeFieldFile)(fs, path.join(outputDir, `${flags['dev-name']}__mdt`), f.fullName, (0, templates_1.createFieldXML)(f, !flags['ignore-unsupported']))));
            this.spinner.status = 'creating the CMDT records';
            // if customMetadata folder does not exist, create it
            await fs.promises.mkdir(recordsOutputDir, { recursive: true });
            const fieldDirPath = path.join(outputDir, `${flags['dev-name']}__mdt`, 'fields');
            const fileNames = await fs.promises.readdir(fieldDirPath);
            const fileData = await (0, createUtil_1.getFileData)(fieldDirPath, fileNames);
            // query records from source
            const sObjectRecords = await conn.query(getSoqlQuery(describeObj));
            await Promise.all(sObjectRecords.records.map((rec) => {
                const record = (0, metadataUtil_1.cleanQueryResponse)(rec, describeObj);
                const lblName = rec['Name'];
                const recordName = (0, validationUtil_1.isValidMetadataRecordName)(lblName) ? lblName : lblName.replace(/ +/g, '_');
                return (0, createUtil_1.createRecord)({
                    typename: flags['dev-name'],
                    recordname: recordName,
                    label: lblName,
                    inputdir: outputDir,
                    outputdir: recordsOutputDir,
                    protected: flags.visibility !== 'Public',
                    varargs: record,
                    fileData,
                    ignorefields: flags['ignore-unsupported'],
                });
            }));
            this.spinner.stop('custom metadata type and records creation in completed');
            this.log(`Congrats! Created a ${flags['dev-name']} custom metadata type with ${sObjectRecords.records.length} records!`);
        }
        catch (e) {
            const targetDir = `${outputDir}${flags['dev-name']}__mdt`;
            // dir might not exist if we never got to the creation step
            if (fs.existsSync(targetDir)) {
                await fs.promises.rm(targetDir, { recursive: true });
            }
            await Promise.all((await fs.promises.readdir(recordsOutputDir))
                .filter((f) => f.startsWith(flags['dev-name']))
                .map((f) => fs.promises.unlink(path.join(recordsOutputDir, f))));
            this.spinner.stop('generate command failed to run');
            const errMsg = messages.getMessage('generateError', [e instanceof Error ? e.message : 'unknown error']);
            throw new core_1.SfError(errMsg, 'generateError');
        }
        return { outputDir, recordsOutputDir };
    }
}
exports.default = Generate;
_a = Generate;
Generate.summary = messages.getMessage('summary');
Generate.description = messages.getMessage('description');
Generate.examples = messages.getMessages('examples');
Generate.requiresProject = true;
Generate.aliases = ['force:cmdt:generate'];
Generate.flags = {
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    loglevel: sf_plugins_core_1.loglevel,
    // flag with a value (-n, --name=VALUE)
    'dev-name': sf_plugins_core_1.Flags.string({
        char: 'n',
        required: true,
        summary: messages.getMessage('flags.dev-name.summary'),
        parse: async (input) => Promise.resolve((0, validationUtil_1.validateMetadataTypeName)(input)),
        aliases: ['devname'],
    }),
    label: sf_plugins_core_1.Flags.string({
        char: 'l',
        summary: messages.getMessage('flags.label.summary'),
    }),
    'plural-label': sf_plugins_core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.plural-label.summary'),
        aliases: ['plurallabel'],
    }),
    visibility: sf_plugins_core_1.Flags.string({
        char: 'v',
        summary: messages.getMessage('flags.visibility.summary'),
        description: messages.getMessage('flags.visibility.description'),
        options: ['PackageProtected', 'Protected', 'Public'],
        default: 'Public',
    }),
    sobject: sf_plugins_core_1.Flags.string({
        char: 's',
        required: true,
        summary: messages.getMessage('flags.sobject.summary'),
        parse: async (sobjectname) => Promise.resolve((0, validationUtil_1.validateAPIName)(sobjectname)),
        aliases: ['sobjectname'],
    }),
    'ignore-unsupported': sf_plugins_core_1.Flags.boolean({
        char: 'i',
        summary: messages.getMessage('flags.ignore-unsupported.summary'),
        description: messages.getMessage('flags.ignore-unsupported.description'),
        aliases: ['ignoreunsupported'],
    }),
    'type-output-directory': sf_plugins_core_1.Flags.directory({
        char: 'd',
        summary: messages.getMessage('flags.type-output-directory.summary'),
        default: path.join('force-app', 'main', 'default', 'objects'),
        aliases: ['typeoutputdir'],
    }),
    'records-output-dir': sf_plugins_core_1.Flags.directory({
        char: 'r',
        summary: messages.getMessage('flags.records-output-dir.summary'),
        default: path.join('force-app', 'main', 'default', 'customMetadata'),
        aliases: ['recordsoutputdir'],
    }),
};
const getSoqlQuery = (describeResult) => {
    const fieldNames = describeResult.fields.map((field) => field.fullName).join(',');
    // Added Name hardcoded as Name field is not retrieved as part of object describe.
    return `SELECT Name, ${fieldNames} FROM ${describeResult.fullName}`;
};
const convertLocationFieldToText = (field) => {
    const baseTextField = {
        required: field['required'],
        trackHistory: field['trackHistory'],
        trackTrending: field['trackTrending'],
        type: 'Text',
        length: 40,
        summaryFilterItems: [],
    };
    return ['Lat_', 'Long_'].map((prefix) => ({
        ...baseTextField,
        fullName: `${prefix}${field.fullName}`,
        label: `${prefix}${field.label}`,
    }));
};
//# sourceMappingURL=fromorg.js.map