"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const createUtil_1 = require("../../../shared/helpers/createUtil");
const validationUtil_1 = require("../../../shared/helpers/validationUtil");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-custom-metadata', 'record');
class Create extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags, args, argv } = await this.parse(Create);
        const varargs = (0, sf_plugins_core_1.parseVarArgs)(args, argv);
        const label = flags.label ?? flags['record-name'];
        const protectedFlag = flags.protected === 'true';
        const dirName = (0, createUtil_1.appendDirectorySuffix)(flags['type-name']);
        const fieldDirPath = path.join(flags['input-directory'], dirName, 'fields');
        const fileNames = await fs.promises.readdir(fieldDirPath);
        // if customMetadata folder does not exist, create it
        await fs.promises.mkdir(flags['output-directory'], { recursive: true });
        const fileData = await (0, createUtil_1.getFileData)(fieldDirPath, fileNames);
        await (0, createUtil_1.createRecord)({
            typename: flags['type-name'],
            recordname: flags['record-name'],
            label,
            inputdir: flags['input-directory'],
            outputdir: flags['output-directory'],
            protected: protectedFlag,
            varargs,
            fileData,
        });
        this.log(messages.getMessage('successResponse', [
            flags['type-name'],
            flags['record-name'],
            label,
            protectedFlag,
            flags['output-directory'],
        ]));
        // Return an object to be displayed with --json
        return {
            typename: flags['type-name'],
            recordname: flags['record-name'],
            label,
            inputdir: flags['input-directory'],
            outputdir: flags['output-directory'],
            protectedFlag,
            varargs,
            fileData,
        };
    }
}
exports.default = Create;
_a = Create;
Create.strict = false;
Create.summary = messages.getMessage('summary');
Create.description = messages.getMessage('description');
Create.requiresProject = true;
Create.aliases = ['force:cmdt:record:create', 'cmdt:record:create'];
Create.examples = messages.getMessages('examples');
Create.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    'type-name': sf_plugins_core_1.Flags.string({
        char: 't',
        summary: messages.getMessage('flags.type-name.summary'),
        required: true,
        parse: async (input) => Promise.resolve((0, validationUtil_1.validateMetadataTypeName)(input)),
        aliases: ['typename'],
    }),
    'record-name': sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.record-name.summary'),
        required: true,
        parse: async (input) => Promise.resolve((0, validationUtil_1.validateMetadataRecordName)(input)),
        aliases: ['recordname'],
    }),
    label: sf_plugins_core_1.Flags.string({
        char: 'l',
        summary: messages.getMessage('flags.label.summary'),
        parse: async (input) => Promise.resolve((0, validationUtil_1.validateLessThanForty)(input, messages.getMessage('notAValidLabelNameError', [input]))),
    }),
    // I hate this flag so much, but have to preserve it
    protected: sf_plugins_core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.protected.summary'),
        description: messages.getMessage('flags.protected.description'),
        options: ['true', 'false'],
        default: 'false',
    }),
    'input-directory': sf_plugins_core_1.Flags.directory({
        char: 'i',
        summary: messages.getMessage('flags.input-directory.summary'),
        default: path.join('force-app', 'main', 'default', 'objects'),
        aliases: ['inputdir', 'inputdirectory'],
        exists: true,
    }),
    'output-directory': sf_plugins_core_1.Flags.directory({
        char: 'd',
        summary: messages.getMessage('flags.output-directory.summary'),
        default: path.join('force-app', 'main', 'default', 'customMetadata'),
        aliases: ['outputdir', 'outputdirectory'],
    }),
};
//# sourceMappingURL=record.js.map