"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const path = require("path");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const csv = require("../../../../csvtojson");
const createUtil_1 = require("../../../shared/helpers/createUtil");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-custom-metadata', 'records');
class Insert extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Insert);
        const dirName = (0, createUtil_1.appendDirectorySuffix)(flags['type-name']);
        const fieldDirPath = path.join(flags['input-directory'], dirName, 'fields');
        const fileNames = await fs.promises.readdir(fieldDirPath);
        // if customMetadata folder does not exist, create it
        await fs.promises.mkdir(flags['output-directory'], { recursive: true });
        const fileData = await (0, createUtil_1.getFileData)(fieldDirPath, fileNames);
        const csvDataAry = (await csv().fromFile(flags.csv));
        const metadataTypeFields = (0, createUtil_1.getFieldNames)(fileData, flags['name-column']);
        if (csvDataAry.length > 0) {
            const record = csvDataAry[0];
            for (const key in record) {
                if (!metadataTypeFields.includes(key)) {
                    throw new core_1.SfError(messages.getMessage('fieldNotFoundError', [key, flags['type-name']]));
                }
            }
        }
        // find the cmdt in the inputdir.
        // loop through files and create records that match fields
        const recordConfigs = csvDataAry.map((record) => ({
            typename: flags['type-name'],
            recordname: record[flags['name-column']].replace(' ', '_'),
            label: record[flags['name-column']],
            inputdir: flags['input-directory'],
            outputdir: flags['output-directory'],
            protected: false,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            varargs: Object.fromEntries(
            // TODO: throw an error if any of the fields in the csvDataAry do not exist in the fileData
            fileData.map((file) => {
                if (file.fullName) {
                    return record[file.fullName] ? [file.fullName, record[file.fullName]] : [];
                }
                else {
                    throw new core_1.SfError('No fullName found in fileData');
                }
            })),
            fileData,
        }));
        await Promise.all(recordConfigs.map((r) => (0, createUtil_1.createRecord)(r)));
        this.log(messages.getMessage('successResponse', [flags.csv, flags['output-directory']]));
        return recordConfigs;
    }
}
exports.default = Insert;
Insert.summary = messages.getMessage('summary');
Insert.description = messages.getMessage('description');
Insert.requiresProject = true;
Insert.aliases = ['force:cmdt:record:insert', 'cmdt:record:insert'];
Insert.examples = messages.getMessages('examples');
Insert.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    csv: sf_plugins_core_1.Flags.string({
        char: 'f',
        summary: messages.getMessage('flags.csv.summary'),
        required: true,
        aliases: ['filepath'],
    }),
    'type-name': sf_plugins_core_1.Flags.string({
        char: 't',
        summary: messages.getMessage('flags.type-name.summary'),
        description: messages.getMessage('flags.type-name.description'),
        required: true,
        parse: (input) => Promise.resolve(input.endsWith('__mdt') ? input.replace('__mdt', '') : input),
        aliases: ['typename'],
    }),
    'input-directory': sf_plugins_core_1.Flags.directory({
        char: 'i',
        summary: messages.getMessage('flags.input-directory.summary'),
        default: path.join('force-app', 'main', 'default', 'objects'),
        aliases: ['inputdir', 'inputdirectory'],
        exists: true,
    }),
    'output-directory': sf_plugins_core_1.Flags.directory({
        char: 'd',
        summary: messages.getMessage('flags.output-directory.summary'),
        default: path.join('force-app', 'main', 'default', 'customMetadata'),
        aliases: ['outputdir', 'outputdirectory'],
    }),
    'name-column': sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.name-column.summary'),
        default: 'Name',
        aliases: ['namecolumn'],
    }),
};
//# sourceMappingURL=records.js.map