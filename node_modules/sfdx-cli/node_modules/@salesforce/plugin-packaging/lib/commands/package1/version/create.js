"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package1VersionCreateCommand = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const packaging_1 = require("@salesforce/packaging");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package1_version_create');
class Package1VersionCreateCommand extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Package1VersionCreateCommand);
        const version = this.parseVersion(flags.version);
        if (flags.wait) {
            // if we're waiting for the request, set up the listener
            core_1.Lifecycle.getInstance().on(packaging_1.PackageVersionEvents.create.progress, 
            // the 'on' method requires an async method, but we don't have any async calls
            // eslint-disable-next-line @typescript-eslint/require-await
            async (data) => {
                this.log(`Package upload is ${data.pollingResult.Status === 'QUEUED' ? 'enqueued' : 'in progress'}. Waiting ${data.timeout} more seconds`);
            });
        }
        const result = await packaging_1.Package1Version.create(flags['target-org'].getConnection(flags['api-version']), {
            MetadataPackageId: flags['package-id'],
            VersionName: flags.name,
            Description: flags.description,
            MajorVersion: version.major,
            MinorVersion: version.minor,
            IsReleaseVersion: flags['managed-released'],
            ReleaseNotesUrl: flags['release-notes-url'],
            PostInstallUrl: flags['post-install-url'],
            Password: flags['installation-key'],
        }, { frequency: kit_1.Duration.seconds(5), timeout: flags.wait ?? kit_1.Duration.seconds(0) });
        const arg = result.Status === 'SUCCESS'
            ? [result.MetadataPackageVersionId]
            : [this.config.bin, result.Id, flags['target-org'].getUsername()];
        this.log(messages.getMessage(result.Status, arg));
        return result;
    }
    // eslint-disable-next-line class-methods-use-this
    parseVersion(versionString) {
        const versions = versionString?.split('.');
        if (!versions) {
            // return nulls so when no version flag is provided, the server can infer the correct version
            return { major: undefined, minor: undefined };
        }
        if (versions.length === 2) {
            return {
                major: Number(versions[0]),
                minor: Number(versions[1]),
            };
        }
        else {
            throw messages.createError('package1VersionCreateCommandInvalidVersion', [versionString]);
        }
    }
}
exports.Package1VersionCreateCommand = Package1VersionCreateCommand;
Package1VersionCreateCommand.summary = messages.getMessage('summary');
Package1VersionCreateCommand.description = messages.getMessage('description');
Package1VersionCreateCommand.examples = messages.getMessages('examples');
Package1VersionCreateCommand.requiresProject = true;
Package1VersionCreateCommand.deprecateAliases = true;
Package1VersionCreateCommand.aliases = ['force:package1:beta:version:create', 'force:package1:version:create'];
Package1VersionCreateCommand.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    'package-id': sf_plugins_core_1.Flags.salesforceId({
        length: 'both',
        deprecateAliases: true,
        aliases: ['packageid'],
        char: 'i',
        summary: messages.getMessage('flags.package-id.summary'),
        required: true,
        startsWith: '033',
    }),
    name: sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.name.summary'),
        required: true,
    }),
    description: sf_plugins_core_1.Flags.string({
        char: 'd',
        summary: messages.getMessage('flags.description.summary'),
    }),
    version: sf_plugins_core_1.Flags.string({
        char: 'v',
        summary: messages.getMessage('flags.version.summary'),
    }),
    'managed-released': sf_plugins_core_1.Flags.boolean({
        char: 'm',
        deprecateAliases: true,
        aliases: ['managedrelease'],
        summary: messages.getMessage('flags.managed-release.summary'),
        description: messages.getMessage('flags.managed-release.description'),
    }),
    'release-notes-url': sf_plugins_core_1.Flags.string({
        char: 'r',
        deprecateAliases: true,
        aliases: ['releasenotesurl'],
        summary: messages.getMessage('flags.release-notes-url.summary'),
        description: messages.getMessage('flags.release-notes-url.description'),
    }),
    'post-install-url': sf_plugins_core_1.Flags.string({
        char: 'p',
        deprecateAliases: true,
        aliases: ['postinstallurl'],
        summary: messages.getMessage('flags.post-install-url.summary'),
        description: messages.getMessage('flags.post-install-url.description'),
    }),
    'installation-key': sf_plugins_core_1.Flags.string({
        char: 'k',
        deprecateAliases: true,
        aliases: ['installationkey'],
        summary: messages.getMessage('flags.installation-key.summary'),
    }),
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        summary: messages.getMessage('flags.wait.summary'),
    }),
};
//# sourceMappingURL=create.js.map