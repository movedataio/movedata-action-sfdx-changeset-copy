"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Install = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const packaging_1 = require("@salesforce/packaging");
const report_1 = require("./install/report");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package_install');
// maps of command flag values to PackageInstallRequest values
const securityType = { AllUsers: 'full', AdminsOnly: 'none' };
const upgradeType = { Delete: 'delete-only', DeprecateOnly: 'deprecate-only', Mixed: 'mixed-mode' };
class Install extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(Install);
        const noPrompt = flags['no-prompt'];
        this.connection = flags['target-org'].getConnection(flags['api-version']);
        const apiVersion = parseInt(this.connection.getApiVersion(), 10);
        if (apiVersion < 36) {
            throw messages.createError('apiVersionTooLow');
        }
        this.subscriberPackageVersion = new packaging_1.SubscriberPackageVersion({
            connection: this.connection,
            aliasOrId: flags.package,
            password: flags['installation-key'],
        });
        const request = {
            SubscriberPackageVersionKey: await this.subscriberPackageVersion.getId(),
            Password: flags['installation-key'],
            ApexCompileType: flags['apex-compile'],
            SecurityType: securityType[flags['security-type']],
            SkipHandlers: flags['skip-handlers']?.join(','),
            UpgradeType: upgradeType[flags['upgrade-type']],
        };
        // eslint-disable-next-line @typescript-eslint/require-await
        core_1.Lifecycle.getInstance().on(packaging_1.PackageEvents.install.warning, async (warningMsg) => {
            this.warn(warningMsg);
        });
        if (flags['publish-wait']?.milliseconds > 0) {
            let timeThen = Date.now();
            // waiting for publish to finish
            let remainingTime = flags['publish-wait'];
            core_1.Lifecycle.getInstance().on(packaging_1.PackageEvents.install['subscriber-status'], 
            // eslint-disable-next-line @typescript-eslint/require-await
            async (publishStatus) => {
                const elapsedTime = kit_1.Duration.milliseconds(Date.now() - timeThen);
                timeThen = Date.now();
                remainingTime = kit_1.Duration.milliseconds(remainingTime.milliseconds - elapsedTime.milliseconds);
                const status = publishStatus === 'NO_ERRORS_DETECTED'
                    ? messages.getMessage('availableForInstallation')
                    : messages.getMessage('unavailableForInstallation');
                this.spinner.status = messages.getMessage('packagePublishWaitingStatus', [remainingTime.minutes, status]);
            });
            this.spinner.start(messages.getMessage('packagePublishWaitingStatus', [remainingTime.minutes, 'Querying Status']));
            await this.subscriberPackageVersion.waitForPublish({
                publishTimeout: flags['publish-wait'],
                publishFrequency: kit_1.Duration.seconds(10),
                installationKey: flags['installation-key'],
            });
            // need to stop the spinner to avoid weird behavior with the prompts below
            this.spinner.stop();
        }
        // If the user has specified --upgradetype Delete, then prompt for confirmation
        // unless the noprompt option has been included.
        if (flags['upgrade-type'] === 'Delete') {
            await this.confirmUpgradeType(noPrompt);
        }
        // If the package has external sites, ask the user for permission to enable them
        // unless the noprompt option has been included.
        await this.confirmExternalSites(request, noPrompt);
        let installOptions;
        if (flags.wait) {
            installOptions = {
                pollingTimeout: flags.wait,
            };
            let remainingTime = flags.wait;
            let timeThen = Date.now();
            this.spinner.start(messages.getMessage('packageInstallWaiting', [remainingTime.minutes]));
            // waiting for package install to finish
            core_1.Lifecycle.getInstance().on(packaging_1.PackageEvents.install.status, 
            // eslint-disable-next-line @typescript-eslint/require-await
            async (piRequest) => {
                const elapsedTime = kit_1.Duration.milliseconds(Date.now() - timeThen);
                timeThen = Date.now();
                remainingTime = kit_1.Duration.milliseconds(remainingTime.milliseconds - elapsedTime.milliseconds);
                this.spinner.status = messages.getMessage('packageInstallWaitingStatus', [
                    remainingTime.minutes,
                    piRequest.Status,
                ]);
            });
        }
        let pkgInstallRequest;
        try {
            pkgInstallRequest = await this.subscriberPackageVersion.install(request, installOptions);
            this.spinner.stop();
        }
        catch (error) {
            if (error instanceof core_1.SfError && error.data) {
                pkgInstallRequest = error.data;
                this.spinner.stop(messages.getMessage('packageInstallPollingTimeout'));
            }
            else {
                throw error;
            }
        }
        finally {
            if (pkgInstallRequest) {
                this.log(report_1.Report.parseStatus(this.config.bin, pkgInstallRequest, flags['target-org'].getUsername(), flags.package));
            }
        }
        return pkgInstallRequest;
    }
    async finally(err) {
        // Remove all the event listeners or they will still handle events
        core_1.Lifecycle.getInstance().removeAllListeners(packaging_1.PackageEvents.install.warning);
        core_1.Lifecycle.getInstance().removeAllListeners(packaging_1.PackageEvents.install.status);
        core_1.Lifecycle.getInstance().removeAllListeners(packaging_1.PackageEvents.install['subscriber-status']);
        await super.finally(err);
    }
    async confirmUpgradeType(noPrompt) {
        if ((await this.subscriberPackageVersion.getPackageType()) === 'Unlocked' && !noPrompt) {
            const promptMsg = messages.getMessage('prompt-upgrade-type');
            if (!(await this.confirm(promptMsg))) {
                throw messages.createError('promptUpgradeTypeDeny');
            }
        }
    }
    async confirmExternalSites(request, noPrompt) {
        const extSites = await this.subscriberPackageVersion.getExternalSites();
        if (extSites) {
            let enableRss = true;
            if (!noPrompt) {
                const promptMsg = messages.getMessage('promptEnableRss', [extSites.join('\n')]);
                enableRss = await this.confirm(promptMsg);
            }
            if (enableRss) {
                request.EnableRss = enableRss;
            }
        }
    }
}
exports.Install = Install;
Install.summary = messages.getMessage('summary');
Install.description = messages.getMessage('description');
Install.examples = messages.getMessages('examples');
Install.deprecateAliases = true;
Install.aliases = ['force:package:beta:install', 'force:package:install'];
Install.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    'target-org': sf_plugins_core_1.requiredOrgFlagWithDeprecations,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    wait: sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'w',
        summary: messages.getMessage('flags.wait.summary'),
        default: kit_1.Duration.minutes(0),
    }),
    'installation-key': sf_plugins_core_1.Flags.string({
        char: 'k',
        deprecateAliases: true,
        aliases: ['installationkey'],
        summary: messages.getMessage('flags.installation-key.summary'),
    }),
    'publish-wait': sf_plugins_core_1.Flags.duration({
        unit: 'minutes',
        char: 'b',
        deprecateAliases: true,
        aliases: ['publishwait'],
        summary: messages.getMessage('flags.publish-wait.summary'),
        default: kit_1.Duration.minutes(0),
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        char: 'r',
        deprecateAliases: true,
        aliases: ['noprompt'],
        summary: messages.getMessage('flags.no-prompt.summary'),
        description: messages.getMessage('flags.no-prompt.description'),
    }),
    package: sf_plugins_core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.package.summary'),
        required: true,
    }),
    'apex-compile': sf_plugins_core_1.Flags.custom({
        options: ['all', 'package'],
    })({
        char: 'a',
        deprecateAliases: true,
        aliases: ['apexcompile'],
        summary: messages.getMessage('flags.apex-compile.summary'),
        description: messages.getMessage('flags.apex-compile.description'),
        default: 'all',
    }),
    'security-type': sf_plugins_core_1.Flags.custom({
        options: ['AllUsers', 'AdminsOnly'],
    })({
        char: 's',
        deprecateAliases: true,
        aliases: ['securitytype'],
        summary: messages.getMessage('flags.security-type.summary'),
        default: 'AdminsOnly',
    }),
    'upgrade-type': sf_plugins_core_1.Flags.custom({
        options: ['DeprecateOnly', 'Mixed', 'Delete'],
    })({
        char: 't',
        deprecateAliases: true,
        aliases: ['upgradetype'],
        summary: messages.getMessage('flags.upgrade-type.summary'),
        description: messages.getMessage('flags.upgrade-type.description'),
        default: 'Mixed',
    }),
    'skip-handlers': sf_plugins_core_1.Flags.string({
        multiple: true,
        options: ['FeatureEnforcement'],
        char: 'l',
        summary: messages.getMessage('flags.skip-handlers.summary'),
        description: messages.getMessage('flags.skip-handlers.description'),
        hidden: true,
    }),
};
//# sourceMappingURL=install.js.map