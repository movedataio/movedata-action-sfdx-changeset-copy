"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageVersionListCommand = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const packaging_1 = require("@salesforce/packaging");
const hubFlag_1 = require("../../../utils/hubFlag");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'package_version_list');
const packaging = core_1.Messages.loadMessages('@salesforce/plugin-packaging', 'packaging');
class PackageVersionListCommand extends sf_plugins_core_1.SfCommand {
    async run() {
        const { flags } = await this.parse(PackageVersionListCommand);
        const connection = flags['target-dev-hub'].getConnection(flags['api-version']);
        const project = core_1.SfProject.getInstance();
        const records = await packaging_1.Package.listVersions(connection, project, {
            createdLastDays: flags['created-last-days'],
            concise: flags.concise,
            modifiedLastDays: flags['modified-last-days'],
            packages: flags.packages?.split(',') ?? [],
            isReleased: flags.released,
            orderBy: flags['order-by'],
            verbose: flags.verbose,
        });
        const results = [];
        if (records?.length > 0) {
            let ancestorVersionsMap;
            // lookup ancestorVersions if ancestorIds are present
            const ancestorIds = records.filter((record) => record.AncestorId).map((record) => record.AncestorId);
            if (ancestorIds?.length > 0) {
                ancestorVersionsMap = await (0, packaging_1.getPackageVersionStrings)(ancestorIds, connection);
            }
            // Get the container options for each package version. We need this for determining if the version is OrgDependent
            const recordIds = [...new Set(records.map((record) => record.Package2Id))];
            const containerOptionsMap = await (0, packaging_1.getContainerOptions)(recordIds, connection);
            records.forEach((record) => {
                const ids = [record.Id, record.SubscriberPackageVersionId];
                const aliases = ids.map((id) => project.getAliasesFromPackageId(id)).flat();
                const AliasStr = aliases.length > 0 ? aliases.join() : '';
                // set Ancestor display values
                let ancestorVersion;
                if (record.AncestorId) {
                    ancestorVersion = ancestorVersionsMap?.get(record.AncestorId);
                }
                else if (containerOptionsMap.get(record.Package2Id) !== 'Managed') {
                    // display N/A if package is unlocked
                    ancestorVersion = 'N/A';
                    record.AncestorId = 'N/A';
                }
                const codeCoverage = record.CodeCoverage?.apexCodeCoveragePercentage != null
                    ? `${record.CodeCoverage.apexCodeCoveragePercentage.toString()}%`
                    : record.Package2.IsOrgDependent || record.ValidationSkipped
                        ? 'N/A'
                        : '';
                const hasPassedCodeCoverageCheck = record.Package2.IsOrgDependent === true || record.ValidationSkipped
                    ? 'N/A'
                    : record.HasPassedCodeCoverageCheck;
                const isOrgDependent = containerOptionsMap.get(record.Package2Id) === 'Managed'
                    ? 'N/A'
                    : record.Package2.IsOrgDependent
                        ? 'Yes'
                        : 'No';
                const hasMetadataRemoved = containerOptionsMap.get(record.Package2Id) !== 'Managed' ? 'N/A' : record.HasMetadataRemoved ? 'Yes' : 'No';
                results.push({
                    Package2Id: record.Package2Id,
                    Branch: record.Branch,
                    Tag: record.Tag,
                    MajorVersion: record.MajorVersion,
                    MinorVersion: record.MinorVersion,
                    PatchVersion: record.PatchVersion,
                    BuildNumber: record.BuildNumber,
                    Id: record.Id,
                    SubscriberPackageVersionId: record.SubscriberPackageVersionId,
                    ConvertedFromVersionId: record.ConvertedFromVersionId,
                    Name: record.Name,
                    NamespacePrefix: record.Package2.NamespacePrefix,
                    Package2Name: record.Package2.Name,
                    Description: record.Description,
                    Version: [record.MajorVersion, record.MinorVersion, record.PatchVersion, record.BuildNumber].join('.'),
                    // Table output needs string false to display 'false'
                    IsPasswordProtected: flags.json ? record.IsPasswordProtected : record.IsPasswordProtected.toString(),
                    IsReleased: flags.json ? record.IsReleased : record.IsReleased.toString(),
                    CreatedDate: new Date(record.CreatedDate).toISOString().replace('T', ' ').substring(0, 16),
                    LastModifiedDate: new Date(record.LastModifiedDate).toISOString().replace('T', ' ').substring(0, 16),
                    InstallUrl: packaging_1.INSTALL_URL_BASE.toString() + record.SubscriberPackageVersionId,
                    CodeCoverage: codeCoverage,
                    HasPassedCodeCoverageCheck: hasPassedCodeCoverageCheck,
                    ValidationSkipped: record.ValidationSkipped,
                    AncestorId: record.AncestorId,
                    AncestorVersion: ancestorVersion,
                    Alias: AliasStr,
                    IsOrgDependent: isOrgDependent,
                    ReleaseVersion: record.ReleaseVersion == null ? '' : Number.parseFloat(record.ReleaseVersion).toFixed(1),
                    BuildDurationInSeconds: record.BuildDurationInSeconds == null ? '' : record.BuildDurationInSeconds,
                    HasMetadataRemoved: hasMetadataRemoved,
                    CreatedBy: record.CreatedById,
                    Language: record.Language,
                });
            });
            this.styledHeader(`Package Versions [${results.length}]`);
            this.table(results, this.getColumnData(flags.concise, flags.verbose), { 'no-truncate': true });
        }
        else {
            this.warn('No results found');
        }
        return results;
    }
    // eslint-disable-next-line class-methods-use-this
    getColumnData(concise, verbose) {
        if (concise) {
            return {
                Package2Id: { header: messages.getMessage('package-id') },
                Version: { header: messages.getMessage('version') },
                SubscriberPackageVersionId: {
                    header: messages.getMessage('subscriberPackageVersionId'),
                },
                IsReleased: { header: 'Released' },
            };
        }
        const defaultCols = {
            Package2Name: { header: 'Package Name' },
            NamespacePrefix: { header: 'Namespace' },
            Name: { header: 'Version Name' },
            Version: { header: messages.getMessage('version') },
            SubscriberPackageVersionId: {
                header: messages.getMessage('subscriberPackageVersionId'),
            },
            Alias: { header: messages.getMessage('alias') },
            IsPasswordProtected: { header: messages.getMessage('installKey') },
            IsReleased: { header: 'Released' },
            ValidationSkipped: { header: messages.getMessage('validationSkipped') },
            AncestorId: { header: 'Ancestor' },
            AncestorVersion: { header: 'Ancestor Version' },
            Branch: { header: messages.getMessage('packageBranch') },
        };
        if (!verbose) {
            return defaultCols;
        }
        else {
            // add additional columns for verbose output
            return {
                ...defaultCols,
                Package2Id: { header: messages.getMessage('package-id') },
                InstallUrl: { header: messages.getMessage('installUrl') },
                Id: { header: messages.getMessage('id') },
                CreatedDate: { header: 'Created Date' },
                LastModifiedDate: { header: 'Last Modified Date' },
                Tag: { header: messages.getMessage('packageTag') },
                Description: { header: messages.getMessage('description') },
                CodeCoverage: { header: messages.getMessage('codeCoverage') },
                HasPassedCodeCoverageCheck: {
                    header: messages.getMessage('hasPassedCodeCoverageCheck'),
                },
                ConvertedFromVersionId: {
                    header: messages.getMessage('convertedFromVersionId'),
                },
                IsOrgDependent: { header: messages.getMessage('isOrgDependent') },
                ReleaseVersion: { header: messages.getMessage('releaseVersion') },
                BuildDurationInSeconds: {
                    header: messages.getMessage('buildDurationInSeconds'),
                },
                HasMetadataRemoved: {
                    header: messages.getMessage('hasMetadataRemoved'),
                },
                CreatedBy: { header: messages.getMessage('createdBy') },
                Language: { header: messages.getMessage('language') },
            };
        }
    }
}
exports.PackageVersionListCommand = PackageVersionListCommand;
PackageVersionListCommand.summary = messages.getMessage('summary');
PackageVersionListCommand.description = messages.getMessage('description');
PackageVersionListCommand.examples = messages.getMessages('examples');
PackageVersionListCommand.deprecateAliases = true;
PackageVersionListCommand.aliases = ['force:package:beta:version:list', 'force:package:version:list'];
PackageVersionListCommand.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    'target-dev-hub': hubFlag_1.requiredHubFlag,
    'api-version': sf_plugins_core_1.orgApiVersionFlagWithDeprecations,
    'created-last-days': sf_plugins_core_1.Flags.integer({
        char: 'c',
        deprecateAliases: true,
        aliases: ['createdlastdays'],
        summary: packaging.getMessage('flags.created-last-days.summary'),
    }),
    concise: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.concise.summary'),
    }),
    'modified-last-days': sf_plugins_core_1.Flags.integer({
        char: 'm',
        deprecateAliases: true,
        aliases: ['modifiedlastdays'],
        summary: packaging.getMessage('flags.modified-last-days.summary'),
    }),
    packages: sf_plugins_core_1.Flags.string({
        char: 'p',
        summary: messages.getMessage('flags.packages.summary'),
    }),
    released: sf_plugins_core_1.Flags.boolean({
        char: 'r',
        summary: messages.getMessage('flags.released.summary'),
    }),
    'order-by': sf_plugins_core_1.Flags.string({
        // eslint-disable-next-line sf-plugin/dash-o
        char: 'o',
        deprecateAliases: true,
        aliases: ['orderby'],
        summary: messages.getMessage('flags.order-by.summary'),
    }),
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
};
//# sourceMappingURL=list.js.map